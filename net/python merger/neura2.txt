
========================================
# File: C:\Users\Saem1001\Documents\GitHub\ai_detect\net\neural_ide_2\setup.py
========================================

import subprocess
import sys

def install(package):
    """Installs a package using pip."""
    subprocess.check_call([sys.executable, "-m", "pip", "install", package])

def main():
    """
    Main function to install all required and optional dependencies.
    """
    print("Starting setup...")
    
    # List of required packages
    required_packages = [
        "pylint",
        "flake8",
        "mypy",
        "bandit",
        "radon",
        "vulture",
        "openai",
        "networkx",
        "matplotlib",
        "psutil",
        "numpy",
        "pyyaml",
        "websockets",
        "beautifulsoup4",
        "requests"
    ]

    print("Installing required packages...")
    for package in required_packages:
        try:
            print(f"Installing {package}...")
            install(package)
            print(f"Successfully installed {package}")
        except Exception as e:
            print(f"Failed to install {package}. Error: {e}")
            
    print("\nSetup complete. Please ensure you have the GitHub CLI installed and authenticated for Copilot features.")
    print("You can do this by running 'gh auth login' and 'gh extension install github/gh-copilot'.")

if __name__ == "__main__":
    main()

========================================
# File: C:\Users\Saem1001\Documents\GitHub\ai_detect\net\neural_ide_2\start_here.py
========================================

#!/usr/bin/env python3
"""
Neural Script IDE Launcher
Handles dependency installation and launches the main application
"""

import sys
import subprocess
import os
from pathlib import Path
import platform

def check_python_version():
    """Check if Python version is compatible"""
    if sys.version_info < (3, 7):
        print("Error: Python 3.7 or higher is required")
        print(f"Current version: {sys.version}")
        return False
    return True

def check_requirements():
    """Check if required packages are installed"""
    required = {
        'tkinter': 'tkinter',
        'pylint': 'pylint',
        'networkx': 'networkx',
        'matplotlib': 'matplotlib',
        'psutil': 'psutil',
        'numpy': 'numpy',
        'yaml': 'pyyaml',
        'websockets': 'websockets'
    }
    
    optional = {
        'flake8': 'flake8',
        'mypy': 'mypy',
        'bandit': 'bandit',
        'radon': 'radon',
        'vulture': 'vulture',
        'openai': 'openai'
    }
    
    missing = []
    optional_missing = []
    
    # Check required packages
    for module, package in required.items():
        try:
            __import__(module)
        except ImportError:
            missing.append(package)
    
    # Check optional packages
    for module, package in optional.items():
        try:
            __import__(module)
        except ImportError:
            optional_missing.append(package)
            
    return missing, optional_missing

def install_requirements(packages):
    """Install required packages"""
    if not packages:
        return True
        
    print(f"\nInstalling required packages: {', '.join(packages)}")
    print("This may take a few minutes...\n")
    
    try:
        # Upgrade pip first
        subprocess.check_call([sys.executable, "-m", "pip", "install", "--upgrade", "pip"])
        
        # Install packages
        subprocess.check_call([sys.executable, "-m", "pip", "install"] + packages)
        
        print("\n‚úì Installation complete!")
        return True
        
    except subprocess.CalledProcessError as e:
        print(f"\n‚úó Installation failed: {e}")
        return False
    except Exception as e:
        print(f"\n‚úó Unexpected error: {e}")
        return False

def create_desktop_shortcut():
    """Create desktop shortcut (Windows only)"""
    if platform.system() != "Windows":
        return
        
    try:
        import winshell
        from win32com.client import Dispatch
        
        desktop = winshell.desktop()
        path = os.path.join(desktop, "Neural Script IDE.lnk")
        target = sys.executable
        wDir = os.path.dirname(os.path.abspath(__file__))
        args = os.path.abspath(__file__)
        icon = target
        
        shell = Dispatch('WScript.Shell')
        shortcut = shell.CreateShortCut(path)
        shortcut.Targetpath = target
        shortcut.Arguments = args
        shortcut.WorkingDirectory = wDir
        shortcut.IconLocation = icon
        shortcut.save()
        
        print(f"Desktop shortcut created: {path}")
        
    except:
        pass  # Silently fail if can't create shortcut

def main():
    """Main launcher function"""
    print("=" * 60)
    print("Neural Script IDE Launcher")
    print("=" * 60)
    
    # Check Python version
    if not check_python_version():
        input("\nPress Enter to exit...")
        sys.exit(1)
    
    # Check requirements
    missing, optional_missing = check_requirements()
    
    if missing:
        print(f"\nRequired packages not found: {', '.join(missing)}")
        response = input("Install required packages? (y/n): ")
        
        if response.lower() == 'y':
            if not install_requirements(missing):
                input("\nPress Enter to exit...")
                sys.exit(1)
        else:
            print("\nCannot run without required packages.")
            input("Press Enter to exit...")
            sys.exit(1)
    
    if optional_missing:
        print(f"\nOptional packages not found: {', '.join(optional_missing)}")
        print("These enhance functionality but are not required.")
        response = input("Install optional packages? (y/n): ")
        
        if response.lower() == 'y':
            install_requirements(optional_missing)
    
    # Check if main script exists
    script_dir = Path(__file__).parent
    main_script = script_dir / "neural_script_ide.py"
    
    if not main_script.exists():
        print(f"\nError: Main script not found at {main_script}")
        print("Please ensure neural_script_ide.py is in the same directory as the launcher.")
        
        # Offer to create it
        response = input("\nCreate neural_script_ide.py with the full IDE code? (y/n): ")
        if response.lower() == 'y':
            print("\nPlease save the Neural Script IDE code as 'neural_script_ide.py' in this directory.")
            print("Then run the launcher again.")
        
        input("\nPress Enter to exit...")
        sys.exit(1)
    
    # Create desktop shortcut on first run
    config_file = Path.home() / ".neural_script_ide_first_run"
    if not config_file.exists():
        create_desktop_shortcut()
        config_file.touch()
    
    # Launch the IDE
    print("\nLaunching Neural Script IDE...")
    print("-" * 60)
    
    try:
        # Import and run
        sys.path.insert(0, str(script_dir))
        from neural_script_ide import main as run_ide
        run_ide()
        
    except ImportError as e:
        print(f"\nError importing main script: {e}")
        input("\nPress Enter to exit...")
        sys.exit(1)
        
    except Exception as e:
        print(f"\nError launching IDE: {e}")
        import traceback
        traceback.print_exc()
        input("\nPress Enter to exit...")
        sys.exit(1)

if __name__ == "__main__":
    # Handle command line arguments
    if len(sys.argv) > 1:
        if sys.argv[1] == "--help":
            print("Neural Script IDE Launcher")
            print("\nUsage: python launch_neural_ide.py [options]")
            print("\nOptions:")
            print("  --help          Show this help message")
            print("  --no-install    Skip package installation")
            print("  --force-install Force reinstall all packages")
            sys.exit(0)
            
        elif sys.argv[1] == "--no-install":
            # Skip directly to running
            script_dir = Path(__file__).parent
            sys.path.insert(0, str(script_dir))
            from neural_script_ide import main as run_ide
            run_ide()
            sys.exit(0)
            
        elif sys.argv[1] == "--force-install":
            # Force reinstall all packages
            packages = ['pylint', 'networkx', 'matplotlib', 'psutil', 'numpy', 'pyyaml', 'websockets']
            install_requirements(packages)
            
    main()

========================================
# File: C:\Users\Saem1001\Documents\GitHub\ai_detect\net\neural_ide_2\app\auto_fix.py
========================================

import subprocess
import os
import sys
from openai import OpenAI
import requests
from bs4 import BeautifulSoup

class AutoFixer:
    """
    A class to automatically diagnose and fix errors in Python scripts.
    """

    def __init__(self, file_path, api_key=None):
        self.file_path = file_path
        self.openai_client = OpenAI(api_key=api_key) if api_key else None

    def run_script(self):
        """Runs the script and captures its output and errors."""
        try:
            result = subprocess.run(
                [sys.executable, self.file_path],
                capture_output=True,
                text=True,
                check=False  # We want to handle non-zero exit codes ourselves
            )
            return result.stdout, result.stderr
        except FileNotFoundError:
            return None, f"Error: Script not found at {self.file_path}"

    def search_for_fix(self, error_message):
        """Searches for a fix online, focusing on Stack Overflow."""
        if not error_message:
            return "No error message provided."

        query = f"site:stackoverflow.com python {error_message.strip()}"
        print(f"Searching online for: '{query}'")
        
        try:
            response = requests.get("https://www.google.com/search", params={'q': query})
            response.raise_for_status()
            
            soup = BeautifulSoup(response.text, 'html.parser')
            
            # Find the first Stack Overflow link
            link_tag = soup.find('a', href=lambda href: href and "stackoverflow.com/questions" in href)
            
            if not link_tag:
                return "Could not find a relevant Stack Overflow link."

            url = link_tag['href']
            # Clean up the URL from Google's redirect
            if url.startswith('/url?q='):
                url = url.split('&')[0].replace('/url?q=', '')

            print(f"Found potential solution at: {url}")
            return self.scrape_stack_overflow_solution(url)
            
        except requests.exceptions.RequestException as e:
            return f"Failed to search for a fix: {e}"

    def scrape_stack_overflow_solution(self, url):
        """Scrapes the highest-voted answer from a Stack Overflow page."""
        try:
            response = requests.get(url)
            response.raise_for_status()
            soup = BeautifulSoup(response.text, 'html.parser')

            # Find the highest-voted answer
            answer = soup.find('div', class_='answer', 'data-answerid'=True)
            if answer:
                return answer.get_text(separator='\n', strip=True)
            return "Could not find a suitable answer on the page."

        except requests.exceptions.RequestException as e:
            return f"Failed to scrape Stack Overflow page: {e}"

    def get_ai_fix(self, original_code, error_message, online_solution):
        """Uses AI to generate a fix based on the error and online solution."""
        if not self.openai_client:
            return "OpenAI client not initialized. Cannot generate AI fix."

        prompt = f"""
        The following Python code has an error.
        
        Original Code:
        ---
        {original_code}
        ---

        Error Message:
        ---
        {error_message}
        ---

        A potential solution found online suggests:
        ---
        {online_solution}
        ---

        Based on all this information, please provide the fully corrected Python code.
        Only output the code, with no additional explanation.
        """
        
        try:
            resp = self.openai_client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[{"role": "user", "content": prompt}]
            )
            return resp.choices[0].message.content
        except Exception as e:
            return f"OpenAI API error during fix generation: {e}"

    def apply_fix(self, fixed_code):
        """Applies the fixed code to the original file."""
        try:
            # Create a backup of the original file
            backup_path = self.file_path + ".bak"
            os.rename(self.file_path, backup_path)
            print(f"Backup of original file created at: {backup_path}")

            with open(self.file_path, 'w') as f:
                f.write(fixed_code)
            return "Fix applied successfully."
        except Exception as e:
            return f"Failed to apply fix: {e}"

def main():
    """Main function to demonstrate the AutoFixer."""
    
    # --- Configuration ---
    # !! IMPORTANT !!
    # This feature uses AI and web scraping and can modify your files.
    # Always review changes and ensure you have backups.
    
    file_to_fix = "test_script.py"  # The script to be fixed
    OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

    # Create a dummy script with an error for demonstration
    with open(file_to_fix, 'w') as f:
        f.write("import os\n\ndef my_function():\n    print(os.get_login())\n\nmy_function()")

    fixer = AutoFixer(file_to_fix, api_key=OPENAI_API_KEY)

    print(f"--- Running initial script: {file_to_fix} ---")
    stdout, stderr = fixer.run_script()

    if stderr:
        print("\n--- Error Detected ---")
        print(stderr)

        print("\n--- Searching for a fix online ---")
        online_solution = fixer.search_for_fix(stderr)
        print(online_solution)

        if online_solution:
            print("\n--- Generating AI-powered fix ---")
            with open(file_to_fix + ".bak", 'r') if os.path.exists(file_to_fix + ".bak") else open(file_to_fix, 'r') as f:
                original_code = f.read()
                
            ai_generated_fix = fixer.get_ai_fix(original_code, stderr, online_solution)
            print("AI Suggestion:\n", ai_generated_fix)

            print("\n--- Applying the fix ---")
            status = fixer.apply_fix(ai_generated_fix)
            print(status)
            
            if "success" in status.lower():
                print("\n--- Verifying the fix by re-running the script ---")
                new_stdout, new_stderr = fixer.run_script()

                if new_stderr:
                    print("\n--- The script still has errors after the fix ---")
                    print(new_stderr)
                else:
                    print("\n--- Script ran successfully after the fix! ---")
                    print("Output:")
                    print(new_stdout)
    else:
        print("\n--- Script ran successfully with no errors ---")
        print("Output:")
        print(stdout)

if __name__ == "__main__":
    main()

========================================
# File: C:\Users\Saem1001\Documents\GitHub\ai_detect\net\neural_ide_2\app\builder_gui.py
========================================

#!/usr/bin/env python3
"""
Neural Script IDE - Production Version
A sophisticated IDE for building neural networks from interconnected Python scripts
Features:
- Advanced inter-script communication with message passing
- Real-time dependency visualization
- Advanced debugging and profiling
- Automatic logic and data flow checking
- Script orchestration and scheduling
- Performance monitoring
- Visual script relationship mapping
"""

import tkinter as tk
from tkinter import ttk, filedialog, messagebox, scrolledtext
import subprocess
import threading
import queue
import platform
import os
import sys
import json
import re
import ast
import tempfile
import time
from pathlib import Path
from datetime import datetime
import pickle
import socket
import multiprocessing
from multiprocessing import Queue, Process, Manager
import networkx as nx
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import traceback
import psutil
import inspect
from typing import Dict, List, Any, Optional, Tuple
import asyncio
import websockets
import yaml
from dataclasses import dataclass, asdict
from enum import Enum
import logging
from collections import defaultdict, deque
import numpy as np

# Try to import optional dependencies
try:
    import pylint.lint
    import pylint.reporters.text
    from io import StringIO
    HAS_PYLINT = True
except ImportError:
    HAS_PYLINT = False

# Setup logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class MessageType(Enum):
    """Types of inter-script messages"""
    DATA = "data"
    CONTROL = "control"
    STATUS = "status"
    ERROR = "error"
    LOG = "log"
    METRIC = "metric"
    HEARTBEAT = "heartbeat"

@dataclass
class ScriptMessage:
    """Message structure for inter-script communication"""
    sender_id: str
    receiver_id: str
    message_type: MessageType
    payload: Any
    timestamp: float = None
    
    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = time.time()
    
    def to_dict(self):
        return {
            'sender_id': self.sender_id,
            'receiver_id': self.receiver_id,
            'message_type': self.message_type.value,
            'payload': self.payload,
            'timestamp': self.timestamp
        }
    
    @classmethod
    def from_dict(cls, data):
        return cls(
            sender_id=data['sender_id'],
            receiver_id=data['receiver_id'],
            message_type=MessageType(data['message_type']),
            payload=data['payload'],
            timestamp=data.get('timestamp', time.time())
        )

class ScriptNode:
    """Represents a script in the neural network"""
    def __init__(self, script_id: str, file_path: str = None):
        self.id = script_id
        self.file_path = file_path
        self.dependencies = set()  # Scripts this node depends on
        self.dependents = set()    # Scripts that depend on this node
        self.inputs = {}           # Expected inputs
        self.outputs = {}          # Expected outputs
        self.status = "idle"       # idle, running, completed, error
        self.metrics = {
            'cpu_usage': 0,
            'memory_usage': 0,
            'message_count': 0,
            'error_count': 0,
            'execution_time': 0
        }
        self.process = None
        self.last_heartbeat = time.time()

class MessageBroker:
    """Central message broker for inter-script communication"""
    def __init__(self):
        self.manager = Manager()
        self.message_queue = self.manager.Queue()
        self.subscribers = self.manager.dict()
        self.message_history = deque(maxlen=1000)
        self.running = False
        self.broker_thread = None
        
    def start(self):
        """Start the message broker"""
        self.running = True
        self.broker_thread = threading.Thread(target=self._broker_loop, daemon=True)
        self.broker_thread.start()
        
    def stop(self):
        """Stop the message broker"""
        self.running = False
        if self.broker_thread:
            self.broker_thread.join(timeout=1)
            
    def _broker_loop(self):
        """Main broker loop for routing messages"""
        while self.running:
            try:
                if not self.message_queue.empty():
                    message = self.message_queue.get(timeout=0.1)
                    self._route_message(message)
            except queue.Empty:
                pass
            except Exception as e:
                logger.error(f"Broker error: {e}")
            time.sleep(0.01)
            
    def _route_message(self, message: ScriptMessage):
        """Route message to appropriate receiver"""
        self.message_history.append(message)
        
        if message.receiver_id == "BROADCAST":
            # Broadcast to all scripts
            for script_id, queue_obj in self.subscribers.items():
                if script_id != message.sender_id:
                    try:
                        queue_obj.put(message.to_dict())
                    except:
                        pass
        elif message.receiver_id in self.subscribers:
            # Direct message
            try:
                self.subscribers[message.receiver_id].put(message.to_dict())
            except:
                pass
                
    def subscribe(self, script_id: str) -> Queue:
        """Subscribe a script to receive messages"""
        script_queue = self.manager.Queue()
        self.subscribers[script_id] = script_queue
        return script_queue
        
    def unsubscribe(self, script_id: str):
        """Unsubscribe a script"""
        if script_id in self.subscribers:
            del self.subscribers[script_id]
            
    def send_message(self, message: ScriptMessage):
        """Send a message through the broker"""
        self.message_queue.put(message)

class ScriptDebugger:
    """Advanced debugger for script analysis"""
    def __init__(self):
        self.breakpoints = defaultdict(set)
        self.watch_variables = defaultdict(list)
        self.profiling_data = defaultdict(dict)
        
    def analyze_script(self, script_content: str, script_id: str) -> Dict:
        """Analyze script for potential issues and patterns"""
        analysis = {
            'syntax_errors': [],
            'logic_warnings': [],
            'dependencies': [],
            'input_patterns': [],
            'output_patterns': [],
            'complexity_score': 0,
            'suggested_optimizations': []
        }
        
        try:
            # Parse AST
            tree = ast.parse(script_content)
            
            # Find imports and dependencies
            for node in ast.walk(tree):
                if isinstance(node, ast.Import):
                    for alias in node.names:
                        analysis['dependencies'].append(alias.name)
                elif isinstance(node, ast.ImportFrom):
                    analysis['dependencies'].append(node.module)
                    
            # Analyze function calls for inter-script communication
            for node in ast.walk(tree):
                if isinstance(node, ast.Call):
                    if isinstance(node.func, ast.Attribute):
                        if node.func.attr in ['send_message', 'receive_message', 'broadcast']:
                            # Found inter-script communication
                            analysis['output_patterns'].append({
                                'type': node.func.attr,
                                'line': node.lineno
                            })
                            
            # Calculate complexity score (simplified McCabe complexity)
            complexity = 0
            for node in ast.walk(tree):
                if isinstance(node, (ast.If, ast.For, ast.While, ast.ExceptHandler)):
                    complexity += 1
            analysis['complexity_score'] = complexity
            
            # Check for common issues
            self._check_logic_issues(tree, analysis)
            
        except SyntaxError as e:
            analysis['syntax_errors'].append({
                'line': e.lineno,
                'message': str(e.msg),
                'offset': e.offset
            })
            
        return analysis
        
    def _check_logic_issues(self, tree: ast.AST, analysis: Dict):
        """Check for common logic issues"""
        # Check for infinite loops
        for node in ast.walk(tree):
            if isinstance(node, ast.While):
                if isinstance(node.test, ast.Constant) and node.test.value is True:
                    analysis['logic_warnings'].append({
                        'type': 'infinite_loop',
                        'line': node.lineno,
                        'message': 'Potential infinite loop detected'
                    })
                    
        # Check for unreachable code
        for node in ast.walk(tree):
            if isinstance(node, ast.FunctionDef):
                for i, stmt in enumerate(node.body):
                    if isinstance(stmt, ast.Return) and i < len(node.body) - 1:
                        analysis['logic_warnings'].append({
                            'type': 'unreachable_code',
                            'line': node.body[i + 1].lineno,
                            'message': 'Unreachable code after return statement'
                        })

class DependencyVisualizer:
    """Visualize script dependencies and data flow"""
    def __init__(self, parent):
        self.parent = parent
        self.graph = nx.DiGraph()
        self.positions = {}
        self.figure = None
        self.canvas = None
        
    def update_graph(self, scripts: Dict[str, ScriptNode]):
        """Update the dependency graph"""
        self.graph.clear()
        
        # Add nodes
        for script_id, node in scripts.items():
            self.graph.add_node(script_id, 
                              status=node.status,
                              metrics=node.metrics)
            
        # Add edges
        for script_id, node in scripts.items():
            for dep in node.dependencies:
                if dep in scripts:
                    self.graph.add_edge(dep, script_id)
                    
    def draw(self, frame: tk.Frame):
        """Draw the dependency graph"""
        if self.figure:
            plt.close(self.figure)
            
        self.figure = plt.Figure(figsize=(8, 6), dpi=100)
        ax = self.figure.add_subplot(111)
        
        if len(self.graph.nodes) > 0:
            # Calculate positions
            if not self.positions or set(self.positions.keys()) != set(self.graph.nodes):
                self.positions = nx.spring_layout(self.graph, k=2, iterations=50)
                
            # Color nodes based on status
            node_colors = []
            for node in self.graph.nodes:
                status = self.graph.nodes[node].get('status', 'idle')
                if status == 'running':
                    node_colors.append('#FFA500')
                elif status == 'completed':
                    node_colors.append('#00FF00')
                elif status == 'error':
                    node_colors.append('#FF0000')
                else:
                    node_colors.append('#87CEEB')
                    
            # Draw graph
            nx.draw(self.graph, self.positions, ax=ax,
                   node_color=node_colors,
                   node_size=2000,
                   font_size=10,
                   font_weight='bold',
                   arrows=True,
                   edge_color='gray',
                   width=2)
            
            # Add labels with metrics
            labels = {}
            for node in self.graph.nodes:
                metrics = self.graph.nodes[node].get('metrics', {})
                labels[node] = f"{node}\nCPU: {metrics.get('cpu_usage', 0):.1f}%"
                
            nx.draw_networkx_labels(self.graph, self.positions, labels, 
                                  font_size=8, ax=ax)
                                  
        ax.set_title("Script Dependency Graph")
        ax.axis('off')
        
        # Embed in tkinter
        if self.canvas:
            self.canvas.get_tk_widget().destroy()
            
        self.canvas = FigureCanvasTkAgg(self.figure, frame)
        self.canvas.draw()
        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)

class ScriptOrchestrator:
    """Orchestrate script execution based on dependencies"""
    def __init__(self, message_broker: MessageBroker):
        self.message_broker = message_broker
        self.scripts = {}
        self.execution_order = []
        self.running = False
        
    def add_script(self, script_node: ScriptNode):
        """Add a script to the orchestrator"""
        self.scripts[script_node.id] = script_node
        self._update_execution_order()
        
    def _update_execution_order(self):
        """Calculate execution order based on dependencies"""
        # Build dependency graph
        graph = nx.DiGraph()
        for script_id, node in self.scripts.items():
            graph.add_node(script_id)
            for dep in node.dependencies:
                if dep in self.scripts:
                    graph.add_edge(dep, script_id)
                    
        # Check for cycles
        if not nx.is_directed_acyclic_graph(graph):
            raise ValueError("Circular dependencies detected!")
            
        # Topological sort
        self.execution_order = list(nx.topological_sort(graph))
        
    def execute_all(self, parallel: bool = True):
        """Execute all scripts respecting dependencies"""
        if parallel:
            self._execute_parallel()
        else:
            self._execute_sequential()
            
    def _execute_sequential(self):
        """Execute scripts sequentially"""
        for script_id in self.execution_order:
            if script_id in self.scripts:
                node = self.scripts[script_id]
                logger.info(f"Executing {script_id}")
                # Execute script and wait for completion
                # Implementation depends on script execution mechanism
                
    def _execute_parallel(self):
        """Execute scripts in parallel respecting dependencies"""
        completed = set()
        running = set()
        
        while len(completed) < len(self.scripts):
            # Find scripts ready to run
            ready = []
            for script_id in self.execution_order:
                if script_id not in completed and script_id not in running:
                    node = self.scripts[script_id]
                    # Check if all dependencies are completed
                    if all(dep in completed for dep in node.dependencies):
                        ready.append(script_id)
                        
            # Start ready scripts
            for script_id in ready:
                logger.info(f"Starting {script_id}")
                running.add(script_id)
                # Start script execution
                # Monitor for completion
                
            time.sleep(0.1)

class EnhancedScriptTab:
    """Enhanced script tab with advanced features"""
    def __init__(self, parent, tab_id, runner):
        self.parent = parent
        self.tab_id = tab_id
        self.runner = runner
        self.script_node = ScriptNode(f"script_{tab_id}")
        self.process = None
        self.output_queue = queue.Queue()
        self.message_queue = None
        self.file_path = None
        self.last_saved_content = ""
        self.syntax_errors = []
        self.logic_analysis = {}
        self.performance_monitor = None
        
        self.setup_ui()
        self._setup_message_handler()
        
    def setup_ui(self):
        """Setup enhanced UI for this script tab"""
        # Main container with notebook for multiple views
        self.frame = ttk.Frame(self.parent)
        self.frame.pack(fill=tk.BOTH, expand=True)
        
        # Create notebook for different views
        self.view_notebook = ttk.Notebook(self.frame)
        self.view_notebook.pack(fill=tk.BOTH, expand=True)
        
        # Editor view
        self.editor_frame = ttk.Frame(self.view_notebook)
        self.view_notebook.add(self.editor_frame, text="Editor")
        self._setup_editor_view()
        
        # Debug view
        self.debug_frame = ttk.Frame(self.view_notebook)
        self.view_notebook.add(self.debug_frame, text="Debug")
        self._setup_debug_view()
        
        # Messages view
        self.messages_frame = ttk.Frame(self.view_notebook)
        self.view_notebook.add(self.messages_frame, text="Messages")
        self._setup_messages_view()
        
        # Metrics view
        self.metrics_frame = ttk.Frame(self.view_notebook)
        self.view_notebook.add(self.metrics_frame, text="Metrics")
        self._setup_metrics_view()
        
    def _setup_editor_view(self):
        """Setup the main editor view"""
        # Paned window for editor and output
        paned = ttk.PanedWindow(self.editor_frame, orient=tk.VERTICAL)
        paned.pack(fill=tk.BOTH, expand=True)
        
        # Top frame for editor
        editor_container = ttk.LabelFrame(paned, text="Script Editor", padding=5)
        paned.add(editor_container, weight=3)
        
        # Enhanced toolbar
        toolbar = ttk.Frame(editor_container)
        toolbar.pack(fill=tk.X, pady=(0, 5))
        
        # File operations
        file_frame = ttk.Frame(toolbar)
        file_frame.pack(side=tk.LEFT, padx=5)
        ttk.Button(file_frame, text="üìÅ Load", command=self.load_file).pack(side=tk.LEFT, padx=2)
        ttk.Button(file_frame, text="üíæ Save", command=self.save_file).pack(side=tk.LEFT, padx=2)
        
        ttk.Separator(toolbar, orient='vertical').pack(side=tk.LEFT, fill='y', padx=5)
        
        # Execution controls
        exec_frame = ttk.Frame(toolbar)
        exec_frame.pack(side=tk.LEFT, padx=5)
        ttk.Button(exec_frame, text="‚ñ∂Ô∏è Run", command=self.run_script).pack(side=tk.LEFT, padx=2)
        ttk.Button(exec_frame, text="‚è∏Ô∏è Debug", command=self.debug_script).pack(side=tk.LEFT, padx=2)
        ttk.Button(exec_frame, text="‚èπÔ∏è Stop", command=self.stop_script).pack(side=tk.LEFT, padx=2)
        
        ttk.Separator(toolbar, orient='vertical').pack(side=tk.LEFT, fill='y', padx=5)
        
        # Analysis controls
        analysis_frame = ttk.Frame(toolbar)
        analysis_frame.pack(side=tk.LEFT, padx=5)
        ttk.Button(analysis_frame, text="‚úì Check", command=self.analyze_script).pack(side=tk.LEFT, padx=2)
        ttk.Button(analysis_frame, text="üîç Profile", command=self.profile_script).pack(side=tk.LEFT, padx=2)
        
        # Status
        self.status_label = ttk.Label(toolbar, text="Ready", foreground="green")
        self.status_label.pack(side=tk.RIGHT, padx=5)
        
        # Editor with enhanced features
        editor_container_inner = ttk.Frame(editor_container)
        editor_container_inner.pack(fill=tk.BOTH, expand=True)
        
        # Line numbers
        self.line_numbers = tk.Text(editor_container_inner, width=5, padx=3, takefocus=0,
                                   wrap=tk.NONE, state='disabled',
                                   font=("Consolas", 10))
        self.line_numbers.pack(side=tk.LEFT, fill=tk.Y)
        
        # Main editor
        self.editor = scrolledtext.ScrolledText(editor_container_inner, wrap=tk.NONE,
                                               font=("Consolas", 10), undo=True,
                                               maxundo=-1)
        self.editor.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        # Syntax highlighting setup
        self._setup_syntax_highlighting()
        
        # Analysis panel
        self.analysis_text = scrolledtext.ScrolledText(editor_container, height=5, 
                                                      wrap=tk.WORD,
                                                      font=("Consolas", 9))
        # Initially hidden
        
        # Bind events
        self.editor.bind('<KeyRelease>', self.on_editor_change)
        self.editor.bind('<Control-s>', lambda e: self.save_file())
        self.editor.bind('<F5>', lambda e: self.run_script())
        
        # Output frame
        output_frame = ttk.LabelFrame(paned, text="Output", padding=5)
        paned.add(output_frame, weight=2)
        
        # Output controls
        output_toolbar = ttk.Frame(output_frame)
        output_toolbar.pack(fill=tk.X, pady=(0, 5))
        
        ttk.Button(output_toolbar, text="Clear", command=self.clear_output).pack(side=tk.LEFT, padx=2)
        ttk.Button(output_toolbar, text="Copy", command=self.copy_output).pack(side=tk.LEFT, padx=2)
        
        self.auto_scroll = tk.BooleanVar(value=True)
        ttk.Checkbutton(output_toolbar, text="Auto-scroll", 
                       variable=self.auto_scroll).pack(side=tk.LEFT, padx=10)
        
        # Filter options
        ttk.Label(output_toolbar, text="Filter:").pack(side=tk.LEFT, padx=5)
        self.output_filter = tk.StringVar(value="all")
        filter_combo = ttk.Combobox(output_toolbar, textvariable=self.output_filter,
                                   values=["all", "stdout", "stderr", "messages", "metrics"],
                                   width=10, state="readonly")
        filter_combo.pack(side=tk.LEFT)
        
        # Output text with tabs
        output_notebook = ttk.Notebook(output_frame)
        output_notebook.pack(fill=tk.BOTH, expand=True)
        
        # Console output
        self.output = scrolledtext.ScrolledText(output_notebook, wrap=tk.WORD,
                                               font=("Consolas", 9),
                                               state='disabled')
        output_notebook.add(self.output, text="Console")
        
        # Message log
        self.message_log = scrolledtext.ScrolledText(output_notebook, wrap=tk.WORD,
                                                    font=("Consolas", 9),
                                                    state='disabled')
        output_notebook.add(self.message_log, text="Messages")
        
        # Configure output tags
        self.output.tag_config("stdout", foreground="black")
        self.output.tag_config("stderr", foreground="red")
        self.output.tag_config("system", foreground="blue", font=("Consolas", 9, "italic"))
        self.output.tag_config("debug", foreground="purple")
        self.output.tag_config("message_in", foreground="green")
        self.output.tag_config("message_out", foreground="orange")
        
        self.update_line_numbers()
        
    def _setup_debug_view(self):
        """Setup debug view with advanced debugging features"""
        # Debug toolbar
        toolbar = ttk.Frame(self.debug_frame)
        toolbar.pack(fill=tk.X, pady=5)
        
        ttk.Button(toolbar, text="Set Breakpoint", command=self.set_breakpoint).pack(side=tk.LEFT, padx=2)
        ttk.Button(toolbar, text="Step Over", command=self.step_over).pack(side=tk.LEFT, padx=2)
        ttk.Button(toolbar, text="Step Into", command=self.step_into).pack(side=tk.LEFT, padx=2)
        ttk.Button(toolbar, text="Continue", command=self.continue_execution).pack(side=tk.LEFT, padx=2)
        
        # Debug panels
        debug_paned = ttk.PanedWindow(self.debug_frame, orient=tk.HORIZONTAL)
        debug_paned.pack(fill=tk.BOTH, expand=True)
        
        # Variables panel
        var_frame = ttk.LabelFrame(debug_paned, text="Variables", padding=5)
        debug_paned.add(var_frame, weight=1)
        
        self.variables_tree = ttk.Treeview(var_frame, columns=('value', 'type'), show='tree headings')
        self.variables_tree.heading('#0', text='Name')
        self.variables_tree.heading('value', text='Value')
        self.variables_tree.heading('type', text='Type')
        self.variables_tree.pack(fill=tk.BOTH, expand=True)
        
        # Call stack panel
        stack_frame = ttk.LabelFrame(debug_paned, text="Call Stack", padding=5)
        debug_paned.add(stack_frame, weight=1)
        
        self.call_stack = tk.Listbox(stack_frame, font=("Consolas", 9))
        self.call_stack.pack(fill=tk.BOTH, expand=True)
        
        # Breakpoints panel
        break_frame = ttk.LabelFrame(debug_paned, text="Breakpoints", padding=5)
        debug_paned.add(break_frame, weight=1)
        
        self.breakpoints_list = tk.Listbox(break_frame, font=("Consolas", 9))
        self.breakpoints_list.pack(fill=tk.BOTH, expand=True)
        
    def _setup_messages_view(self):
        """Setup messages view for inter-script communication"""
        # Message controls
        controls = ttk.Frame(self.messages_frame)
        controls.pack(fill=tk.X, pady=5)
        
        ttk.Label(controls, text="Send to:").pack(side=tk.LEFT, padx=5)
        self.message_target = tk.StringVar(value="BROADCAST")
        self.target_combo = ttk.Combobox(controls, textvariable=self.message_target, width=15)
        self.target_combo.pack(side=tk.LEFT, padx=5)
        
        ttk.Label(controls, text="Message:").pack(side=tk.LEFT, padx=5)
        self.message_entry = ttk.Entry(controls, width=40)
        self.message_entry.pack(side=tk.LEFT, padx=5)
        
        ttk.Button(controls, text="Send", command=self.send_message).pack(side=tk.LEFT, padx=5)
        
        # Message history
        history_frame = ttk.LabelFrame(self.messages_frame, text="Message History", padding=5)
        history_frame.pack(fill=tk.BOTH, expand=True)
        
        # Create treeview for messages
        columns = ('time', 'from', 'to', 'type', 'message')
        self.message_tree = ttk.Treeview(history_frame, columns=columns, show='headings')
        
        for col in columns:
            self.message_tree.heading(col, text=col.title())
            self.message_tree.column(col, width=100)
            
        self.message_tree.pack(fill=tk.BOTH, expand=True)
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(history_frame, orient=tk.VERTICAL, command=self.message_tree.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.message_tree.configure(yscrollcommand=scrollbar.set)
        
    def _setup_metrics_view(self):
        """Setup metrics view for performance monitoring"""
        # Metrics display
        metrics_container = ttk.Frame(self.metrics_frame)
        metrics_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Current metrics
        current_frame = ttk.LabelFrame(metrics_container, text="Current Metrics", padding=10)
        current_frame.pack(fill=tk.X, pady=5)
        
        self.metric_labels = {}
        metrics = ['CPU Usage', 'Memory Usage', 'Messages/sec', 'Execution Time', 'Error Count']
        
        for i, metric in enumerate(metrics):
            label_frame = ttk.Frame(current_frame)
            label_frame.grid(row=i//3, column=(i%3)*2, padx=5, pady=2, sticky=tk.W)
            
            ttk.Label(label_frame, text=f"{metric}:").pack(side=tk.LEFT)
            value_label = ttk.Label(label_frame, text="0", font=("Consolas", 10, "bold"))
            value_label.pack(side=tk.LEFT, padx=5)
            self.metric_labels[metric] = value_label
            
        # Performance graph placeholder
        graph_frame = ttk.LabelFrame(metrics_container, text="Performance Graph", padding=5)
        graph_frame.pack(fill=tk.BOTH, expand=True, pady=5)
        
        # Would add matplotlib graph here
        ttk.Label(graph_frame, text="Performance visualization would go here").pack(expand=True)
        
    def _setup_syntax_highlighting(self):
        """Setup syntax highlighting for Python"""
        # Python keywords
        self.editor.tag_config("keyword", foreground="#0000FF", font=("Consolas", 10, "bold"))
        self.editor.tag_config("builtin", foreground="#8B008B")
        self.editor.tag_config("string", foreground="#008000")
        self.editor.tag_config("comment", foreground="#808080", font=("Consolas", 10, "italic"))
        self.editor.tag_config("function", foreground="#FF1493")
        self.editor.tag_config("class", foreground="#FF8C00", font=("Consolas", 10, "bold"))
        self.editor.tag_config("number", foreground="#FF0000")
        
    def _setup_message_handler(self):
        """Setup message handling for inter-script communication"""
        if self.runner.message_broker:
            self.message_queue = self.runner.message_broker.subscribe(self.script_node.id)
            # Start message monitoring thread
            threading.Thread(target=self._monitor_messages, daemon=True).start()
            
    def _monitor_messages(self):
        """Monitor incoming messages"""
        while True:
            try:
                if self.message_queue and not self.message_queue.empty():
                    message_dict = self.message_queue.get(timeout=0.1)
                    message = ScriptMessage.from_dict(message_dict)
                    self.frame.after(0, lambda m=message: self._handle_message(m))
            except queue.Empty:
                pass
            except Exception as e:
                logger.error(f"Message monitoring error: {e}")
            time.sleep(0.01)
            
    def _handle_message(self, message: ScriptMessage):
        """Handle incoming message"""
        # Update message tree
        timestamp = datetime.fromtimestamp(message.timestamp).strftime("%H:%M:%S")
        self.message_tree.insert('', 0, values=(
            timestamp,
            message.sender_id,
            message.receiver_id,
            message.message_type.value,
            str(message.payload)[:100]
        ))
        
        # Log to message output
        self.add_output(f"[MESSAGE IN] From {message.sender_id}: {message.payload}\n", "message_in")
        
        # Handle special message types
        if message.message_type == MessageType.CONTROL:
            self._handle_control_message(message)
            
    def _handle_control_message(self, message: ScriptMessage):
        """Handle control messages"""
        payload = message.payload
        if isinstance(payload, dict):
            action = payload.get('action')
            if action == 'stop':
                self.stop_script()
            elif action == 'pause':
                # Implement pause functionality
                pass
                
    def send_message(self):
        """Send a message to another script"""
        target = self.message_target.get()
        message_text = self.message_entry.get()
        
        if not message_text:
            return
            
        message = ScriptMessage(
            sender_id=self.script_node.id,
            receiver_id=target,
            message_type=MessageType.DATA,
            payload=message_text
        )
        
        self.runner.message_broker.send_message(message)
        
        # Log outgoing message
        self.add_output(f"[MESSAGE OUT] To {target}: {message_text}\n", "message_out")
        
        # Clear entry
        self.message_entry.delete(0, tk.END)
        
    def analyze_script(self):
        """Perform comprehensive script analysis"""
        content = self.editor.get(1.0, tk.END)
        
        # Show analysis panel
        if not self.analysis_text.winfo_viewable():
            self.analysis_text.pack(fill=tk.X, pady=(5, 0))
            
        self.analysis_text.config(state='normal')
        self.analysis_text.delete(1.0, tk.END)
        
        # Perform analysis
        analysis = self.runner.debugger.analyze_script(content, self.script_node.id)
        self.logic_analysis = analysis
        
        # Display results
        self.analysis_text.insert(tk.END, "=== Script Analysis ===\n\n", "header")
        
        # Syntax errors
        if analysis['syntax_errors']:
            self.analysis_text.insert(tk.END, "‚ùå Syntax Errors:\n", "error")
            for error in analysis['syntax_errors']:
                self.analysis_text.insert(tk.END, f"  Line {error['line']}: {error['message']}\n")
        else:
            self.analysis_text.insert(tk.END, "‚úÖ No syntax errors\n", "success")
            
        # Logic warnings
        if analysis['logic_warnings']:
            self.analysis_text.insert(tk.END, "\n‚ö†Ô∏è Logic Warnings:\n", "warning")
            for warning in analysis['logic_warnings']:
                self.analysis_text.insert(tk.END, f"  Line {warning['line']}: {warning['message']}\n")
                
        # Complexity
        self.analysis_text.insert(tk.END, f"\nüìä Complexity Score: {analysis['complexity_score']}\n")
        
        # Dependencies
        if analysis['dependencies']:
            self.analysis_text.insert(tk.END, "\nüì¶ Dependencies:\n")
            for dep in analysis['dependencies']:
                self.analysis_text.insert(tk.END, f"  - {dep}\n")
                
        # Communication patterns
        if analysis['output_patterns']:
            self.analysis_text.insert(tk.END, "\nüí¨ Communication Patterns:\n")
            for pattern in analysis['output_patterns']:
                self.analysis_text.insert(tk.END, f"  - {pattern['type']} at line {pattern['line']}\n")
                
        self.analysis_text.config(state='disabled')
        
        # Update script node dependencies
        self._update_dependencies(analysis['dependencies'])
        
    def _update_dependencies(self, dependencies):
        """Update script node dependencies"""
        # Parse dependencies to find other scripts
        for dep in dependencies:
            if dep.startswith('script_'):
                self.script_node.dependencies.add(dep)
                
        # Update orchestrator
        self.runner.orchestrator.add_script(self.script_node)
        
    def profile_script(self):
        """Profile script performance"""
        messagebox.showinfo("Profiling", "Script profiling will be implemented here")
        
    def debug_script(self):
        """Start script in debug mode"""
        messagebox.showinfo("Debug", "Debug mode will be implemented here")
        
    def set_breakpoint(self):
        """Set a breakpoint at current line"""
        insert = self.editor.index(tk.INSERT)
        line = int(insert.split('.')[0])
        
        self.runner.debugger.breakpoints[self.script_node.id].add(line)
        self.breakpoints_list.insert(tk.END, f"Line {line}")
        
        # Visual indicator
        self.editor.tag_add("breakpoint", f"{line}.0", f"{line}.end")
        self.editor.tag_config("breakpoint", background="#FFCCCC")
        
    def step_over(self):
        """Step over in debug mode"""
        # Implementation for debugging
        pass
        
    def step_into(self):
        """Step into in debug mode"""
        # Implementation for debugging
        pass
        
    def continue_execution(self):
        """Continue execution in debug mode"""
        # Implementation for debugging
        pass
        
    def on_editor_change(self, event=None):
        """Handle editor content changes"""
        self.update_line_numbers()
        self._apply_syntax_highlighting()
        
        # Schedule analysis (debounced)
        if hasattr(self, '_analysis_timer'):
            self.frame.after_cancel(self._analysis_timer)
        self._analysis_timer = self.frame.after(1500, self.analyze_script)
        
    def _apply_syntax_highlighting(self):
        """Apply syntax highlighting to editor content"""
        # Simple Python syntax highlighting
        content = self.editor.get(1.0, tk.END)
        
        # Remove existing tags
        for tag in ["keyword", "string", "comment", "function", "class", "number"]:
            self.editor.tag_remove(tag, 1.0, tk.END)
            
        # Keywords
        import keyword
        for kw in keyword.kwlist:
            start = 1.0
            while True:
                pos = self.editor.search(rf'\b{kw}\b', start, tk.END, regexp=True)
                if not pos:
                    break
                end = f"{pos}+{len(kw)}c"
                self.editor.tag_add("keyword", pos, end)
                start = end
                
        # Strings (simple version)
        for quote in ['"', "'"]:
            start = 1.0
            while True:
                pos = self.editor.search(quote, start, tk.END)
                if not pos:
                    break
                end = self.editor.search(quote, f"{pos}+1c", tk.END)
                if not end:
                    break
                self.editor.tag_add("string", pos, f"{end}+1c")
                start = f"{end}+1c"
                
        # Comments
        start = 1.0
        while True:
            pos = self.editor.search('#', start, tk.END)
            if not pos:
                break
            end = self.editor.search('\n', pos, tk.END)
            if not end:
                end = tk.END
            self.editor.tag_add("comment", pos, end)
            start = end
            
    def update_line_numbers(self):
        """Update line numbers in the editor"""
        self.line_numbers.config(state='normal')
        self.line_numbers.delete(1.0, tk.END)
        
        line_count = self.editor.get(1.0, tk.END).count('\n')
        line_numbers_string = "\n".join(str(i) for i in range(1, line_count + 1))
        self.line_numbers.insert(1.0, line_numbers_string)
        self.line_numbers.config(state='disabled')
        
    def run_script(self):
        """Run the script with enhanced monitoring"""
        if self.process and self.process.poll() is None:
            messagebox.showwarning("Warning", "Script is already running!")
            return
            
        content = self.editor.get(1.0, tk.END).strip()
        if not content:
            messagebox.showwarning("Warning", "No script to run!")
            return
            
        # Perform analysis first
        self.analyze_script()
        
        if self.logic_analysis.get('syntax_errors'):
            if not messagebox.askyesno("Syntax Errors", 
                                     "Syntax errors found. Run anyway?"):
                return
                
        # Inject communication framework
        enhanced_content = self._inject_communication_framework(content)
        
        # Save to temporary file
        with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:
            f.write(enhanced_content)
            self.temp_script = f.name
            
        # Start process with monitoring
        self._start_process_with_monitoring()
        
    def _inject_communication_framework(self, content):
        """Inject inter-script communication framework"""
        framework = '''
import sys
import json
import time
import multiprocessing
from multiprocessing import Queue

# Script communication framework
class ScriptCommunicator:
    def __init__(self, script_id):
        self.script_id = script_id
        self.message_queue = None
        
    def send_message(self, target, payload):
        message = {
            'sender_id': self.script_id,
            'receiver_id': target,
            'message_type': 'data',
            'payload': payload,
            'timestamp': time.time()
        }
        print(f"[SCRIPT_MESSAGE_OUT]{json.dumps(message)}")
        sys.stdout.flush()
        
    def broadcast(self, payload):
        self.send_message('BROADCAST', payload)
        
    def log_metric(self, name, value):
        message = {
            'sender_id': self.script_id,
            'receiver_id': 'SYSTEM',
            'message_type': 'metric',
            'payload': {'name': name, 'value': value},
            'timestamp': time.time()
        }
        print(f"[SCRIPT_METRIC]{json.dumps(message)}")
        sys.stdout.flush()

# Initialize communicator
comm = ScriptCommunicator('{}')

# User script below
{}
'''.format(self.script_node.id, content)
        
        return framework
        
    def _start_process_with_monitoring(self):
        """Start process with enhanced monitoring"""
        try:
            # Create process
            self.process = subprocess.Popen(
                [sys.executable, '-u', self.temp_script],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                stdin=subprocess.PIPE,
                text=True,
                bufsize=1,
                universal_newlines=True
            )
            
            # Update status
            self.script_node.status = "running"
            self.status_label.config(text="Running...", foreground="orange")
            
            # Clear output
            self.clear_output()
            self.add_output(f"Starting script {self.script_node.id}...\n", "system")
            
            # Start monitoring
            self.performance_monitor = threading.Thread(
                target=self._monitor_performance, daemon=True)
            self.performance_monitor.start()
            
            # Start output monitoring
            threading.Thread(target=self._monitor_output, 
                           args=(self.process.stdout, "stdout"), daemon=True).start()
            threading.Thread(target=self._monitor_output, 
                           args=(self.process.stderr, "stderr"), daemon=True).start()
            threading.Thread(target=self._monitor_process, daemon=True).start()
            
            # Update visualization
            self.runner.update_visualization()
            
        except Exception as e:
            self.add_output(f"Failed to start script: {str(e)}\n", "stderr")
            self.script_node.status = "error"
            self.status_label.config(text="Error", foreground="red")
            
    def _monitor_output(self, pipe, tag):
        """Monitor process output with message detection"""
        try:
            for line in pipe:
                # Check for special messages
                if line.startswith("[SCRIPT_MESSAGE_OUT]"):
                    # Parse and route message
                    try:
                        message_data = json.loads(line[20:])
                        message = ScriptMessage.from_dict(message_data)
                        self.runner.message_broker.send_message(message)
                        self.frame.after(0, lambda: self.add_output(
                            f"‚Üí Sent message to {message.receiver_id}\n", "message_out"))
                    except:
                        pass
                elif line.startswith("[SCRIPT_METRIC]"):
                    # Parse metric
                    try:
                        metric_data = json.loads(line[15:])
                        self._update_metric(metric_data['payload'])
                    except:
                        pass
                else:
                    # Regular output
                    self.output_queue.put((line, tag))
                    self.frame.after(0, self.process_output_queue)
        except:
            pass
            
    def _monitor_performance(self):
        """Monitor script performance metrics"""
        if not self.process:
            return
            
        try:
            proc = psutil.Process(self.process.pid)
            
            while self.process and self.process.poll() is None:
                # Get metrics
                cpu_percent = proc.cpu_percent(interval=1)
                memory_info = proc.memory_info()
                memory_mb = memory_info.rss / 1024 / 1024
                
                # Update metrics
                self.script_node.metrics['cpu_usage'] = cpu_percent
                self.script_node.metrics['memory_usage'] = memory_mb
                
                # Update UI
                self.frame.after(0, lambda: self._update_metrics_display())
                
                time.sleep(1)
        except:
            pass
            
    def _update_metrics_display(self):
        """Update metrics display"""
        metrics = self.script_node.metrics
        
        self.metric_labels['CPU Usage'].config(
            text=f"{metrics['cpu_usage']:.1f}%")
        self.metric_labels['Memory Usage'].config(
            text=f"{metrics['memory_usage']:.1f} MB")
        self.metric_labels['Messages/sec'].config(
            text=f"{metrics.get('message_rate', 0):.1f}")
        self.metric_labels['Execution Time'].config(
            text=f"{metrics.get('execution_time', 0):.1f}s")
        self.metric_labels['Error Count'].config(
            text=str(metrics['error_count']))
            
    def _update_metric(self, metric_data):
        """Update custom metric"""
        name = metric_data.get('name')
        value = metric_data.get('value')
        
        if name and value is not None:
            self.script_node.metrics[name] = value
            
    def _monitor_process(self):
        """Monitor process completion"""
        start_time = time.time()
        self.process.wait()
        execution_time = time.time() - start_time
        
        return_code = self.process.returncode
        self.script_node.metrics['execution_time'] = execution_time
        
        self.frame.after(0, lambda: self._on_process_complete(return_code))
        
    def _on_process_complete(self, return_code):
        """Handle process completion"""
        self.add_output("-" * 50 + "\n", "system")
        self.add_output(f"Process exited with code: {return_code}\n", "system")
        self.add_output(f"Execution time: {self.script_node.metrics['execution_time']:.2f}s\n", "system")
        
        if return_code == 0:
            self.script_node.status = "completed"
            self.status_label.config(text="Completed", foreground="green")
        else:
            self.script_node.status = "error"
            self.script_node.metrics['error_count'] += 1
            self.status_label.config(text=f"Error (code {return_code})", foreground="red")
            
        # Clean up
        try:
            if hasattr(self, 'temp_script') and os.path.exists(self.temp_script):
                os.unlink(self.temp_script)
        except:
            pass
            
        self.process = None
        
        # Update visualization
        self.runner.update_visualization()
        
    def stop_script(self):
        """Stop the running script"""
        if self.process and self.process.poll() is None:
            self.process.terminate()
            self.add_output("\nScript terminated by user\n", "system")
            self.script_node.status = "idle"
            self.status_label.config(text="Terminated", foreground="red")
            
    def process_output_queue(self):
        """Process queued output"""
        try:
            while True:
                line, tag = self.output_queue.get_nowait()
                self.add_output(line, tag)
        except queue.Empty:
            pass
            
    def add_output(self, text, tag="stdout"):
        """Add text to output with filtering"""
        # Apply filter
        filter_value = self.output_filter.get()
        if filter_value != "all" and tag != filter_value:
            return
            
        self.output.config(state='normal')
        self.output.insert(tk.END, text, tag)
        if self.auto_scroll.get():
            self.output.see(tk.END)
        self.output.config(state='disabled')
        
        # Also add to message log if it's a message
        if tag in ["message_in", "message_out"]:
            self.message_log.config(state='normal')
            self.message_log.insert(tk.END, text, tag)
            if self.auto_scroll.get():
                self.message_log.see(tk.END)
            self.message_log.config(state='disabled')
            
    def clear_output(self):
        """Clear all output"""
        for widget in [self.output, self.message_log]:
            widget.config(state='normal')
            widget.delete(1.0, tk.END)
            widget.config(state='disabled')
            
    def copy_output(self):
        """Copy output to clipboard"""
        content = self.output.get(1.0, tk.END)
        self.frame.clipboard_clear()
        self.frame.clipboard_append(content)
        
    def load_file(self):
        """Load a script file"""
        filename = filedialog.askopenfilename(
            title="Open Script",
            filetypes=[
                ("Python files", "*.py"),
                ("All files", "*.*")
            ]
        )
        
        if filename:
            try:
                with open(filename, 'r', encoding='utf-8') as f:
                    content = f.read()
                self.editor.delete(1.0, tk.END)
                self.editor.insert(1.0, content)
                self.file_path = filename
                self.last_saved_content = content
                self.script_node.file_path = filename
                
                # Update tab title
                self.runner.notebook.tab(self.frame, text=os.path.basename(filename))
                
                # Analyze immediately
                self.analyze_script()
                
            except Exception as e:
                messagebox.showerror("Error", f"Failed to load file: {str(e)}")
                
    def save_file(self):
        """Save the script to file"""
        if not self.file_path:
            self.file_path = filedialog.asksaveasfilename(
                title="Save Script",
                defaultextension=".py",
                filetypes=[
                    ("Python files", "*.py"),
                    ("All files", "*.*")
                ]
            )
            
        if self.file_path:
            try:
                content = self.editor.get(1.0, tk.END)
                with open(self.file_path, 'w', encoding='utf-8') as f:
                    f.write(content)
                self.last_saved_content = content
                self.script_node.file_path = self.file_path
                
                # Update tab title
                self.runner.notebook.tab(self.frame, text=os.path.basename(self.file_path))
                
                self.add_output(f"Saved to: {self.file_path}\n", "system")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to save file: {str(e)}")


class NeuralScriptIDE:
    """Main application for the Neural Script IDE"""
    def __init__(self, root):
        self.root = root
        self.root.title("Neural Script IDE - Production Version")
        self.root.geometry("1400x900")
        
        # Core components
        self.message_broker = MessageBroker()
        self.debugger = ScriptDebugger()
        self.orchestrator = ScriptOrchestrator(self.message_broker)
        self.dependency_visualizer = None
        
        self.tabs = {}
        self.tab_counter = 0
        
        # Configuration
        self.config_file = Path.home() / ".neural_script_ide_config.json"
        self.load_config()
        
        self.setup_ui()
        self.setup_menu()
        
        # Start services
        self.message_broker.start()
        
        # Create initial tab
        self.create_new_tab()
        
        # Bind shortcuts
        self.setup_keyboard_shortcuts()
        
    def load_config(self):
        """Load configuration"""
        default_config = {
            "theme": "dark",
            "auto_save": True,
            "auto_analyze": True,
            "debug_mode": False,
            "performance_monitoring": True,
            "message_history_size": 1000
        }
        
        if self.config_file.exists():
            try:
                with open(self.config_file, 'r') as f:
                    self.config = {**default_config, **json.load(f)}
            except:
                self.config = default_config
        else:
            self.config = default_config
            
    def save_config(self):
        """Save configuration"""
        with open(self.config_file, 'w') as f:
            json.dump(self.config, f, indent=2)
            
    def setup_ui(self):
        """Setup main UI"""
        # Main container
        main_paned = ttk.PanedWindow(self.root, orient=tk.HORIZONTAL)
        main_paned.pack(fill=tk.BOTH, expand=True)
        
        # Left panel - Script tabs
        left_frame = ttk.Frame(main_paned)
        main_paned.add(left_frame, weight=3)
        
        # Tab bar
        tab_toolbar = ttk.Frame(left_frame)
        tab_toolbar.pack(fill=tk.X)
        
        ttk.Button(tab_toolbar, text="‚ûï New Tab", command=self.create_new_tab).pack(side=tk.LEFT, padx=2)
        ttk.Button(tab_toolbar, text="üìä Show Dependencies", command=self.show_dependencies).pack(side=tk.LEFT, padx=2)
        ttk.Button(tab_toolbar, text="‚ñ∂Ô∏è Run All", command=self.run_all_scripts).pack(side=tk.LEFT, padx=2)
        ttk.Button(tab_toolbar, text="‚èπÔ∏è Stop All", command=self.stop_all_scripts).pack(side=tk.LEFT, padx=2)
        
        # Script tabs notebook
        self.notebook = ttk.Notebook(left_frame)
        self.notebook.pack(fill=tk.BOTH, expand=True)
        
        # Right panel - Visualization and monitoring
        right_frame = ttk.Frame(main_paned)
        main_paned.add(right_frame, weight=1)
        
        # Right panel notebook
        self.right_notebook = ttk.Notebook(right_frame)
        self.right_notebook.pack(fill=tk.BOTH, expand=True)
        
        # Dependency graph tab
        dep_frame = ttk.Frame(self.right_notebook)
        self.right_notebook.add(dep_frame, text="Dependencies")
        self.dependency_visualizer = DependencyVisualizer(self)
        
        # System monitor tab
        monitor_frame = ttk.Frame(self.right_notebook)
        self.right_notebook.add(monitor_frame, text="System Monitor")
        self.setup_system_monitor(monitor_frame)
        
        # Message flow tab
        message_frame = ttk.Frame(self.right_notebook)
        self.right_notebook.add(message_frame, text="Message Flow")
        self.setup_message_flow(message_frame)
        
        # Status bar
        self.setup_status_bar()
        
    def setup_system_monitor(self, parent):
        """Setup system monitoring view"""
        # System metrics
        metrics_frame = ttk.LabelFrame(parent, text="System Metrics", padding=10)
        metrics_frame.pack(fill=tk.X, padx=5, pady=5)
        
        self.system_labels = {}
        metrics = ['Total CPU', 'Total Memory', 'Active Scripts', 'Messages/sec']
        
        for i, metric in enumerate(metrics):
            label_frame = ttk.Frame(metrics_frame)
            label_frame.grid(row=i//2, column=(i%2)*2, padx=5, pady=2, sticky=tk.W)
            
            ttk.Label(label_frame, text=f"{metric}:").pack(side=tk.LEFT)
            value_label = ttk.Label(label_frame, text="0", font=("Arial", 10, "bold"))
            value_label.pack(side=tk.LEFT, padx=5)
            self.system_labels[metric] = value_label
            
        # Script status list
        status_frame = ttk.LabelFrame(parent, text="Script Status", padding=5)
        status_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        columns = ('script', 'status', 'cpu', 'memory', 'messages')
        self.status_tree = ttk.Treeview(status_frame, columns=columns, show='headings', height=10)
        
        for col in columns:
            self.status_tree.heading(col, text=col.title())
            self.status_tree.column(col, width=80)
            
        self.status_tree.pack(fill=tk.BOTH, expand=True)
        
        # Start monitoring
        self.monitor_system()
        
    def setup_message_flow(self, parent):
        """Setup message flow visualization"""
        # Message statistics
        stats_frame = ttk.LabelFrame(parent, text="Message Statistics", padding=10)
        stats_frame.pack(fill=tk.X, padx=5, pady=5)
        
        ttk.Label(stats_frame, text="Total Messages: ").grid(row=0, column=0, sticky=tk.W)
        self.total_messages_label = ttk.Label(stats_frame, text="0")
        self.total_messages_label.grid(row=0, column=1, sticky=tk.W)
        
        # Recent messages
        recent_frame = ttk.LabelFrame(parent, text="Recent Messages", padding=5)
        recent_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        self.message_flow_text = scrolledtext.ScrolledText(recent_frame, height=15, 
                                                          wrap=tk.WORD, 
                                                          font=("Consolas", 9))
        self.message_flow_text.pack(fill=tk.BOTH, expand=True)
        
        # Update periodically
        self.update_message_flow()
        
    def setup_status_bar(self):
        """Setup status bar"""
        self.status_frame = ttk.Frame(self.root)
        self.status_frame.pack(fill=tk.X, side=tk.BOTTOM)
        
        self.status_label = ttk.Label(self.status_frame, text="Ready")
        self.status_label.pack(side=tk.LEFT, padx=5)
        
        ttk.Separator(self.status_frame, orient='vertical').pack(side=tk.LEFT, fill='y', padx=5)
        
        self.tab_count_label = ttk.Label(self.status_frame, text="Scripts: 0")
        self.tab_count_label.pack(side=tk.LEFT, padx=5)
        
        ttk.Separator(self.status_frame, orient='vertical').pack(side=tk.LEFT, fill='y', padx=5)
        
        self.message_count_label = ttk.Label(self.status_frame, text="Messages: 0")
        self.message_count_label.pack(side=tk.LEFT, padx=5)
        
    def setup_menu(self):
        """Setup application menu"""
        menubar = tk.Menu(self.root)
        self.root.config(menu=menubar)
        
        # File menu
        file_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="File", menu=file_menu)
        file_menu.add_command(label="New Script", command=self.create_new_tab, accelerator="Ctrl+N")
        file_menu.add_command(label="Open Script", command=self.open_script, accelerator="Ctrl+O")
        file_menu.add_command(label="Save All", command=self.save_all_scripts, accelerator="Ctrl+Shift+S")
        file_menu.add_separator()
        file_menu.add_command(label="Import Project", command=self.import_project)
        file_menu.add_command(label="Export Project", command=self.export_project)
        file_menu.add_separator()
        file_menu.add_command(label="Exit", command=self.quit_app)
        
        # Edit menu
        edit_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Edit", menu=edit_menu)
        edit_menu.add_command(label="Find", accelerator="Ctrl+F")
        edit_menu.add_command(label="Replace", accelerator="Ctrl+H")
        
        # Scripts menu
        scripts_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Scripts", menu=scripts_menu)
        scripts_menu.add_command(label="Run All", command=self.run_all_scripts, accelerator="F5")
        scripts_menu.add_command(label="Stop All", command=self.stop_all_scripts, accelerator="Shift+F5")
        scripts_menu.add_separator()
        scripts_menu.add_command(label="Analyze All", command=self.analyze_all_scripts)
        scripts_menu.add_command(label="Check Dependencies", command=self.check_dependencies)
        
        # Debug menu
        debug_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Debug", menu=debug_menu)
        debug_menu.add_command(label="Start Debugging", accelerator="F10")
        debug_menu.add_command(label="Step Over", accelerator="F11")
        debug_menu.add_command(label="Toggle Breakpoint", accelerator="F9")
        
        # Tools menu
        tools_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Tools", menu=tools_menu)
        tools_menu.add_command(label="Message Inspector", command=self.open_message_inspector)
        tools_menu.add_command(label="Performance Profiler", command=self.open_profiler)
        tools_menu.add_command(label="Script Templates", command=self.open_templates)
        tools_menu.add_separator()
        tools_menu.add_command(label="Settings", command=self.open_settings)
        
        # Help menu
        help_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Help", menu=help_menu)
        help_menu.add_command(label="Documentation", command=self.open_documentation)
        help_menu.add_command(label="Examples", command=self.open_examples)
        help_menu.add_separator()
        help_menu.add_command(label="About", command=self.show_about)
        
    def setup_keyboard_shortcuts(self):
        """Setup keyboard shortcuts"""
        self.root.bind('<Control-n>', lambda e: self.create_new_tab())
        self.root.bind('<Control-o>', lambda e: self.open_script())
        self.root.bind('<Control-w>', lambda e: self.close_current_tab())
        self.root.bind('<Control-Tab>', lambda e: self.next_tab())
        self.root.bind('<Control-Shift-Tab>', lambda e: self.prev_tab())
        self.root.bind('<F5>', lambda e: self.run_current_script())
        self.root.bind('<Shift-F5>', lambda e: self.stop_all_scripts())
        self.root.bind('<Control-Shift-s>', lambda e: self.save_all_scripts())
        
    def create_new_tab(self):
        """Create a new script tab"""
        self.tab_counter += 1
        tab_id = self.tab_counter
        
        tab = EnhancedScriptTab(self.notebook, tab_id, self)
        self.tabs[tab_id] = tab
        
        self.notebook.add(tab.frame, text=f"Script {tab_id}")
        self.notebook.select(tab.frame)
        
        # Update target options for messages
        self.update_message_targets()
        
        self.update_tab_count()
        
    def open_script(self):
        """Open an existing script"""
        tab = self.create_new_tab()
        current_tab = self.get_current_tab()
        if current_tab:
            current_tab.load_file()
            
    def close_current_tab(self):
        """Close the current tab"""
        if len(self.tabs) <= 1:
            messagebox.showwarning("Warning", "Cannot close the last tab!")
            return
            
        current_tab_widget = self.notebook.select()
        for tab_id, tab in self.tabs.items():
            if str(tab.frame) == current_tab_widget:
                # Check if script is running
                if tab.process and tab.process.poll() is None:
                    if not messagebox.askyesno("Script Running", 
                                             "Script is still running. Close anyway?"):
                        return
                    tab.stop_script()
                    
                # Unsubscribe from messages
                if self.message_broker:
                    self.message_broker.unsubscribe(tab.script_node.id)
                    
                self.notebook.forget(current_tab_widget)
                del self.tabs[tab_id]
                self.update_tab_count()
                self.update_message_targets()
                break
                
    def get_current_tab(self):
        """Get the current active tab"""
        current_tab_widget = self.notebook.select()
        for tab_id, tab in self.tabs.items():
            if str(tab.frame) == current_tab_widget:
                return tab
        return None
        
    def next_tab(self):
        """Switch to next tab"""
        tabs = self.notebook.tabs()
        if tabs:
            current = self.notebook.select()
            current_index = tabs.index(current)
            next_index = (current_index + 1) % len(tabs)
            self.notebook.select(tabs[next_index])
            
    def prev_tab(self):
        """Switch to previous tab"""
        tabs = self.notebook.tabs()
        if tabs:
            current = self.notebook.select()
            current_index = tabs.index(current)
            prev_index = (current_index - 1) % len(tabs)
            self.notebook.select(tabs[prev_index])
            
    def update_tab_count(self):
        """Update tab count in status bar"""
        self.tab_count_label.config(text=f"Scripts: {len(self.tabs)}")
        

    def update_message_flow(self):
        """Update message flow display"""
        # Get recent messages
        recent_messages = list(self.message_broker.message_history)[-20:]

        self.message_flow_text.config(state='normal')
        self.message_flow_text.delete(1.0, tk.END)

        for msg in recent_messages:
            ts = datetime.fromtimestamp(msg.timestamp).strftime("%H:%M:%S.%f")[:-3]
            self.message_flow_text.insert(
                tk.END,
                f"[{ts}] {msg.sender_id} ‚Üí {msg.receiver_id}: {msg.payload}\n"
            )

        self.message_flow_text.config(state='disabled')
        self.message_flow_text.see(tk.END)

        # Update count (only once the status bar label exists)
        self.total_messages_label.config(text=str(len(self.message_broker.message_history)))
        if hasattr(self, 'message_count_label'):
            self.message_count_label.config(
                text=f"Messages: {len(self.message_broker.message_history)}"
            )

        # Schedule next update
        self.root.after(500, self.update_message_flow)



                

            
    def run_current_script(self):
        """Run the current script"""
        tab = self.get_current_tab()
        if tab:
            tab.run_script()
            
    def run_all_scripts(self):
        """Run all scripts with orchestration"""
        try:
            # Update orchestrator with all scripts
            for tab in self.tabs.values():
                self.orchestrator.add_script(tab.script_node)
                
            # Check for circular dependencies
            self.orchestrator._update_execution_order()
            
            # Run scripts
            for tab_id in self.orchestrator.execution_order:
                if tab_id in [tab.script_node.id for tab in self.tabs.values()]:
                    tab = next(t for t in self.tabs.values() if t.script_node.id == tab_id)
                    tab.run_script()
                    time.sleep(0.1)  # Small delay between starts
                    
        except ValueError as e:
            messagebox.showerror("Dependency Error", str(e))
            
    def stop_all_scripts(self):
        """Stop all running scripts"""
        for tab in self.tabs.values():
            tab.stop_script()
            
    def save_all_scripts(self):
        """Save all scripts"""
        for tab in self.tabs.values():
            if tab.editor.get(1.0, tk.END).strip():
                tab.save_file()
                
    def analyze_all_scripts(self):
        """Analyze all scripts"""
        for tab in self.tabs.values():
            tab.analyze_script()
            
    def check_dependencies(self):
        """Check and visualize dependencies"""
        self.show_dependencies()
        
        # Check for issues
        issues = []
        
        # Check for circular dependencies
        try:
            self.orchestrator._update_execution_order()
        except ValueError as e:
            issues.append(str(e))
            
        # Check for missing dependencies
        all_script_ids = {tab.script_node.id for tab in self.tabs.values()}
        for tab in self.tabs.values():
            for dep in tab.script_node.dependencies:
                if dep not in all_script_ids:
                    issues.append(f"Script {tab.script_node.id} depends on missing script {dep}")
                    
        if issues:
            messagebox.showwarning("Dependency Issues", "\n".join(issues))
        else:
            messagebox.showinfo("Dependencies", "All dependencies are valid!")
            
    def show_dependencies(self):
        """Show dependency visualization"""
        # Update graph
        scripts = {tab.script_node.id: tab.script_node for tab in self.tabs.values()}
        self.dependency_visualizer.update_graph(scripts)
        
        # Draw graph
        dep_frame = self.right_notebook.tabs()[0]
        dep_widget = self.right_notebook.nametowidget(dep_frame)
        
        # Clear existing content
        for child in dep_widget.winfo_children():
            child.destroy()
            
        self.dependency_visualizer.draw(dep_widget)
        
        # Switch to dependencies tab
        self.right_notebook.select(0)
        
    def update_visualization(self):
        """Update all visualizations"""
        self.show_dependencies()
        self.update_status_tree()
        
    def monitor_system(self):
        """Monitor system metrics"""
        def update():
            # Get system metrics
            cpu_percent = psutil.cpu_percent(interval=0.1)
            memory = psutil.virtual_memory()
            
            active_scripts = sum(1 for tab in self.tabs.values() 
                               if tab.script_node.status == "running")
            
            # Calculate message rate
            message_count = len(self.message_broker.message_history)
            
            # Update labels
            self.system_labels['Total CPU'].config(text=f"{cpu_percent:.1f}%")
            self.system_labels['Total Memory'].config(text=f"{memory.percent:.1f}%")
            self.system_labels['Active Scripts'].config(text=str(active_scripts))
            self.system_labels['Messages/sec'].config(text="0")  # Would need proper calculation
            
            # Schedule next update
            self.root.after(1000, update)
            
        update()
        
    def update_status_tree(self):
        """Update script status tree"""
        # Clear existing
        for item in self.status_tree.get_children():
            self.status_tree.delete(item)
            
        # Add current scripts
        for tab in self.tabs.values():
            node = tab.script_node
            self.status_tree.insert('', tk.END, values=(
                node.id,
                node.status,
                f"{node.metrics['cpu_usage']:.1f}%",
                f"{node.metrics['memory_usage']:.1f} MB",
                node.metrics['message_count']
            ))
            
        # Schedule next update
        self.root.after(1000, self.update_status_tree)
        
    def update_message_flow(self):
        """Update message flow display"""
        # Get recent messages
        recent_messages = list(self.message_broker.message_history)[-20:]
        
        self.message_flow_text.config(state='normal')
        self.message_flow_text.delete(1.0, tk.END)
        
        for msg in recent_messages:
            timestamp = datetime.fromtimestamp(msg.timestamp).strftime("%H:%M:%S.%f")[:-3]
            self.message_flow_text.insert(tk.END, 
                f"[{timestamp}] {msg.sender_id} ‚Üí {msg.receiver_id}: {msg.payload}\n")
            
        self.message_flow_text.config(state='disabled')
        self.message_flow_text.see(tk.END)
        
        # Update count
        self.total_messages_label.config(text=str(len(self.message_broker.message_history)))
        self.message_count_label.config(text=f"Messages: {len(self.message_broker.message_history)}")
        
        # Schedule next update
        self.root.after(500, self.update_message_flow)
        
    def import_project(self):
        """Import a project configuration"""
        filename = filedialog.askopenfilename(
            title="Import Project",
            filetypes=[("JSON files", "*.json"), ("YAML files", "*.yaml")]
        )
        
        if filename:
            try:
                with open(filename, 'r') as f:
                    if filename.endswith('.yaml'):
                        project = yaml.safe_load(f)
                    else:
                        project = json.load(f)
                        
                # Load scripts
                for script_config in project.get('scripts', []):
                    tab = self.create_new_tab()
                    # Load script content and configuration
                    # Implementation would load file paths, dependencies, etc.
                    
                messagebox.showinfo("Success", "Project imported successfully!")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to import project: {str(e)}")
                
    def export_project(self):
        """Export current project configuration"""
        filename = filedialog.asksaveasfilename(
            title="Export Project",
            defaultextension=".json",
            filetypes=[("JSON files", "*.json"), ("YAML files", "*.yaml")]
        )
        
        if filename:
            try:
                project = {
                    'name': 'Neural Script Project',
                    'version': '1.0',
                    'scripts': []
                }
                
                for tab in self.tabs.values():
                    script_config = {
                        'id': tab.script_node.id,
                        'file_path': tab.file_path,
                        'dependencies': list(tab.script_node.dependencies),
                        'status': tab.script_node.status
                    }
                    project['scripts'].append(script_config)
                    
                with open(filename, 'w') as f:
                    if filename.endswith('.yaml'):
                        yaml.dump(project, f)
                    else:
                        json.dump(project, f, indent=2)
                        
                messagebox.showinfo("Success", "Project exported successfully!")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to export project: {str(e)}")
                
    def open_message_inspector(self):
        """Open message inspector tool"""
        inspector = tk.Toplevel(self.root)
        inspector.title("Message Inspector")
        inspector.geometry("800x600")
        
        # Message history viewer with filtering
        ttk.Label(inspector, text="Message Inspector - Coming Soon").pack(expand=True)
        
    def open_profiler(self):
        """Open performance profiler"""
        profiler = tk.Toplevel(self.root)
        profiler.title("Performance Profiler")
        profiler.geometry("900x700")
        
        ttk.Label(profiler, text="Performance Profiler - Coming Soon").pack(expand=True)
        
    def open_templates(self):
        """Open script templates"""
        templates = tk.Toplevel(self.root)
        templates.title("Script Templates")
        templates.geometry("600x400")
        
        # Template categories
        notebook = ttk.Notebook(templates)
        notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Basic templates
        basic_frame = ttk.Frame(notebook)
        notebook.add(basic_frame, text="Basic")
        
        templates_list = [
            ("Data Processor", self._get_data_processor_template),
            ("Message Handler", self._get_message_handler_template),
            ("Neural Node", self._get_neural_node_template),
        ]
        
        for i, (name, template_func) in enumerate(templates_list):
            ttk.Button(basic_frame, text=name, 
                      command=lambda f=template_func: self._apply_template(f())).grid(
                          row=i//3, column=i%3, padx=10, pady=10)
                          
    def _get_data_processor_template(self):
        """Get data processor template"""
        return '''# Data Processor Script
import time
import json

def process_data(data):
    """Process incoming data"""
    # Your processing logic here
    processed = data.upper() if isinstance(data, str) else str(data)
    return processed

def main():
    # Listen for messages
    while True:
        # In real implementation, this would receive from message queue
        data = input("Enter data: ")
        
        if data.lower() == 'quit':
            break
            
        # Process data
        result = process_data(data)
        
        # Send result
        comm.send_message('BROADCAST', result)
        comm.log_metric('processed_items', 1)
        
        time.sleep(0.1)

if __name__ == "__main__":
    main()
'''

    def _get_message_handler_template(self):
        """Get message handler template"""
        return '''# Message Handler Script
import json
import time
from collections import defaultdict

class MessageHandler:
    def __init__(self):
        self.message_count = defaultdict(int)
        
    def handle_message(self, message):
        """Handle incoming message"""
        sender = message.get('sender_id', 'unknown')
        payload = message.get('payload', '')
        
        # Count messages
        self.message_count[sender] += 1
        
        # Process based on message type
        if isinstance(payload, dict):
            action = payload.get('action')
            if action == 'process':
                return self.process_action(payload)
        
        return None
        
    def process_action(self, payload):
        """Process specific action"""
        # Implement your logic here
        return {'status': 'processed', 'data': payload}

def main():
    handler = MessageHandler()
    
    # Main message loop
    while True:
        # In real implementation, receive from message queue
        # For now, simulate with input
        try:
            message_str = input("Message JSON: ")
            if message_str.lower() == 'quit':
                break
                
            message = json.loads(message_str)
            result = handler.handle_message(message)
            
            if result:
                comm.send_message('BROADCAST', result)
                
        except json.JSONDecodeError:
            print("Invalid JSON")
        except Exception as e:
            comm.send_message('SYSTEM', {'error': str(e)})
            
        # Log metrics
        total_messages = sum(handler.message_count.values())
        comm.log_metric('total_messages', total_messages)

if __name__ == "__main__":
    main()
'''

    def _get_neural_node_template(self):
        """Get neural network node template"""
        return '''# Neural Network Node Script
import numpy as np
import time

class NeuralNode:
    def __init__(self, node_id, input_size=10, output_size=5):
        self.node_id = node_id
        self.weights = np.random.randn(input_size, output_size) * 0.1
        self.bias = np.zeros(output_size)
        self.activation_count = 0
        
    def forward(self, inputs):
        """Forward pass through the node"""
        # Linear transformation
        output = np.dot(inputs, self.weights) + self.bias
        
        # Activation (ReLU)
        output = np.maximum(0, output)
        
        self.activation_count += 1
        return output
        
    def receive_input(self, sender, data):
        """Receive input from another node"""
        if isinstance(data, list):
            inputs = np.array(data)
        else:
            inputs = data
            
        # Process through node
        output = self.forward(inputs)
        
        # Send to next nodes
        self.send_output(output)
        
    def send_output(self, output):
        """Send output to connected nodes"""
        # Convert to list for JSON serialization
        output_list = output.tolist()
        
        # Send to specific nodes or broadcast
        comm.send_message('BROADCAST', {
            'node_id': self.node_id,
            'output': output_list,
            'activation': self.activation_count
        })

def main():
    # Initialize node
    node = NeuralNode('node_1')
    
    # Main processing loop
    while True:
        # Simulate receiving input
        # In real implementation, would receive from message queue
        try:
            input_data = input("Input data (comma-separated numbers): ")
            if input_data.lower() == 'quit':
                break
                
            # Parse input
            inputs = [float(x) for x in input_data.split(',')]
            
            # Process
            node.receive_input('user', inputs)
            
            # Log metrics
            comm.log_metric('activations', node.activation_count)
            
        except ValueError:
            print("Invalid input format")
        except Exception as e:
            comm.send_message('SYSTEM', {'error': str(e)})
            
        time.sleep(0.1)

if __name__ == "__main__":
    main()
'''

    def _apply_template(self, template_code):
        """Apply template to current tab"""
        tab = self.get_current_tab()
        if tab:
            tab.editor.delete(1.0, tk.END)
            tab.editor.insert(1.0, template_code)
            
    def open_settings(self):
        """Open settings dialog"""
        settings = tk.Toplevel(self.root)
        settings.title("Settings")
        settings.geometry("600x500")
        
        notebook = ttk.Notebook(settings)
        notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # General settings
        general_frame = ttk.Frame(notebook)
        notebook.add(general_frame, text="General")
        
        settings_vars = {}
        
        # Auto-save
        auto_save_var = tk.BooleanVar(value=self.config.get('auto_save', True))
        ttk.Checkbutton(general_frame, text="Auto-save scripts", 
                       variable=auto_save_var).pack(anchor=tk.W, padx=10, pady=5)
        settings_vars['auto_save'] = auto_save_var
        
        # Auto-analyze
        auto_analyze_var = tk.BooleanVar(value=self.config.get('auto_analyze', True))
        ttk.Checkbutton(general_frame, text="Auto-analyze scripts", 
                       variable=auto_analyze_var).pack(anchor=tk.W, padx=10, pady=5)
        settings_vars['auto_analyze'] = auto_analyze_var
        
        # Performance monitoring
        perf_var = tk.BooleanVar(value=self.config.get('performance_monitoring', True))
        ttk.Checkbutton(general_frame, text="Enable performance monitoring", 
                       variable=perf_var).pack(anchor=tk.W, padx=10, pady=5)
        settings_vars['performance_monitoring'] = perf_var
        
        # Advanced settings
        advanced_frame = ttk.Frame(notebook)
        notebook.add(advanced_frame, text="Advanced")
        
        ttk.Label(advanced_frame, text="Message History Size:").pack(anchor=tk.W, padx=10, pady=5)
        history_var = tk.IntVar(value=self.config.get('message_history_size', 1000))
        ttk.Spinbox(advanced_frame, from_=100, to=10000, textvariable=history_var, 
                   width=10).pack(anchor=tk.W, padx=20)
        settings_vars['message_history_size'] = history_var
        
        # Save button
        def save_settings():
            for key, var in settings_vars.items():
                self.config[key] = var.get()
            self.save_config()
            messagebox.showinfo("Settings", "Settings saved successfully!")
            settings.destroy()
            
        ttk.Button(settings, text="Save", command=save_settings).pack(pady=10)
        
    def open_documentation(self):
        """Open documentation"""
        messagebox.showinfo("Documentation", 
                          "Documentation is available at:\n"
                          "https://neural-script-ide.readthedocs.io")
                          
    def open_examples(self):
        """Open examples"""
        examples = tk.Toplevel(self.root)
        examples.title("Examples")
        examples.geometry("800x600")
        
        text = scrolledtext.ScrolledText(examples, wrap=tk.WORD)
        text.pack(fill=tk.BOTH, expand=True)
        
        example_text = """Neural Script IDE Examples
=======================

1. Simple Message Passing
------------------------
Create two scripts that communicate:

Script 1 (Producer):
```python
import time
for i in range(10):
    comm.send_message('script_2', f'Data item {i}')
    time.sleep(1)
```

Script 2 (Consumer):
```python
# This script will automatically receive messages
# from Script 1 through the message broker
```

2. Data Processing Pipeline
--------------------------
Create a pipeline of scripts that process data sequentially.

3. Neural Network Simulation
---------------------------
Build a simple neural network with scripts acting as nodes.

For more examples, visit our GitHub repository.
"""
        
        text.insert(1.0, example_text)
        text.config(state='disabled')
        
    def show_about(self):
        """Show about dialog"""
        about_text = """Neural Script IDE
Version 1.0.0

A sophisticated IDE for building neural networks 
from interconnected Python scripts.

Features:
‚Ä¢ Advanced inter-script communication
‚Ä¢ Real-time dependency visualization  
‚Ä¢ Comprehensive debugging tools
‚Ä¢ Performance monitoring
‚Ä¢ Script orchestration

¬© 2024 Neural Script IDE Team"""
        
        messagebox.showinfo("About Neural Script IDE", about_text)
        
    def quit_app(self):
        """Quit application"""
        # Check for running scripts
        running_scripts = [tab for tab in self.tabs.values() 
                          if tab.process and tab.process.poll() is None]
        
        if running_scripts:
            if not messagebox.askyesno("Scripts Running",
                                     f"{len(running_scripts)} scripts are still running. Quit anyway?"):
                return
                
        # Stop services
        self.message_broker.stop()
        
        # Save config
        self.save_config()
        
        self.root.quit()


def main():
    """Main entry point"""
    # Check dependencies
    missing_deps = []
    
    try:
        import networkx
    except ImportError:
        missing_deps.append("networkx")
        
    try:
        import matplotlib
    except ImportError:
        missing_deps.append("matplotlib")
        
    try:
        import psutil
    except ImportError:
        missing_deps.append("psutil")
        
    if missing_deps:
        print(f"Missing dependencies: {', '.join(missing_deps)}")
        print("Install with: pip install " + " ".join(missing_deps))
        response = input("Continue anyway? (y/n): ")
        if response.lower() != 'y':
            return
            
    # Create and run application
    root = tk.Tk()
    app = NeuralScriptIDE(root)
    
    # Set icon if available
    try:
        if platform.system() == "Windows":
            root.iconbitmap(default='neural_ide.ico')
    except:
        pass
        
    root.mainloop()


if __name__ == "__main__":
    main()

========================================
# File: C:\Users\Saem1001\Documents\GitHub\ai_detect\net\neural_ide_2\app\code_check.py
========================================

import subprocess
import os
from openai import OpenAI
import json

class CodeAnalyzer:
    """
    A class to handle code analysis using various tools like Pylint, Flake8, etc.
    """
    def __init__(self, file_path):
        self.file_path = file_path

    def run_pylint(self):
        """Runs Pylint on the specified file."""
        try:
            result = subprocess.run(
                ["pylint", self.file_path],
                capture_output=True,
                text=True,
                check=True
            )
            return result.stdout
        except (subprocess.CalledProcessError, FileNotFoundError) as e:
            return f"Pylint analysis failed: {e}"

    def run_flake8(self):
        """Runs Flake8 on the specified file."""
        try:
            result = subprocess.run(
                ["flake8", self.file_path],
                capture_output=True,
                text=True,
                check=True
            )
            return result.stdout
        except (subprocess.CalledProcessError, FileNotFoundError) as e:
            return f"Flake8 analysis failed: {e}"

class AISuggestor:
    """
    A class to get suggestions from AI tools like GitHub Copilot and OpenAI.
    """
    def __init__(self, api_key=None):
        if api_key:
            self.openai_client = OpenAI(api_key=api_key)

    def get_copilot_suggestion(self, prompt):
        """Gets a suggestion from GitHub Copilot CLI."""
        try:
            proc = subprocess.run(
                ["gh", "copilot", "suggest", "--stdin"],
                input=prompt,
                text=True,
                capture_output=True,
                check=True
            )
            return proc.stdout
        except (subprocess.CalledProcessError, FileNotFoundError) as e:
            return f"GitHub Copilot CLI error: {e}"

    def get_openai_suggestion(self, prompt):
        """Gets a suggestion from OpenAI's GPT-4o-mini model."""
        if not hasattr(self, 'openai_client'):
            return "OpenAI client not initialized. Please provide an API key."
            
        try:
            resp = self.openai_client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[{"role": "user", "content": prompt}]
            )
            return resp.choices[0].message.content
        except Exception as e:
            return f"OpenAI API error: {e}"

class AutoReviser:
    """
    A class to automatically revise code based on AI suggestions.
    """
    def __init__(self, file_path):
        self.file_path = file_path

    def revise_code(self, original_code, suggestion):
        """
        Revises the code by replacing the original with the suggestion.
        This is a simple implementation; a more advanced version could use diff-patch.
        """
        with open(self.file_path, 'w') as f:
            f.write(suggestion)
        return "Code has been revised."

def main():
    """
    Main function to demonstrate the usage of the new classes.
    """
    # Configuration
    USE_AI_CHECKER = True  # Set to False to disable AI features
    OPENAI_API_KEY = os.getenv("OPENAI_API_KEY") # Securely get your API key

    # Example usage
    file_to_analyze = "your_script.py"  # Change this to the script you want to analyze
    
    # Create a dummy file for demonstration
    with open(file_to_analyze, "w") as f:
        f.write("def my_func( a, b):\n    return a+b")

    analyzer = CodeAnalyzer(file_to_analyze)
    print("--- Pylint Analysis ---")
    print(analyzer.run_pylint())
    print("\n--- Flake8 Analysis ---")
    print(analyzer.run_flake8())

    if USE_AI_CHECKER:
        ai_suggestor = AISuggestor(api_key=OPENAI_API_KEY)
        reviser = AutoReviser(file_to_analyze)

        with open(file_to_analyze, 'r') as f:
            original_code = f.read()

        # Get suggestion from Copilot
        copilot_prompt = f"Fix the following Python code:\n\n{original_code}"
        copilot_suggestion = ai_suggestor.get_copilot_suggestion(copilot_prompt)
        print("\n--- GitHub Copilot Suggestion ---")
        print(copilot_suggestion)

        # Get suggestion from OpenAI
        openai_prompt = f"Fix the following Python code to adhere to PEP 8 and best practices:\n\n{original_code}"
        openai_suggestion = ai_suggestor.get_openai_suggestion(openai_prompt)
        print("\n--- OpenAI Suggestion ---")
        print(openai_suggestion)

        # Automatically revise the code with OpenAI's suggestion
        print("\n--- Auto-Revision ---")
        revision_status = reviser.revise_code(original_code, openai_suggestion)
        print(revision_status)

        # Show the revised code
        with open(file_to_analyze, 'r') as f:
            revised_code = f.read()
        print("\n--- Revised Code ---")
        print(revised_code)

if __name__ == "__main__":
    main()


========================================
# File: C:\Users\Saem1001\Documents\GitHub\ai_detect\net\neural_ide_2\app\config.py
========================================

# === config_manager.py ===
"""
Configuration Manager for Neural Script IDE
Handles project configurations, templates, and settings
"""

import json
import os
from pathlib import Path
from typing import Dict, List, Any, Optional
from dataclasses import dataclass, asdict
from datetime import datetime

try:
    import yaml
except ImportError:
    print("Warning: PyYAML not installed. Some features may not work.")
    yaml = None

@dataclass
class ScriptConfig:
    """Configuration for a single script"""
    id: str
    name: str
    file_path: Optional[str] = None
    dependencies: List[str] = None
    inputs: Dict[str, Any] = None
    outputs: Dict[str, Any] = None
    parameters: Dict[str, Any] = None
    auto_restart: bool = False
    max_retries: int = 3
    timeout: Optional[int] = None
    
    def __post_init__(self):
        if self.dependencies is None:
            self.dependencies = []
        if self.inputs is None:
            self.inputs = {}
        if self.outputs is None:
            self.outputs = {}
        if self.parameters is None:
            self.parameters = {}

@dataclass
class ProjectConfig:
    """Configuration for an entire project"""
    name: str
    version: str
    description: str = ""
    created: str = ""
    modified: str = ""
    scripts: List[ScriptConfig] = None
    global_parameters: Dict[str, Any] = None
    message_broker_config: Dict[str, Any] = None
    
    def __post_init__(self):
        if not self.created:
            self.created = datetime.now().isoformat()
        self.modified = datetime.now().isoformat()
        if self.scripts is None:
            self.scripts = []
        if self.global_parameters is None:
            self.global_parameters = {}
        if self.message_broker_config is None:
            self.message_broker_config = {
                'buffer_size': 1000,
                'message_timeout': 30,
                'heartbeat_interval': 5
            }

class ConfigurationManager:
    """Manages IDE configurations and projects"""
    
    def __init__(self):
        self.config_dir = Path.home() / ".neural_script_ide"
        self.projects_dir = self.config_dir / "projects"
        self.templates_dir = self.config_dir / "templates"
        self.current_project = None
        
        # Create directories
        self.config_dir.mkdir(exist_ok=True)
        self.projects_dir.mkdir(exist_ok=True)
        self.templates_dir.mkdir(exist_ok=True)
        
        # Load default templates
        self._create_default_templates()
        
    def _create_default_templates(self):
        """Create default project templates"""
        templates = {
            'simple_pipeline': self._create_pipeline_template(),
            'neural_network': self._create_neural_network_template(),
            'data_processing': self._create_data_processing_template(),
            'microservices': self._create_microservices_template()
        }
        
        for name, config in templates.items():
            self.save_template(name, config)
            
    def _create_pipeline_template(self) -> ProjectConfig:
        """Create a simple pipeline template"""
        return ProjectConfig(
            name="Simple Pipeline",
            version="1.0",
            description="A simple data processing pipeline",
            scripts=[
                ScriptConfig(
                    id="data_reader",
                    name="Data Reader",
                    outputs={"data": "raw_data"},
                    parameters={"source": "file.csv"}
                ),
                ScriptConfig(
                    id="processor",
                    name="Data Processor",
                    dependencies=["data_reader"],
                    inputs={"data": "raw_data"},
                    outputs={"data": "processed_data"}
                ),
                ScriptConfig(
                    id="writer",
                    name="Data Writer",
                    dependencies=["processor"],
                    inputs={"data": "processed_data"},
                    parameters={"destination": "output.csv"}
                )
            ]
        )
        
    def _create_neural_network_template(self) -> ProjectConfig:
        """Create a neural network template"""
        return ProjectConfig(
            name="Neural Network",
            version="1.0",
            description="Multi-layer neural network with parallel processing",
            scripts=[
                ScriptConfig(
                    id="input_layer",
                    name="Input Layer",
                    outputs={"activations": "input_features"},
                    parameters={
                        "input_size": 784,
                        "batch_size": 32
                    }
                ),
                ScriptConfig(
                    id="hidden_layer_1",
                    name="Hidden Layer 1",
                    dependencies=["input_layer"],
                    inputs={"features": "input_features"},
                    outputs={"activations": "hidden_1_output"},
                    parameters={
                        "neurons": 128,
                        "activation": "relu",
                        "dropout": 0.2
                    }
                ),
                ScriptConfig(
                    id="hidden_layer_2",
                    name="Hidden Layer 2",
                    dependencies=["input_layer"],
                    inputs={"features": "input_features"},
                    outputs={"activations": "hidden_2_output"},
                    parameters={
                        "neurons": 64,
                        "activation": "tanh"
                    }
                ),
                ScriptConfig(
                    id="attention_layer",
                    name="Attention Mechanism",
                    dependencies=["hidden_layer_1", "hidden_layer_2"],
                    inputs={
                        "hidden_1": "hidden_1_output",
                        "hidden_2": "hidden_2_output"
                    },
                    outputs={"attention_weights": "attention_output"}
                ),
                ScriptConfig(
                    id="output_layer",
                    name="Output Layer",
                    dependencies=["attention_layer"],
                    inputs={"features": "attention_output"},
                    outputs={"predictions": "final_output"},
                    parameters={
                        "num_classes": 10,
                        "activation": "softmax"
                    }
                ),
                ScriptConfig(
                    id="loss_calculator",
                    name="Loss Calculator",
                    dependencies=["output_layer"],
                    inputs={"predictions": "final_output"},
                    outputs={"loss": "training_loss"},
                    parameters={
                        "loss_function": "cross_entropy"
                    }
                )
            ],
            global_parameters={
                "learning_rate": 0.001,
                "optimizer": "adam",
                "epochs": 100
            }
        )
        
    def _create_data_processing_template(self) -> ProjectConfig:
        """Create a data processing template"""
        return ProjectConfig(
            name="Data Processing Pipeline",
            version="1.0",
            description="ETL pipeline with validation and monitoring",
            scripts=[
                ScriptConfig(
                    id="extractor",
                    name="Data Extractor",
                    outputs={"raw_data": "extracted_data"},
                    parameters={
                        "sources": ["database", "api", "files"],
                        "batch_size": 1000
                    }
                ),
                ScriptConfig(
                    id="validator",
                    name="Data Validator",
                    dependencies=["extractor"],
                    inputs={"data": "extracted_data"},
                    outputs={
                        "valid_data": "validated_data",
                        "errors": "validation_errors"
                    },
                    parameters={
                        "rules": "validation_rules.json"
                    }
                ),
                ScriptConfig(
                    id="transformer",
                    name="Data Transformer",
                    dependencies=["validator"],
                    inputs={"data": "validated_data"},
                    outputs={"transformed": "transformed_data"},
                    parameters={
                        "transformations": ["normalize", "aggregate", "enrich"]
                    }
                ),
                ScriptConfig(
                    id="loader",
                    name="Data Loader",
                    dependencies=["transformer"],
                    inputs={"data": "transformed_data"},
                    parameters={
                        "destination": "data_warehouse",
                        "mode": "append"
                    }
                ),
                ScriptConfig(
                    id="monitor",
                    name="Pipeline Monitor",
                    dependencies=["extractor", "validator", "transformer", "loader"],
                    inputs={
                        "errors": "validation_errors"
                    },
                    parameters={
                        "alert_threshold": 0.05,
                        "metrics": ["throughput", "error_rate", "latency"]
                    }
                )
            ]
        )
        
    def _create_microservices_template(self) -> ProjectConfig:
        """Create a microservices template"""
        return ProjectConfig(
            name="Microservices Architecture",
            version="1.0",
            description="Distributed microservices with load balancing",
            scripts=[
                ScriptConfig(
                    id="api_gateway",
                    name="API Gateway",
                    outputs={"requests": "incoming_requests"},
                    parameters={
                        "port": 8080,
                        "rate_limit": 100,
                        "auth_enabled": True
                    }
                ),
                ScriptConfig(
                    id="load_balancer",
                    name="Load Balancer",
                    dependencies=["api_gateway"],
                    inputs={"requests": "incoming_requests"},
                    outputs={"distributed": "balanced_requests"},
                    parameters={
                        "algorithm": "round_robin",
                        "health_check_interval": 30
                    }
                ),
                ScriptConfig(
                    id="auth_service",
                    name="Authentication Service",
                    dependencies=["load_balancer"],
                    inputs={"requests": "balanced_requests"},
                    outputs={"authenticated": "auth_requests"},
                    parameters={
                        "token_expiry": 3600,
                        "max_attempts": 3
                    }
                ),
                ScriptConfig(
                    id="user_service",
                    name="User Service",
                    dependencies=["auth_service"],
                    inputs={"requests": "auth_requests"},
                    outputs={"responses": "user_responses"},
                    parameters={
                        "cache_enabled": True,
                        "database": "users_db"
                    },
                    auto_restart=True
                ),
                ScriptConfig(
                    id="order_service",
                    name="Order Service",
                    dependencies=["auth_service"],
                    inputs={"requests": "auth_requests"},
                    outputs={"responses": "order_responses"},
                    parameters={
                        "database": "orders_db",
                        "transaction_timeout": 30
                    },
                    auto_restart=True
                ),
                ScriptConfig(
                    id="notification_service",
                    name="Notification Service",
                    dependencies=["user_service", "order_service"],
                    inputs={
                        "user_events": "user_responses",
                        "order_events": "order_responses"
                    },
                    parameters={
                        "channels": ["email", "sms", "push"],
                        "queue_size": 1000
                    }
                )
            ],
            message_broker_config={
                "type": "rabbitmq",
                "host": "localhost",
                "port": 5672,
                "prefetch_count": 10
            }
        )
        
    def save_project(self, project: ProjectConfig, name: str) -> Path:
        """Save a project configuration"""
        project_file = self.projects_dir / f"{name}.yaml"
        
        with open(project_file, 'w') as f:
            yaml.dump(asdict(project), f, default_flow_style=False)
            
        return project_file
        
    def load_project(self, name: str) -> ProjectConfig:
        """Load a project configuration"""
        project_file = self.projects_dir / f"{name}.yaml"
        
        if not project_file.exists():
            raise FileNotFoundError(f"Project '{name}' not found")
            
        with open(project_file, 'r') as f:
            data = yaml.safe_load(f)
            
        # Convert to ProjectConfig
        scripts = [ScriptConfig(**s) for s in data.get('scripts', [])]
        data['scripts'] = scripts
        
        return ProjectConfig(**data)
        
    def save_template(self, name: str, config: ProjectConfig):
        """Save a project template"""
        template_file = self.templates_dir / f"{name}.yaml"
        
        with open(template_file, 'w') as f:
            yaml.dump(asdict(config), f, default_flow_style=False)
            
    def list_projects(self) -> List[str]:
        """List all saved projects"""
        return [f.stem for f in self.projects_dir.glob("*.yaml")]
        
    def list_templates(self) -> List[str]:
        """List all available templates"""
        return [f.stem for f in self.templates_dir.glob("*.yaml")]
        
    def export_project(self, project: ProjectConfig, output_path: str, 
                      include_scripts: bool = True):
        """Export project with all scripts"""
        export_dir = Path(output_path) / project.name.replace(" ", "_").lower()
        export_dir.mkdir(parents=True, exist_ok=True)
        
        # Save project config
        with open(export_dir / "project.yaml", 'w') as f:
            yaml.dump(asdict(project), f, default_flow_style=False)
            
        # Create scripts directory
        if include_scripts:
            scripts_dir = export_dir / "scripts"
            scripts_dir.mkdir(exist_ok=True)
            
            # Copy script files
            for script in project.scripts:
                if script.file_path and Path(script.file_path).exists():
                    import shutil
                    shutil.copy2(script.file_path, 
                               scripts_dir / f"{script.id}.py")
                               
        # Create README
        readme_content = f"""# {project.name}

{project.description}

## Version: {project.version}

## Scripts:
"""
        for script in project.scripts:
            readme_content += f"\n### {script.name} ({script.id})"
            if script.dependencies:
                readme_content += f"\n- Dependencies: {', '.join(script.dependencies)}"
            if script.parameters:
                readme_content += f"\n- Parameters: {json.dumps(script.parameters, indent=2)}"
            readme_content += "\n"
            
        with open(export_dir / "README.md", 'w') as f:
            f.write(readme_content)
            
        print(f"Project exported to: {export_dir}")
        
    def validate_project(self, project: ProjectConfig) -> List[str]:
        """Validate project configuration"""
        errors = []
        
        # Check for duplicate script IDs
        script_ids = [s.id for s in project.scripts]
        if len(script_ids) != len(set(script_ids)):
            errors.append("Duplicate script IDs found")
            
        # Check dependencies
        for script in project.scripts:
            for dep in script.dependencies:
                if dep not in script_ids:
                    errors.append(f"Script '{script.id}' depends on unknown script '{dep}'")
                    
        # Check for circular dependencies
        try:
            self._check_circular_dependencies(project)
        except ValueError as e:
            errors.append(str(e))
            
        return errors
        
    def _check_circular_dependencies(self, project: ProjectConfig):
        """Check for circular dependencies using DFS"""
        # Build adjacency list
        graph = {s.id: s.dependencies for s in project.scripts}
        
        # DFS to detect cycles
        visited = set()
        rec_stack = set()
        
        def has_cycle(node):
            visited.add(node)
            rec_stack.add(node)
            
            for neighbor in graph.get(node, []):
                if neighbor not in visited:
                    if has_cycle(neighbor):
                        return True
                elif neighbor in rec_stack:
                    return True
                    
            rec_stack.remove(node)
            return False
            
        for script_id in graph:
            if script_id not in visited:
                if has_cycle(script_id):
                    raise ValueError(f"Circular dependency detected involving '{script_id}'")


# === project_wizard.py ===
"""
Project Creation Wizard for Neural Script IDE
Interactive project setup with guided configuration
"""

import tkinter as tk
from tkinter import ttk, messagebox, filedialog
from typing import List, Dict, Any, Optional
import json

class ProjectWizard:
    """Interactive wizard for creating projects"""
    
    def __init__(self, parent, config_manager):
        self.parent = parent
        self.config_manager = config_manager
        self.result = None
        
        self.window = tk.Toplevel(parent)
        self.window.title("New Project Wizard")
        self.window.geometry("800x600")
        
        # Current page
        self.current_page = 0
        self.pages = []
        
        # Project data
        self.project_data = {
            'name': '',
            'description': '',
            'template': None,
            'scripts': [],
            'parameters': {}
        }
        
        self.setup_ui()
        self.create_pages()
        self.show_page(0)
        
    def setup_ui(self):
        """Setup wizard UI"""
        # Header
        header_frame = ttk.Frame(self.window)
        header_frame.pack(fill=tk.X, padx=20, pady=10)
        
        self.title_label = ttk.Label(header_frame, text="New Project Wizard",
                                    font=("Arial", 16, "bold"))
        self.title_label.pack()
        
        self.subtitle_label = ttk.Label(header_frame, text="Step 1 of 5")
        self.subtitle_label.pack()
        
        # Content area
        self.content_frame = ttk.Frame(self.window)
        self.content_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)
        
        # Navigation
        nav_frame = ttk.Frame(self.window)
        nav_frame.pack(fill=tk.X, padx=20, pady=10)
        
        self.back_button = ttk.Button(nav_frame, text="< Back", 
                                     command=self.previous_page)
        self.back_button.pack(side=tk.LEFT)
        
        self.next_button = ttk.Button(nav_frame, text="Next >", 
                                     command=self.next_page)
        self.next_button.pack(side=tk.RIGHT)
        
        self.cancel_button = ttk.Button(nav_frame, text="Cancel", 
                                       command=self.window.destroy)
        self.cancel_button.pack(side=tk.RIGHT, padx=5)
        
    def create_pages(self):
        """Create wizard pages"""
        self.pages = [
            self.create_welcome_page,
            self.create_template_page,
            self.create_scripts_page,
            self.create_connections_page,
            self.create_summary_page
        ]
        
    def show_page(self, index):
        """Show specific page"""
        # Clear content
        for widget in self.content_frame.winfo_children():
            widget.destroy()
            
        # Update navigation
        self.current_page = index
        self.subtitle_label.config(text=f"Step {index + 1} of {len(self.pages)}")
        
        self.back_button.config(state=tk.NORMAL if index > 0 else tk.DISABLED)
        self.next_button.config(text="Finish" if index == len(self.pages) - 1 else "Next >")
        
        # Create page
        self.pages[index]()
        
    def next_page(self):
        """Go to next page"""
        if self.current_page == len(self.pages) - 1:
            self.finish()
        else:
            self.show_page(self.current_page + 1)
            
    def previous_page(self):
        """Go to previous page"""
        if self.current_page > 0:
            self.show_page(self.current_page - 1)
            
    def create_welcome_page(self):
        """Create welcome page"""
        self.title_label.config(text="Welcome to Project Wizard")
        
        # Project name
        ttk.Label(self.content_frame, text="Project Name:",
                 font=("Arial", 10, "bold")).grid(row=0, column=0, sticky=tk.W, pady=10)
                 
        self.name_var = tk.StringVar(value=self.project_data.get('name', ''))
        name_entry = ttk.Entry(self.content_frame, textvariable=self.name_var, width=40)
        name_entry.grid(row=0, column=1, sticky=tk.W, pady=10)
        
        # Description
        ttk.Label(self.content_frame, text="Description:",
                 font=("Arial", 10, "bold")).grid(row=1, column=0, sticky=tk.NW, pady=10)
                 
        self.desc_text = tk.Text(self.content_frame, width=50, height=5)
        self.desc_text.grid(row=1, column=1, sticky=tk.W, pady=10)
        self.desc_text.insert(1.0, self.project_data.get('description', ''))
        
        # Project type
        ttk.Label(self.content_frame, text="Project Type:",
                 font=("Arial", 10, "bold")).grid(row=2, column=0, sticky=tk.W, pady=10)
                 
        self.type_var = tk.StringVar(value="custom")
        types = [
            ("Start from template", "template"),
            ("Create custom project", "custom"),
            ("Import existing project", "import")
        ]
        
        for i, (text, value) in enumerate(types):
            ttk.Radiobutton(self.content_frame, text=text, variable=self.type_var,
                           value=value).grid(row=2+i, column=1, sticky=tk.W, pady=2)
                           
    def create_template_page(self):
        """Create template selection page"""
        self.title_label.config(text="Select Template")
        
        if self.type_var.get() != "template":
            # Skip to next page
            self.next_page()
            return
            
        # Template list
        ttk.Label(self.content_frame, text="Available Templates:",
                 font=("Arial", 10, "bold")).pack(pady=10)
                 
        # Template listbox with descriptions
        template_frame = ttk.Frame(self.content_frame)
        template_frame.pack(fill=tk.BOTH, expand=True)
        
        # Listbox
        self.template_listbox = tk.Listbox(template_frame, height=10)
        self.template_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        # Description
        desc_frame = ttk.LabelFrame(template_frame, text="Description", padding=10)
        desc_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=10)
        
        self.template_desc = tk.Text(desc_frame, width=40, height=10, wrap=tk.WORD)
        self.template_desc.pack(fill=tk.BOTH, expand=True)
        
        # Load templates
        templates = self.config_manager.list_templates()
        for template in templates:
            self.template_listbox.insert(tk.END, template)
            
        # Bind selection
        self.template_listbox.bind('<<ListboxSelect>>', self.on_template_select)
        
    def on_template_select(self, event):
        """Handle template selection"""
        selection = self.template_listbox.curselection()
        if selection:
            template_name = self.template_listbox.get(selection[0])
            
            # Load template
            try:
                # Load template from templates directory
                template_file = self.config_manager.templates_dir / f"{template_name}.yaml"
                if template_file.exists():
                    with open(template_file, 'r') as f:
                        template_data = yaml.safe_load(f)
                    
                    # Show description
                    self.template_desc.delete(1.0, tk.END)
                    self.template_desc.insert(1.0, template_data.get('description', 'No description available'))
                    
                    # Store selection
                    self.project_data['template'] = template_name
                    self.project_data['template_data'] = template_data
                else:
                    raise FileNotFoundError(f"Template '{template_name}' not found")
                    
            except Exception as e:
                messagebox.showerror("Error", f"Failed to load template: {e}")
                
    def create_scripts_page(self):
        """Create scripts configuration page"""
        self.title_label.config(text="Configure Scripts")
        
        # Script list
        list_frame = ttk.Frame(self.content_frame)
        list_frame.pack(fill=tk.BOTH, expand=True)
        
        # Toolbar
        toolbar = ttk.Frame(list_frame)
        toolbar.pack(fill=tk.X, pady=5)
        
        ttk.Button(toolbar, text="Add Script", command=self.add_script).pack(side=tk.LEFT, padx=2)
        ttk.Button(toolbar, text="Remove", command=self.remove_script).pack(side=tk.LEFT, padx=2)
        ttk.Button(toolbar, text="Edit", command=self.edit_script).pack(side=tk.LEFT, padx=2)
        
        # Script tree
        columns = ('name', 'type', 'dependencies')
        self.script_tree = ttk.Treeview(list_frame, columns=columns, show='headings')
        
        for col in columns:
            self.script_tree.heading(col, text=col.title())
            self.script_tree.column(col, width=150)
            
        self.script_tree.pack(fill=tk.BOTH, expand=True)
        
        # Load scripts if template selected
        if self.project_data.get('template'):
            self.load_template_scripts()
            
    def load_template_scripts(self):
        """Load scripts from selected template"""
        # Implementation to load template scripts
        pass
        
    def add_script(self):
        """Add new script"""
        dialog = ScriptDialog(self.window)
        if dialog.result:
            self.project_data['scripts'].append(dialog.result)
            self.update_script_tree()
            
    def remove_script(self):
        """Remove selected script"""
        selection = self.script_tree.selection()
        if selection:
            # Remove script
            pass
            
    def edit_script(self):
        """Edit selected script"""
        selection = self.script_tree.selection()
        if selection:
            # Edit script
            pass
            
    def update_script_tree(self):
        """Update script tree display"""
        # Clear tree
        for item in self.script_tree.get_children():
            self.script_tree.delete(item)
            
        # Add scripts
        for script in self.project_data['scripts']:
            self.script_tree.insert('', tk.END, values=(
                script.get('name', ''),
                script.get('type', 'python'),
                ', '.join(script.get('dependencies', []))
            ))
            
    def create_connections_page(self):
        """Create connections configuration page"""
        self.title_label.config(text="Configure Connections")
        
        # Visual connection editor
        ttk.Label(self.content_frame, text="Drag to create connections between scripts").pack()
        
        # Canvas for visual editing
        canvas = tk.Canvas(self.content_frame, bg='white', height=400)
        canvas.pack(fill=tk.BOTH, expand=True)
        
        # Draw script nodes
        self.draw_script_nodes(canvas)
        
    def draw_script_nodes(self, canvas):
        """Draw script nodes on canvas"""
        # Implementation for visual node editor
        pass
        
    def create_summary_page(self):
        """Create summary page"""
        self.title_label.config(text="Project Summary")
        
        # Summary text
        summary = tk.Text(self.content_frame, width=60, height=20)
        summary.pack(fill=tk.BOTH, expand=True)
        
        # Generate summary
        summary_text = f"""Project: {self.name_var.get()}
Description: {self.desc_text.get(1.0, tk.END).strip()}

Scripts: {len(self.project_data['scripts'])}
"""
        
        for script in self.project_data['scripts']:
            summary_text += f"\n- {script.get('name', 'Unnamed')}"
            
        summary.insert(1.0, summary_text)
        summary.config(state='disabled')
        
    def finish(self):
        """Complete wizard"""
        # Create project configuration
        project = ProjectConfig(
            name=self.name_var.get(),
            version="1.0",
            description=self.desc_text.get(1.0, tk.END).strip(),
            scripts=self.project_data['scripts']
        )
        
        # Validate
        errors = self.config_manager.validate_project(project)
        if errors:
            messagebox.showerror("Validation Error", "\n".join(errors))
            return
            
        # Save project
        try:
            self.config_manager.save_project(project, project.name)
            self.result = project
            messagebox.showinfo("Success", f"Project '{project.name}' created successfully!")
            self.window.destroy()
        except Exception as e:
            messagebox.showerror("Error", f"Failed to create project: {e}")


class ScriptDialog:
    """Dialog for adding/editing scripts"""
    
    def __init__(self, parent, script_data=None):
        self.result = None
        
        self.dialog = tk.Toplevel(parent)
        self.dialog.title("Script Configuration")
        self.dialog.geometry("500x400")
        
        # Script data
        self.script_data = script_data or {}
        
        self.setup_ui()
        
    def setup_ui(self):
        """Setup dialog UI"""
        # Basic info
        info_frame = ttk.LabelFrame(self.dialog, text="Basic Information", padding=10)
        info_frame.pack(fill=tk.X, padx=10, pady=5)
        
        ttk.Label(info_frame, text="Script ID:").grid(row=0, column=0, sticky=tk.W, pady=2)
        self.id_var = tk.StringVar(value=self.script_data.get('id', ''))
        ttk.Entry(info_frame, textvariable=self.id_var).grid(row=0, column=1, sticky=tk.W, pady=2)
        
        ttk.Label(info_frame, text="Name:").grid(row=1, column=0, sticky=tk.W, pady=2)
        self.name_var = tk.StringVar(value=self.script_data.get('name', ''))
        ttk.Entry(info_frame, textvariable=self.name_var).grid(row=1, column=1, sticky=tk.W, pady=2)
        
        # Parameters
        param_frame = ttk.LabelFrame(self.dialog, text="Parameters", padding=10)
        param_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        # Parameter editor
        self.param_text = tk.Text(param_frame, height=10)
        self.param_text.pack(fill=tk.BOTH, expand=True)
        
        # Buttons
        button_frame = ttk.Frame(self.dialog)
        button_frame.pack(fill=tk.X, padx=10, pady=10)
        
        ttk.Button(button_frame, text="OK", command=self.ok).pack(side=tk.RIGHT, padx=5)
        ttk.Button(button_frame, text="Cancel", command=self.dialog.destroy).pack(side=tk.RIGHT)
        
    def ok(self):
        """Save script configuration"""
        self.result = {
            'id': self.id_var.get(),
            'name': self.name_var.get(),
            'parameters': {}  # Parse from text
        }
        self.dialog.destroy()


# Example usage
if __name__ == "__main__":
    # Test configuration manager
    config_mgr = ConfigurationManager()
    
    # List templates
    print("Available templates:")
    for template in config_mgr.list_templates():
        print(f"  - {template}")
        
    # Load a template
    neural_net = config_mgr.load_project("neural_network")
    print(f"\nLoaded template: {neural_net.name}")
    print(f"Scripts: {len(neural_net.scripts)}")
    
    # Validate project
    errors = config_mgr.validate_project(neural_net)
    if errors:
        print("Validation errors:", errors)
    else:
        print("Project is valid!")

========================================
# File: C:\Users\Saem1001\Documents\GitHub\ai_detect\net\neural_ide_2\app\engine\neural_ide_tools.py
========================================

# === performance_profiler.py ===
"""
Advanced Performance Profiler for Neural Script IDE
Real-time performance analysis and optimization suggestions
"""

import time
import psutil
import threading
from collections import deque, defaultdict
from dataclasses import dataclass
from typing import Dict, List, Optional, Tuple
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import tkinter as tk
from tkinter import ttk

@dataclass
class PerformanceMetric:
    """Single performance measurement"""
    timestamp: float
    cpu_percent: float
    memory_mb: float
    message_rate: float
    latency_ms: float
    error_rate: float
    custom_metrics: Dict[str, float] = None

@dataclass
class ScriptProfile:
    """Performance profile for a script"""
    script_id: str
    metrics_history: deque
    bottlenecks: List[str]
    optimization_suggestions: List[str]
    resource_usage_pattern: str  # "cpu_intensive", "memory_intensive", "io_bound", "balanced"
    
class PerformanceProfiler:
    """Advanced performance profiling system"""
    
    def __init__(self, max_history=1000):
        self.max_history = max_history
        self.script_profiles = {}
        self.global_metrics = deque(maxlen=max_history)
        self.monitoring = False
        self.monitor_thread = None
        
        # Analysis thresholds
        self.thresholds = {
            'cpu_high': 80.0,
            'memory_high': 80.0,
            'latency_high': 100.0,  # ms
            'error_rate_high': 0.05,
            'message_rate_low': 1.0
        }
        
    def start_monitoring(self, scripts: Dict[str, any]):
        """Start performance monitoring"""
        self.monitoring = True
        self.scripts = scripts
        
        # Initialize profiles
        for script_id in scripts:
            if script_id not in self.script_profiles:
                self.script_profiles[script_id] = ScriptProfile(
                    script_id=script_id,
                    metrics_history=deque(maxlen=self.max_history),
                    bottlenecks=[],
                    optimization_suggestions=[],
                    resource_usage_pattern="unknown"
                )
                
        # Start monitor thread
        self.monitor_thread = threading.Thread(target=self._monitor_loop, daemon=True)
        self.monitor_thread.start()
        
    def stop_monitoring(self):
        """Stop performance monitoring"""
        self.monitoring = False
        if self.monitor_thread:
            self.monitor_thread.join(timeout=1)
            
    def _monitor_loop(self):
        """Main monitoring loop"""
        while self.monitoring:
            try:
                # Collect metrics for each script
                for script_id, script_obj in self.scripts.items():
                    if hasattr(script_obj, 'process') and script_obj.process:
                        metrics = self._collect_metrics(script_obj)
                        if metrics:
                            self.script_profiles[script_id].metrics_history.append(metrics)
                            
                # Analyze performance
                self._analyze_performance()
                
                # Global system metrics
                global_metric = PerformanceMetric(
                    timestamp=time.time(),
                    cpu_percent=psutil.cpu_percent(interval=0.1),
                    memory_mb=psutil.virtual_memory().used / 1024 / 1024,
                    message_rate=self._calculate_global_message_rate(),
                    latency_ms=self._calculate_global_latency(),
                    error_rate=self._calculate_global_error_rate()
                )
                self.global_metrics.append(global_metric)
                
                time.sleep(1)  # Monitor interval
                
            except Exception as e:
                print(f"Monitor error: {e}")
                
    def _collect_metrics(self, script_obj) -> Optional[PerformanceMetric]:
        """Collect metrics for a single script"""
        try:
            proc = psutil.Process(script_obj.process.pid)
            
            # Basic metrics
            cpu_percent = proc.cpu_percent(interval=0.1)
            memory_info = proc.memory_info()
            memory_mb = memory_info.rss / 1024 / 1024
            
            # Get custom metrics from script
            custom_metrics = {}
            if hasattr(script_obj, 'script_node'):
                custom_metrics = script_obj.script_node.metrics.copy()
                
            # Calculate rates
            message_rate = custom_metrics.get('message_rate', 0)
            latency_ms = custom_metrics.get('latency_ms', 0)
            error_rate = custom_metrics.get('error_rate', 0)
            
            return PerformanceMetric(
                timestamp=time.time(),
                cpu_percent=cpu_percent,
                memory_mb=memory_mb,
                message_rate=message_rate,
                latency_ms=latency_ms,
                error_rate=error_rate,
                custom_metrics=custom_metrics
            )
            
        except (psutil.NoSuchProcess, psutil.AccessDenied):
            return None
            
    def _analyze_performance(self):
        """Analyze performance and identify issues"""
        for script_id, profile in self.script_profiles.items():
            if len(profile.metrics_history) < 10:
                continue
                
            # Get recent metrics
            recent_metrics = list(profile.metrics_history)[-100:]
            
            # Reset analysis
            profile.bottlenecks.clear()
            profile.optimization_suggestions.clear()
            
            # Analyze CPU usage
            avg_cpu = np.mean([m.cpu_percent for m in recent_metrics])
            max_cpu = np.max([m.cpu_percent for m in recent_metrics])
            
            if avg_cpu > self.thresholds['cpu_high']:
                profile.bottlenecks.append("High CPU usage")
                profile.optimization_suggestions.append(
                    "Consider optimizing compute-intensive operations or using multiprocessing"
                )
                
            # Analyze memory usage
            avg_memory = np.mean([m.memory_mb for m in recent_metrics])
            memory_trend = np.polyfit(range(len(recent_metrics)), 
                                    [m.memory_mb for m in recent_metrics], 1)[0]
                                    
            if memory_trend > 1.0:  # Growing by >1MB per measurement
                profile.bottlenecks.append("Memory leak detected")
                profile.optimization_suggestions.append(
                    "Check for growing data structures or unclosed resources"
                )
                
            # Analyze message latency
            if recent_metrics[-1].latency_ms > self.thresholds['latency_high']:
                profile.bottlenecks.append("High message latency")
                profile.optimization_suggestions.append(
                    "Consider batching messages or optimizing message processing"
                )
                
            # Determine resource pattern
            if avg_cpu > 70:
                profile.resource_usage_pattern = "cpu_intensive"
            elif avg_memory > 1000:  # >1GB
                profile.resource_usage_pattern = "memory_intensive"
            elif recent_metrics[-1].message_rate > 100:
                profile.resource_usage_pattern = "io_bound"
            else:
                profile.resource_usage_pattern = "balanced"
                
    def get_optimization_report(self, script_id: str) -> Dict:
        """Get detailed optimization report for a script"""
        if script_id not in self.script_profiles:
            return {"error": "Script not found"}
            
        profile = self.script_profiles[script_id]
        
        if len(profile.metrics_history) < 10:
            return {"error": "Insufficient data"}
            
        recent_metrics = list(profile.metrics_history)[-100:]
        
        report = {
            "script_id": script_id,
            "resource_pattern": profile.resource_usage_pattern,
            "bottlenecks": profile.bottlenecks,
            "suggestions": profile.optimization_suggestions,
            "metrics_summary": {
                "avg_cpu": np.mean([m.cpu_percent for m in recent_metrics]),
                "max_cpu": np.max([m.cpu_percent for m in recent_metrics]),
                "avg_memory_mb": np.mean([m.memory_mb for m in recent_metrics]),
                "max_memory_mb": np.max([m.memory_mb for m in recent_metrics]),
                "avg_latency_ms": np.mean([m.latency_ms for m in recent_metrics]),
                "total_errors": sum([m.error_rate for m in recent_metrics])
            },
            "performance_score": self._calculate_performance_score(recent_metrics)
        }
        
        return report
        
    def _calculate_performance_score(self, metrics: List[PerformanceMetric]) -> float:
        """Calculate overall performance score (0-100)"""
        if not metrics:
            return 0.0
            
        # Weighted scoring
        cpu_score = 100 - min(np.mean([m.cpu_percent for m in metrics]), 100)
        memory_score = 100 - min(np.mean([m.memory_mb for m in metrics]) / 10, 100)
        latency_score = 100 - min(np.mean([m.latency_ms for m in metrics]) / 10, 100)
        error_score = 100 - min(np.mean([m.error_rate for m in metrics]) * 1000, 100)
        
        # Weighted average
        score = (cpu_score * 0.3 + 
                memory_score * 0.3 + 
                latency_score * 0.3 + 
                error_score * 0.1)
                
        return round(score, 1)
        
    def _calculate_global_message_rate(self) -> float:
        """Calculate global message rate"""
        # Implementation would sum across all scripts
        return sum([
            profile.metrics_history[-1].message_rate 
            if profile.metrics_history else 0
            for profile in self.script_profiles.values()
        ])
        
    def _calculate_global_latency(self) -> float:
        """Calculate average global latency"""
        latencies = [
            profile.metrics_history[-1].latency_ms 
            if profile.metrics_history else 0
            for profile in self.script_profiles.values()
        ]
        return np.mean(latencies) if latencies else 0
        
    def _calculate_global_error_rate(self) -> float:
        """Calculate global error rate"""
        error_rates = [
            profile.metrics_history[-1].error_rate 
            if profile.metrics_history else 0
            for profile in self.script_profiles.values()
        ]
        return np.mean(error_rates) if error_rates else 0


class PerformanceViewer(ttk.Frame):
    """Performance visualization widget"""
    
    def __init__(self, parent, profiler: PerformanceProfiler):
        super().__init__(parent)
        self.profiler = profiler
        self.selected_script = None
        self.setup_ui()
        self.update_display()
        
    def setup_ui(self):
        """Setup performance viewer UI"""
        # Control panel
        control_frame = ttk.Frame(self)
        control_frame.pack(fill=tk.X, padx=5, pady=5)
        
        ttk.Label(control_frame, text="Script:").pack(side=tk.LEFT, padx=5)
        
        self.script_var = tk.StringVar()
        self.script_combo = ttk.Combobox(control_frame, textvariable=self.script_var,
                                        state="readonly", width=20)
        self.script_combo.pack(side=tk.LEFT, padx=5)
        self.script_combo.bind('<<ComboboxSelected>>', self.on_script_select)
        
        ttk.Button(control_frame, text="Refresh", 
                  command=self.update_display).pack(side=tk.LEFT, padx=5)
                  
        ttk.Button(control_frame, text="Export Report", 
                  command=self.export_report).pack(side=tk.LEFT, padx=5)
                  
        # Main display area
        display_frame = ttk.Frame(self)
        display_frame.pack(fill=tk.BOTH, expand=True)
        
        # Create notebook for different views
        self.notebook = ttk.Notebook(display_frame)
        self.notebook.pack(fill=tk.BOTH, expand=True)
        
        # Real-time metrics tab
        metrics_frame = ttk.Frame(self.notebook)
        self.notebook.add(metrics_frame, text="Real-time Metrics")
        self.setup_metrics_view(metrics_frame)
        
        # Analysis tab
        analysis_frame = ttk.Frame(self.notebook)
        self.notebook.add(analysis_frame, text="Analysis")
        self.setup_analysis_view(analysis_frame)
        
        # Optimization tab
        optimization_frame = ttk.Frame(self.notebook)
        self.notebook.add(optimization_frame, text="Optimization")
        self.setup_optimization_view(optimization_frame)
        
    def setup_metrics_view(self, parent):
        """Setup real-time metrics view"""
        # Create matplotlib figure
        self.figure = plt.Figure(figsize=(10, 6), dpi=80)
        
        # Create subplots
        self.cpu_ax = self.figure.add_subplot(221)
        self.memory_ax = self.figure.add_subplot(222)
        self.latency_ax = self.figure.add_subplot(223)
        self.rate_ax = self.figure.add_subplot(224)
        
        # Configure axes
        for ax, title in [
            (self.cpu_ax, "CPU Usage (%)"),
            (self.memory_ax, "Memory (MB)"),
            (self.latency_ax, "Latency (ms)"),
            (self.rate_ax, "Message Rate")
        ]:
            ax.set_title(title)
            ax.set_xlabel("Time")
            ax.grid(True, alpha=0.3)
            
        self.figure.tight_layout()
        
        # Create canvas
        self.canvas = FigureCanvasTkAgg(self.figure, parent)
        self.canvas.draw()
        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
        
    def setup_analysis_view(self, parent):
        """Setup analysis view"""
        # Summary frame
        summary_frame = ttk.LabelFrame(parent, text="Performance Summary", padding=10)
        summary_frame.pack(fill=tk.X, padx=5, pady=5)
        
        self.summary_text = tk.Text(summary_frame, height=10, width=60)
        self.summary_text.pack(fill=tk.BOTH, expand=True)
        
        # Bottlenecks frame
        bottleneck_frame = ttk.LabelFrame(parent, text="Identified Bottlenecks", padding=10)
        bottleneck_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        self.bottleneck_list = tk.Listbox(bottleneck_frame, height=10)
        self.bottleneck_list.pack(fill=tk.BOTH, expand=True)
        
    def setup_optimization_view(self, parent):
        """Setup optimization suggestions view"""
        # Suggestions text
        self.suggestions_text = tk.Text(parent, wrap=tk.WORD, padx=10, pady=10)
        self.suggestions_text.pack(fill=tk.BOTH, expand=True)
        
        # Configure tags
        self.suggestions_text.tag_config("header", font=("Arial", 12, "bold"))
        self.suggestions_text.tag_config("suggestion", font=("Arial", 10), 
                                       foreground="blue")
                                       
    def update_display(self):
        """Update all displays"""
        # Update script list
        scripts = list(self.profiler.script_profiles.keys())
        self.script_combo['values'] = scripts
        
        if self.selected_script:
            self.update_metrics()
            self.update_analysis()
            self.update_optimization()
            
        # Schedule next update
        self.after(1000, self.update_display)
        
    def on_script_select(self, event):
        """Handle script selection"""
        self.selected_script = self.script_var.get()
        self.update_metrics()
        self.update_analysis()
        self.update_optimization()
        
    def update_metrics(self):
        """Update metrics graphs"""
        if not self.selected_script:
            return
            
        profile = self.profiler.script_profiles.get(self.selected_script)
        if not profile or len(profile.metrics_history) < 2:
            return
            
        # Get data
        metrics = list(profile.metrics_history)
        times = [(m.timestamp - metrics[0].timestamp) for m in metrics]
        
        # Clear and update plots
        for ax in [self.cpu_ax, self.memory_ax, self.latency_ax, self.rate_ax]:
            ax.clear()
            
        # CPU plot
        self.cpu_ax.plot(times, [m.cpu_percent for m in metrics], 'b-')
        self.cpu_ax.set_title("CPU Usage (%)")
        self.cpu_ax.set_ylim(0, 100)
        
        # Memory plot
        self.memory_ax.plot(times, [m.memory_mb for m in metrics], 'g-')
        self.memory_ax.set_title("Memory (MB)")
        
        # Latency plot
        self.latency_ax.plot(times, [m.latency_ms for m in metrics], 'r-')
        self.latency_ax.set_title("Latency (ms)")
        
        # Message rate plot
        self.rate_ax.plot(times, [m.message_rate for m in metrics], 'm-')
        self.rate_ax.set_title("Message Rate")
        
        # Add grid
        for ax in [self.cpu_ax, self.memory_ax, self.latency_ax, self.rate_ax]:
            ax.grid(True, alpha=0.3)
            ax.set_xlabel("Time (s)")
            
        self.figure.tight_layout()
        self.canvas.draw()
        
    def update_analysis(self):
        """Update analysis display"""
        if not self.selected_script:
            return
            
        report = self.profiler.get_optimization_report(self.selected_script)
        
        if "error" in report:
            self.summary_text.delete(1.0, tk.END)
            self.summary_text.insert(1.0, report["error"])
            return
            
        # Update summary
        self.summary_text.delete(1.0, tk.END)
        summary = f"""Script: {report['script_id']}
Resource Pattern: {report['resource_pattern']}
Performance Score: {report['performance_score']}/100

Metrics Summary:
- Average CPU: {report['metrics_summary']['avg_cpu']:.1f}%
- Maximum CPU: {report['metrics_summary']['max_cpu']:.1f}%
- Average Memory: {report['metrics_summary']['avg_memory_mb']:.1f} MB
- Maximum Memory: {report['metrics_summary']['max_memory_mb']:.1f} MB
- Average Latency: {report['metrics_summary']['avg_latency_ms']:.1f} ms
- Total Errors: {report['metrics_summary']['total_errors']}
"""
        self.summary_text.insert(1.0, summary)
        
        # Update bottlenecks
        self.bottleneck_list.delete(0, tk.END)
        for bottleneck in report['bottlenecks']:
            self.bottleneck_list.insert(tk.END, f"‚ö†Ô∏è {bottleneck}")
            
    def update_optimization(self):
        """Update optimization suggestions"""
        if not self.selected_script:
            return
            
        report = self.profiler.get_optimization_report(self.selected_script)
        
        if "error" in report:
            return
            
        # Clear and update suggestions
        self.suggestions_text.delete(1.0, tk.END)
        
        self.suggestions_text.insert(tk.END, "Optimization Suggestions\n\n", "header")
        
        for i, suggestion in enumerate(report['suggestions'], 1):
            self.suggestions_text.insert(tk.END, f"{i}. {suggestion}\n\n", "suggestion")
            
        # Add resource-specific suggestions
        if report['resource_pattern'] == "cpu_intensive":
            self.suggestions_text.insert(tk.END, "\nCPU Optimization Tips:\n", "header")
            self.suggestions_text.insert(tk.END, 
                "‚Ä¢ Use NumPy for numerical computations\n"
                "‚Ä¢ Consider Cython for performance-critical code\n"
                "‚Ä¢ Implement caching for repeated calculations\n"
                "‚Ä¢ Use multiprocessing for parallel tasks\n", "suggestion")
                
        elif report['resource_pattern'] == "memory_intensive":
            self.suggestions_text.insert(tk.END, "\nMemory Optimization Tips:\n", "header")
            self.suggestions_text.insert(tk.END,
                "‚Ä¢ Use generators instead of lists for large datasets\n"
                "‚Ä¢ Implement data streaming instead of loading all at once\n"
                "‚Ä¢ Clear unused variables explicitly\n"
                "‚Ä¢ Consider using memory-mapped files\n", "suggestion")
                
    def export_report(self):
        """Export performance report"""
        if not self.selected_script:
            return
            
        from tkinter import filedialog
        
        filename = filedialog.asksaveasfilename(
            defaultextension=".json",
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")]
        )
        
        if filename:
            report = self.profiler.get_optimization_report(self.selected_script)
            
            # Add timestamp
            report['exported_at'] = time.strftime("%Y-%m-%d %H:%M:%S")
            
            import json
            with open(filename, 'w') as f:
                json.dump(report, f, indent=2)
                
            tk.messagebox.showinfo("Export Complete", f"Report saved to {filename}")


# === message_debugger.py ===
"""
Message Debugger for Neural Script IDE
Advanced message inspection and debugging tools
"""

import json
import time
from datetime import datetime
from collections import defaultdict, deque
from typing import Dict, List, Any, Optional, Tuple
import tkinter as tk
from tkinter import ttk, messagebox
import re

class MessageFilter:
    """Filter for messages"""
    def __init__(self):
        self.sender_pattern = None
        self.receiver_pattern = None
        self.message_type = None
        self.payload_pattern = None
        self.time_range = None
        
    def matches(self, message) -> bool:
        """Check if message matches filter criteria"""
        # Sender filter
        if self.sender_pattern:
            if not re.match(self.sender_pattern, message.sender_id):
                return False
                
        # Receiver filter
        if self.receiver_pattern:
            if not re.match(self.receiver_pattern, message.receiver_id):
                return False
                
        # Type filter
        if self.message_type:
            if message.message_type != self.message_type:
                return False
                
        # Payload filter
        if self.payload_pattern:
            payload_str = str(message.payload)
            if not re.search(self.payload_pattern, payload_str):
                return False
                
        # Time filter
        if self.time_range:
            start, end = self.time_range
            if not (start <= message.timestamp <= end):
                return False
                
        return True

class MessageDebugger:
    """Advanced message debugging system"""
    
    def __init__(self, message_broker):
        self.message_broker = message_broker
        self.breakpoints = []
        self.message_log = deque(maxlen=10000)
        self.statistics = defaultdict(lambda: defaultdict(int))
        self.paused_messages = []
        self.debug_mode = False
        
    def add_breakpoint(self, filter_: MessageFilter):
        """Add message breakpoint"""
        self.breakpoints.append(filter_)
        
    def remove_breakpoint(self, index: int):
        """Remove breakpoint by index"""
        if 0 <= index < len(self.breakpoints):
            del self.breakpoints[index]
            
    def intercept_message(self, message) -> bool:
        """Intercept message for debugging"""
        # Log message
        self.message_log.append(message)
        
        # Update statistics
        self.statistics[message.sender_id]['sent'] += 1
        self.statistics[message.receiver_id]['received'] += 1
        self.statistics['_global']['total'] += 1
        
        # Check breakpoints
        if self.debug_mode:
            for bp in self.breakpoints:
                if bp.matches(message):
                    self.paused_messages.append(message)
                    return True  # Pause message delivery
                    
        return False  # Continue normal delivery
        
    def get_message_flow(self, start_time: float = None, 
                        end_time: float = None) -> List[Tuple[str, str, float]]:
        """Get message flow for visualization"""
        flow = []
        
        for msg in self.message_log:
            if start_time and msg.timestamp < start_time:
                continue
            if end_time and msg.timestamp > end_time:
                continue
                
            flow.append((msg.sender_id, msg.receiver_id, msg.timestamp))
            
        return flow
        
    def get_statistics(self) -> Dict:
        """Get message statistics"""
        return {
            'total_messages': self.statistics['_global']['total'],
            'by_sender': dict(self.statistics),
            'message_rate': self._calculate_message_rate(),
            'average_size': self._calculate_average_size(),
            'peak_rate': self._calculate_peak_rate()
        }
        
    def _calculate_message_rate(self) -> float:
        """Calculate current message rate"""
        if len(self.message_log) < 2:
            return 0.0
            
        recent = list(self.message_log)[-100:]
        time_span = recent[-1].timestamp - recent[0].timestamp
        
        if time_span > 0:
            return len(recent) / time_span
        return 0.0
        
    def _calculate_average_size(self) -> float:
        """Calculate average message payload size"""
        if not self.message_log:
            return 0.0
            
        sizes = []
        for msg in list(self.message_log)[-100:]:
            sizes.append(len(json.dumps(msg.payload)))
            
        return sum(sizes) / len(sizes) if sizes else 0.0
        
    def _calculate_peak_rate(self) -> float:
        """Calculate peak message rate"""
        # Implementation for peak rate calculation
        return 0.0

class MessageDebuggerUI(ttk.Frame):
    """Message debugger UI"""
    
    def __init__(self, parent, debugger: MessageDebugger):
        super().__init__(parent)
        self.debugger = debugger
        self.setup_ui()
        self.update_display()
        
    def setup_ui(self):
        """Setup debugger UI"""
        # Control panel
        control_frame = ttk.Frame(self)
        control_frame.pack(fill=tk.X, padx=5, pady=5)
        
        self.debug_var = tk.BooleanVar(value=self.debugger.debug_mode)
        ttk.Checkbutton(control_frame, text="Debug Mode", 
                       variable=self.debug_var,
                       command=self.toggle_debug).pack(side=tk.LEFT, padx=5)
                       
        ttk.Button(control_frame, text="Clear Log",
                  command=self.clear_log).pack(side=tk.LEFT, padx=5)
                  
        ttk.Button(control_frame, text="Add Breakpoint",
                  command=self.add_breakpoint).pack(side=tk.LEFT, padx=5)
                  
        # Filter controls
        filter_frame = ttk.LabelFrame(control_frame, text="Filter", padding=5)
        filter_frame.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=10)
        
        self.filter_sender = tk.StringVar()
        ttk.Label(filter_frame, text="Sender:").pack(side=tk.LEFT)
        ttk.Entry(filter_frame, textvariable=self.filter_sender, 
                 width=15).pack(side=tk.LEFT, padx=2)
                 
        self.filter_type = tk.StringVar()
        ttk.Label(filter_frame, text="Type:").pack(side=tk.LEFT)
        ttk.Combobox(filter_frame, textvariable=self.filter_type,
                    values=["all", "data", "control", "status", "error"],
                    width=10).pack(side=tk.LEFT, padx=2)
                    
        ttk.Button(filter_frame, text="Apply",
                  command=self.apply_filter).pack(side=tk.LEFT, padx=5)
                  
        # Main display
        display_frame = ttk.Frame(self)
        display_frame.pack(fill=tk.BOTH, expand=True)
        
        # Create paned window
        paned = ttk.PanedWindow(display_frame, orient=tk.HORIZONTAL)
        paned.pack(fill=tk.BOTH, expand=True)
        
        # Message log
        log_frame = ttk.LabelFrame(paned, text="Message Log", padding=5)
        paned.add(log_frame, weight=2)
        
        # Create treeview for messages
        columns = ('time', 'sender', 'receiver', 'type', 'size', 'preview')
        self.message_tree = ttk.Treeview(log_frame, columns=columns, show='headings')
        
        # Configure columns
        self.message_tree.heading('time', text='Time')
        self.message_tree.heading('sender', text='Sender')
        self.message_tree.heading('receiver', text='Receiver')
        self.message_tree.heading('type', text='Type')
        self.message_tree.heading('size', text='Size')
        self.message_tree.heading('preview', text='Preview')
        
        self.message_tree.column('time', width=80)
        self.message_tree.column('sender', width=100)
        self.message_tree.column('receiver', width=100)
        self.message_tree.column('type', width=60)
        self.message_tree.column('size', width=60)
        self.message_tree.column('preview', width=200)
        
        self.message_tree.pack(fill=tk.BOTH, expand=True)
        
        # Scrollbar
        scrollbar = ttk.Scrollbar(log_frame, orient=tk.VERTICAL,
                                 command=self.message_tree.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.message_tree.configure(yscrollcommand=scrollbar.set)
        
        # Bind selection
        self.message_tree.bind('<<TreeviewSelect>>', self.on_message_select)
        
        # Details panel
        details_frame = ttk.LabelFrame(paned, text="Message Details", padding=5)
        paned.add(details_frame, weight=1)
        
        self.details_text = tk.Text(details_frame, wrap=tk.WORD)
        self.details_text.pack(fill=tk.BOTH, expand=True)
        
        # Breakpoints panel
        bp_frame = ttk.LabelFrame(display_frame, text="Breakpoints", padding=5)
        bp_frame.pack(fill=tk.X, pady=5)
        
        self.bp_listbox = tk.Listbox(bp_frame, height=3)
        self.bp_listbox.pack(fill=tk.X, side=tk.LEFT, expand=True)
        
        ttk.Button(bp_frame, text="Remove",
                  command=self.remove_breakpoint).pack(side=tk.LEFT, padx=5)
                  
    def toggle_debug(self):
        """Toggle debug mode"""
        self.debugger.debug_mode = self.debug_var.get()
        
    def clear_log(self):
        """Clear message log"""
        self.debugger.message_log.clear()
        self.update_display()
        
    def add_breakpoint(self):
        """Add new breakpoint"""
        dialog = BreakpointDialog(self)
        if dialog.result:
            self.debugger.add_breakpoint(dialog.result)
            self.update_breakpoints()
            
    def remove_breakpoint(self):
        """Remove selected breakpoint"""
        selection = self.bp_listbox.curselection()
        if selection:
            self.debugger.remove_breakpoint(selection[0])
            self.update_breakpoints()
            
    def apply_filter(self):
        """Apply display filter"""
        self.update_display()
        
    def update_display(self):
        """Update message display"""
        # Clear tree
        for item in self.message_tree.get_children():
            self.message_tree.delete(item)
            
        # Get filter criteria
        sender_filter = self.filter_sender.get()
        type_filter = self.filter_type.get()
        
        # Add messages
        for msg in reversed(list(self.debugger.message_log)):
            # Apply filters
            if sender_filter and sender_filter not in msg.sender_id:
                continue
            if type_filter != "all" and msg.message_type.value != type_filter:
                continue
                
            # Format message
            time_str = datetime.fromtimestamp(msg.timestamp).strftime("%H:%M:%S.%f")[:-3]
            size = len(json.dumps(msg.payload))
            preview = str(msg.payload)[:100]
            
            self.message_tree.insert('', 0, values=(
                time_str,
                msg.sender_id,
                msg.receiver_id,
                msg.message_type.value,
                size,
                preview
            ))
            
        # Update statistics
        self.update_statistics()
        
        # Schedule next update
        self.after(500, self.update_display)
        
    def update_breakpoints(self):
        """Update breakpoints display"""
        self.bp_listbox.delete(0, tk.END)
        
        for i, bp in enumerate(self.debugger.breakpoints):
            desc = f"BP{i}: "
            if bp.sender_pattern:
                desc += f"sender={bp.sender_pattern} "
            if bp.receiver_pattern:
                desc += f"receiver={bp.receiver_pattern} "
            if bp.message_type:
                desc += f"type={bp.message_type} "
                
            self.bp_listbox.insert(tk.END, desc)
            
    def update_statistics(self):
        """Update statistics display"""
        stats = self.debugger.get_statistics()
        
        # Update status bar or statistics panel
        # Implementation depends on UI layout
        
    def on_message_select(self, event):
        """Handle message selection"""
        selection = self.message_tree.selection()
        if not selection:
            return
            
        # Get selected message index
        item = self.message_tree.item(selection[0])
        values = item['values']
        
        # Find corresponding message
        # This is simplified - in real implementation would use message ID
        time_str = values[0]
        
        # Display full message details
        self.details_text.delete(1.0, tk.END)
        
        # Find message by matching fields
        for msg in self.debugger.message_log:
            msg_time = datetime.fromtimestamp(msg.timestamp).strftime("%H:%M:%S.%f")[:-3]
            if msg_time == time_str:
                # Format message details
                details = f"""Timestamp: {msg.timestamp}
Time: {datetime.fromtimestamp(msg.timestamp).strftime("%Y-%m-%d %H:%M:%S.%f")}
Sender: {msg.sender_id}
Receiver: {msg.receiver_id}
Type: {msg.message_type.value}

Payload:
{json.dumps(msg.payload, indent=2)}
"""
                self.details_text.insert(1.0, details)
                break

class BreakpointDialog:
    """Dialog for creating message breakpoints"""
    
    def __init__(self, parent):
        self.result = None
        
        self.dialog = tk.Toplevel(parent)
        self.dialog.title("Add Breakpoint")
        self.dialog.geometry("400x300")
        
        self.setup_ui()
        
    def setup_ui(self):
        """Setup dialog UI"""
        # Sender pattern
        ttk.Label(self.dialog, text="Sender Pattern (regex):").grid(
            row=0, column=0, sticky=tk.W, padx=10, pady=5)
        self.sender_entry = ttk.Entry(self.dialog, width=30)
        self.sender_entry.grid(row=0, column=1, padx=10, pady=5)
        
        # Receiver pattern
        ttk.Label(self.dialog, text="Receiver Pattern (regex):").grid(
            row=1, column=0, sticky=tk.W, padx=10, pady=5)
        self.receiver_entry = ttk.Entry(self.dialog, width=30)
        self.receiver_entry.grid(row=1, column=1, padx=10, pady=5)
        
        # Message type
        ttk.Label(self.dialog, text="Message Type:").grid(
            row=2, column=0, sticky=tk.W, padx=10, pady=5)
        self.type_var = tk.StringVar(value="any")
        type_combo = ttk.Combobox(self.dialog, textvariable=self.type_var,
                                 values=["any", "data", "control", "status", "error"],
                                 width=28)
        type_combo.grid(row=2, column=1, padx=10, pady=5)
        
        # Payload pattern
        ttk.Label(self.dialog, text="Payload Pattern (regex):").grid(
            row=3, column=0, sticky=tk.W, padx=10, pady=5)
        self.payload_entry = ttk.Entry(self.dialog, width=30)
        self.payload_entry.grid(row=3, column=1, padx=10, pady=5)
        
        # Buttons
        button_frame = ttk.Frame(self.dialog)
        button_frame.grid(row=4, column=0, columnspan=2, pady=20)
        
        ttk.Button(button_frame, text="OK", command=self.ok).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Cancel", 
                  command=self.dialog.destroy).pack(side=tk.LEFT, padx=5)
                  
    def ok(self):
        """Create breakpoint from inputs"""
        filter_ = MessageFilter()
        
        # Set patterns
        if self.sender_entry.get():
            filter_.sender_pattern = self.sender_entry.get()
        if self.receiver_entry.get():
            filter_.receiver_pattern = self.receiver_entry.get()
        if self.type_var.get() != "any":
            filter_.message_type = self.type_var.get()
        if self.payload_entry.get():
            filter_.payload_pattern = self.payload_entry.get()
            
        self.result = filter_
        self.dialog.destroy()


# Example usage
if __name__ == "__main__":
    # Test performance profiler
    profiler = PerformanceProfiler()
    
    # Simulate some metrics
    test_metric = PerformanceMetric(
        timestamp=time.time(),
        cpu_percent=45.2,
        memory_mb=256.8,
        message_rate=150.5,
        latency_ms=23.4,
        error_rate=0.01
    )
    
    print("Performance metric created:", test_metric)
