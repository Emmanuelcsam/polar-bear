
========================================
# File: C:\Users\Saem1001\Documents\GitHub\ai_detect\net\neural_ide_lite_2\launch_synapse_ide.py
========================================

#!/usr/bin/env python3
"""
Synapse IDE Launcher
Handles dependency checks, installation, and launches the main application.
This is a robust launcher designed for a smooth startup experience.
"""

import sys
import subprocess
import os
from pathlib import Path

# --- Configuration: All required and optional packages ---
# This dictionary ensures all dependencies are checked before launch.
PACKAGES = {
    "required": {
        "tkinter": "tkinter",       # Standard GUI library
        "ttkthemes": "ttkthemes",   # For modern UI styling
        "Pillow": "Pillow",         # For image handling in the UI
        "pyyaml": "PyYAML",         # For human-readable project configurations
        "networkx": "networkx",     # For dependency visualization
        "matplotlib": "matplotlib", # For plotting graphs
        "psutil": "psutil"          # For performance monitoring
    },
    "optional": {
        "pylint": "pylint",         # For advanced code analysis
        "openai": "openai",         # For AI-powered suggestions
        "requests": "requests",     # For the Auto-Healer to search for solutions
        "beautifulsoup4": "beautifulsoup4" # For parsing web content in Auto-Healer
    }
}

def check_python_version():
    """Ensures the Python version is 3.7 or higher for compatibility."""
    print("Step 1: Checking Python version...")
    if sys.version_info < (3, 7):
        print(f"❌ Error: Python 3.7 or higher is required.")
        print(f"   Your version is: {sys.version}")
        return False
    print(f"✅ Python version {sys.version_info.major}.{sys.version_info.minor} is compatible.")
    return True

def get_missing_packages():
    """
    Checks for all required and optional packages.
    Returns two lists: missing required and missing optional packages.
    """
    print("\nStep 2: Checking for required packages...")
    missing_required = []
    for module, package in PACKAGES["required"].items():
        try:
            # Tkinter is a special case
            if module == 'tkinter' and sys.version_info.major == 3:
                import tkinter
            else:
                __import__(module)
        except ImportError:
            # On Linux, tkinter might need a separate install
            if module == 'tkinter':
                missing_required.append('python3-tk') 
            else:
                missing_required.append(package)

    if not missing_required:
        print("✅ All required packages are installed.")
    else:
        print(f"⚠️ Missing required packages: {', '.join(missing_required)}")

    print("\nStep 3: Checking for optional AI & Analysis packages...")
    missing_optional = []
    for module, package in PACKAGES["optional"].items():
        try:
            __import__(module)
        except ImportError:
            missing_optional.append(package)

    if not missing_optional:
        print("✅ All optional packages are installed.")
    else:
        print(f"⚠️ Missing optional packages: {', '.join(missing_optional)}")

    return missing_required, missing_optional

def install_packages(packages_to_install: list):
    """Installs a list of Python packages using pip."""
    if not packages_to_install:
        return True

    print(f"\nInstalling: {', '.join(packages_to_install)}")
    try:
        # We use sys.executable to ensure we're using the pip for the correct Python interpreter
        subprocess.check_call([sys.executable, "-m", "pip", "install", "--upgrade", "pip"])
        subprocess.check_call([sys.executable, "-m", "pip", "install"] + packages_to_install)
        print("\n✅ Installation successful!")
        return True
    except subprocess.CalledProcessError as e:
        print(f"\n❌ Pip installation failed: {e}")
        print("   Please try installing the packages manually and run the launcher again.")
        return False
    except Exception as e:
        print(f"\n❌ An unexpected error occurred during installation: {e}")
        return False

def launch_app():
    """Finds and launches the main Synapse IDE application."""
    print("\nStep 4: Launching Synapse IDE...")
    print("-" * 50)
    
    script_dir = Path(__file__).parent.resolve()
    main_app_file = script_dir / "synapse_ide_main.py"

    if not main_app_file.exists():
        print(f"❌ Critical Error: Main application file not found!")
        print(f"   Expected at: {main_app_file}")
        print("   Please ensure 'synapse_ide_main.py' is in the same directory.")
        return

    # Add the script's directory to the Python path to ensure local imports work
    sys.path.insert(0, str(script_dir))
    
    try:
        # Dynamically import and run the main application
        from synapse_ide_main import main as run_app
        run_app()
    except ImportError as e:
        print(f"\n❌ Error: Could not import the main application.")
        print(f"   Details: {e}")
        print("   This might be due to a missing dependency or an error in the main script.")
        import traceback
        traceback.print_exc()
    except Exception as e:
        print(f"\n❌ An unexpected error occurred while launching the application:")
        import traceback
        traceback.print_exc()

def main():
    """Main function to run the launcher sequence."""
    print("=" * 50)
    print("      Welcome to the Synapse IDE Launcher")
    print("=" * 50)

    if not check_python_version():
        input("\nPress Enter to exit.")
        sys.exit(1)

    missing_required, missing_optional = get_missing_packages()

    if missing_required:
        prompt = f"\nSome required packages are missing. Install them now? (y/n): "
        if input(prompt).lower() == 'y':
            if not install_packages(missing_required):
                input("\nPress Enter to exit.")
                sys.exit(1)
        else:
            print("\nCannot start without required packages. Exiting.")
            sys.exit(1)

    if missing_optional:
        prompt = f"\nOptional packages for AI features are missing. Install for the best experience? (y/n): "
        if input(prompt).lower() == 'y':
            install_packages(missing_optional)

    launch_app()
    print("-" * 50)
    print("Synapse IDE has closed. Thank you for using it!")

if __name__ == "__main__":
    main()

========================================
# File: C:\Users\Saem1001\Documents\GitHub\ai_detect\net\neural_ide_lite_2\main_script.py
========================================

# Script: main_script

print("Hello from main_script")


========================================
# File: C:\Users\Saem1001\Documents\GitHub\ai_detect\net\neural_ide_lite_2\synapse_config.py
========================================

"""
Synapse Config: Manages project and script configurations for Synapse IDE.
- Uses clear, dataclass-based structures for projects and scripts.
- Saves configurations in human-readable YAML format.
- Automatically creates default templates to help users get started.
"""

import yaml
from pathlib import Path
from dataclasses import dataclass, field, asdict
from typing import Dict, List, Any, Optional
from datetime import datetime
import networkx as nx

# --- Data Structures for Projects and Scripts ---

@dataclass
class ScriptConfig:
    """Configuration for a single script within a project."""
    id: str
    name: str
    description: str = "A Python script."
    file_path: Optional[str] = None
    dependencies: List[str] = field(default_factory=list)
    parameters: Dict[str, Any] = field(default_factory=dict)
    
    # --- NEW: Configuration for autonomous operation ---
    # When true, automatically analyzes the script's syntax on every save.
    auto_check_on_save: bool = False
    # When true, runs the script in a self-healing loop until it succeeds.
    autonomous_mode: bool = False
    
@dataclass
class ProjectConfig:
    """Configuration for an entire Synapse IDE project."""
    name: str
    description: str = "A Synapse IDE project."
    version: str = "1.0"
    created_at: str = field(default_factory=lambda: datetime.now().isoformat())
    modified_at: str = field(default_factory=lambda: datetime.now().isoformat())
    scripts: List[ScriptConfig] = field(default_factory=list)
    global_parameters: Dict[str, Any] = field(default_factory=dict)

# --- Main Configuration Manager Class ---

class ConfigManager:
    """
    Handles loading, saving, and managing all project configurations and templates.
    Provides a clean API for the main application to interact with the file system.
    """
    
    def __init__(self, base_dir: Optional[Path] = None):
        """Initializes the config manager and ensures necessary directories exist."""
        self.config_dir = base_dir or Path.home() / ".synapse_ide"
        self.projects_dir = self.config_dir / "projects"
        self.templates_dir = self.config_dir / "templates"
        
        self.config_dir.mkdir(exist_ok=True)
        self.projects_dir.mkdir(exist_ok=True)
        self.templates_dir.mkdir(exist_ok=True)
        
        self._create_default_templates_if_needed()

    def _create_default_templates_if_needed(self):
        """Checks if default templates exist and creates them if not."""
        if any(self.templates_dir.iterdir()):
            return
        
        print("Creating default project templates...")
        
        ping_pong_template = ProjectConfig(
            name="Ping Pong Communicator",
            description="A simple project demonstrating two scripts sending messages to each other.",
            scripts=[
                ScriptConfig(id="script_1", name="Ping", file_path="ping.py"),
                ScriptConfig(id="script_2", name="Pong", dependencies=["script_1"], file_path="pong.py")
            ]
        )
        self.save_template("ping_pong", ping_pong_template)

    def save_project(self, project_config: ProjectConfig) -> Path:
        """Saves a project configuration to a YAML file."""
        project_config.modified_at = datetime.now().isoformat()
        safe_name = project_config.name.replace(' ', '_').lower()
        file_path = self.projects_dir / f"{safe_name}.yaml"
        with open(file_path, 'w', encoding='utf-8') as f:
            yaml.dump(asdict(project_config), f, default_flow_style=False, sort_keys=False)
        return file_path

    def load_project(self, project_name: str) -> ProjectConfig:
        """Loads a project configuration from a YAML file."""
        safe_name = project_name.replace(' ', '_').lower()
        file_path = self.projects_dir / f"{safe_name}.yaml"
        if not file_path.exists():
            raise FileNotFoundError(f"Project '{project_name}' not found at {file_path}")
            
        with open(file_path, 'r', encoding='utf-8') as f:
            data = yaml.safe_load(f)
            
        data['scripts'] = [ScriptConfig(**s) for s in data.get('scripts', [])]
        return ProjectConfig(**data)

    def list_projects(self) -> List[str]:
        """Returns a list of all available project names."""
        return [p.stem.replace('_', ' ').title() for p in self.projects_dir.glob("*.yaml")]

    def save_template(self, template_name: str, project_config: ProjectConfig):
        """Saves a project configuration as a reusable template."""
        safe_name = template_name.replace(' ', '_').lower()
        file_path = self.templates_dir / f"{safe_name}.yaml"
        with open(file_path, 'w', encoding='utf-8') as f:
            yaml.dump(asdict(project_config), f, default_flow_style=False, sort_keys=False)

    def load_template(self, template_name: str) -> ProjectConfig:
        """Loads a template and returns it as a new ProjectConfig object."""
        safe_name = template_name.replace(' ', '_').lower()
        file_path = self.templates_dir / f"{safe_name}.yaml"
        if not file_path.exists():
            raise FileNotFoundError(f"Template '{template_name}' not found.")

        with open(file_path, 'r', encoding='utf-8') as f:
            data = yaml.safe_load(f)
            
        data['scripts'] = [ScriptConfig(**s) for s in data.get('scripts', [])]
        project_config = ProjectConfig(**data)
        project_config.name = f"New Project from {template_name.replace('_', ' ').title()}"
        return project_config

    def list_templates(self) -> List[str]:
        """Returns a list of all available template names."""
        return [p.stem.replace('_', ' ').title() for p in self.templates_dir.glob("*.yaml")]

    @staticmethod
    def validate_project(project_config: ProjectConfig) -> List[str]:
        """
        Validates a project for common issues like duplicate IDs or circular dependencies.
        Returns a list of error messages.
        """
        errors = []
        script_ids = [script.id for script in project_config.scripts]

        if len(script_ids) != len(set(script_ids)):
            errors.append("Error: Duplicate Script IDs found. Each script must have a unique ID.")

        graph = nx.DiGraph()
        for script in project_config.scripts:
            graph.add_node(script.id)
            for dep_id in script.dependencies:
                if dep_id not in script_ids:
                    errors.append(f"Error: Script '{script.name}' has a broken dependency on non-existent script ID '{dep_id}'.")
                else:
                    graph.add_edge(dep_id, script.id)
        
        try:
            cycles = list(nx.simple_cycles(graph))
            if cycles:
                cycle_path = " -> ".join(cycles[0]) + f" -> {cycles[0][0]}"
                errors.append(f"Error: A circular dependency was detected: {cycle_path}.")
        except Exception as e:
            errors.append(f"An unexpected error occurred during validation: {e}")
            
        return errors

    @staticmethod
    def get_execution_order(project_config: ProjectConfig) -> List[str]:
        """Performs a topological sort to get the correct script execution order."""
        graph = nx.DiGraph()
        for script in project_config.scripts:
            graph.add_node(script.id)
            for dep_id in script.dependencies:
                graph.add_edge(dep_id, script.id)
        
        if not nx.is_directed_acyclic_graph(graph):
            raise ValueError("Cannot determine execution order due to circular dependencies.")
        
        return list(nx.topological_sort(graph))

========================================
# File: C:\Users\Saem1001\Documents\GitHub\ai_detect\net\neural_ide_lite_2\synapse_ide_main.py
========================================

#!/usr/bin/env python3
"""
Synapse IDE: An advanced, script-centric IDE for building interconnected systems.
This application provides a powerful, multi-tabbed editor environment with integrated
tools for code analysis, performance monitoring, and AI-assisted development.
"""

import tkinter as tk
from tkinter import ttk, filedialog, messagebox, scrolledtext, font, simpledialog
from ttkthemes import ThemedTk
import os
import sys
import subprocess
import threading
import queue
import time
from pathlib import Path
from typing import Optional, List, Dict, Any

# Import the backend modules
from synapse_config import ConfigManager, ProjectConfig, ScriptConfig
from synapse_tools import CodeAnalyzer, AISuggestor, AutoHealer, save_api_key

# --- Constants ---
APP_NAME = "Synapse IDE"
APP_VERSION = "1.1" # Incremented version

# --- Main Application Class ---

class SynapseIDE(tk.Frame):
    """The main application window and controller."""
    def __init__(self, parent):
        super().__init__(parent)
        self.parent = parent
        self.pack(fill=tk.BOTH, expand=True)

        self.config_manager = ConfigManager()
        self.current_project: Optional[ProjectConfig] = None
        self.tabs: Dict[str, 'ScriptTab'] = {}
        self.processes: Dict[str, subprocess.Popen] = {}
        
        self.setup_ui()
        self.load_or_create_project()

    def setup_ui(self):
        """Initializes the main user interface."""
        self.style = ttk.Style()
        self.style.theme_use('clam')
        BG_COLOR, FG_COLOR, INACTIVE_BG, ACCENT_COLOR = "#2c2f33", "#ffffff", "#23272a", "#007acc"
        self.parent.configure(bg=BG_COLOR)
        # (style configurations remain the same)
        self.style.configure('.', background=BG_COLOR, foreground=FG_COLOR); self.style.configure('TFrame', background=BG_COLOR); self.style.configure('TLabel', background=BG_COLOR, foreground=FG_COLOR, font=('Segoe UI', 10)); self.style.configure('TButton', background="#40444b", foreground=FG_COLOR, borderwidth=1, padding=5); self.style.map('TButton', background=[('active', ACCENT_COLOR)]); self.style.configure('TNotebook', background=BG_COLOR, borderwidth=0); self.style.configure('TNotebook.Tab', background=INACTIVE_BG, foreground='lightgrey', padding=[10, 5], borderwidth=0); self.style.map('TNotebook.Tab', background=[('selected', ACCENT_COLOR)], foreground=[('selected', 'white')])

        main_pane = ttk.PanedWindow(self, orient=tk.HORIZONTAL)
        main_pane.pack(fill=tk.BOTH, expand=True, padx=10, pady=(5, 10))

        project_frame = ttk.Frame(main_pane, width=250)
        main_pane.add(project_frame, weight=0)
        self.editor_notebook = ttk.Notebook(main_pane)
        main_pane.add(self.editor_notebook, weight=1)
        
        self.build_menubar()

        self.project_label = ttk.Label(project_frame, text="No Project Loaded", font=('Segoe UI', 12, 'bold'), foreground=ACCENT_COLOR)
        self.project_label.pack(pady=10, padx=5, fill=tk.X)
        self.script_list = tk.Listbox(project_frame, bg=INACTIVE_BG, fg="white", selectbackground=ACCENT_COLOR, borderwidth=0, highlightthickness=0)
        self.script_list.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        self.script_list.bind("<Double-1>", self.on_script_double_click)

    def build_menubar(self):
        """Creates the main application menu, including new Project and Run menus."""
        menubar = tk.Menu(self.parent, bg="#2c2f33", fg="white", activebackground="#007acc", relief=tk.FLAT)
        self.parent.config(menu=menubar)

        # File Menu
        file_menu = tk.Menu(menubar, tearoff=0, bg="#2c2f33", fg="white")
        menubar.add_cascade(label="File", menu=file_menu)
        file_menu.add_command(label="New Project...", command=self.create_new_project)
        file_menu.add_command(label="Open Project...", command=self.open_project_dialog)
        file_menu.add_separator()
        file_menu.add_command(label="Save Project", command=self.save_project)
        file_menu.add_separator()
        file_menu.add_command(label="Exit", command=self.on_close)

        # --- NEW: Project Menu ---
        project_menu = tk.Menu(menubar, tearoff=0, bg="#2c2f33", fg="white")
        menubar.add_cascade(label="Project", menu=project_menu)
        project_menu.add_command(label="Add New Script...", command=self.add_new_script)
        project_menu.add_command(label="Validate Dependencies", command=self.validate_project_dependencies)

        # --- NEW: Run Menu ---
        run_menu = tk.Menu(menubar, tearoff=0, bg="#2c2f33", fg="white")
        menubar.add_cascade(label="Run", menu=run_menu)
        run_menu.add_command(label="Run Project (respecting dependencies)", command=self.run_project_orchestrated)
        run_menu.add_separator()
        run_menu.add_command(label="Stop All Scripts", command=self.stop_all_scripts)

        # Edit Menu
        edit_menu = tk.Menu(menubar, tearoff=0, bg="#2c2f33", fg="white")
        menubar.add_cascade(label="Edit", menu=edit_menu)
        edit_menu.add_command(label="Settings...", command=self.show_settings)

    # --- Project & Script Management ---
    
    def load_or_create_project(self):
        projects = self.config_manager.list_projects()
        if projects: self.load_project(projects[0])
        else: self.create_new_project()

    def create_new_project(self):
        name = simpledialog.askstring("New Project", "Enter a name for your new project:", parent=self.parent)
        if name:
            new_project = ProjectConfig(name=name)
            default_script = ScriptConfig(id="script_1", name="main_script", file_path=f"{name.lower()}_main.py")
            new_project.scripts.append(default_script)
            self.config_manager.save_project(new_project)
            self.load_project(name)

    def open_project_dialog(self):
        projects = self.config_manager.list_projects()
        if not projects: messagebox.showinfo("No Projects", "No projects found."); return
        name = simpledialog.askstring("Open Project", f"Available projects:\n{', '.join(projects)}\n\nEnter project name:", parent=self.parent)
        if name and name.title() in [p.title() for p in projects]: self.load_project(name)
        elif name: messagebox.showerror("Error", f"Project '{name}' not found.")

    def load_project(self, name: str):
        try:
            self.current_project = self.config_manager.load_project(name)
            self.project_label.config(text=self.current_project.name)
            for tab_id in list(self.tabs.keys()):
                self.editor_notebook.forget(self.tabs[tab_id]); self.tabs[tab_id].destroy()
            self.tabs.clear(); self.script_list.delete(0, tk.END)
            for script in self.current_project.scripts:
                self.script_list.insert(tk.END, f"📜 {script.name}")
                self.create_tab_for_script(script)
        except Exception as e: messagebox.showerror("Load Error", f"Failed to load project: {e}"); import traceback; traceback.print_exc()

    def save_project(self):
        if not self.current_project: return
        for script_id, tab in self.tabs.items():
            for i, s in enumerate(self.current_project.scripts):
                if s.id == script_id: self.current_project.scripts[i] = tab.get_config(); break
        self.config_manager.save_project(self.current_project)
        messagebox.showinfo("Success", f"Project '{self.current_project.name}' saved.")

    def add_new_script(self):
        """Handles the UI and logic for adding a new script to the project."""
        if not self.current_project: messagebox.showwarning("No Project", "Please open or create a project first."); return
        name = simpledialog.askstring("New Script", "Enter a name for the new script:", parent=self.parent)
        if name:
            script_id = f"script_{int(time.time())}"
            file_path = f"{name.lower().replace(' ', '_')}.py"
            new_script_config = ScriptConfig(id=script_id, name=name, file_path=file_path)
            self.current_project.scripts.append(new_script_config)
            self.script_list.insert(tk.END, f"📜 {name}")
            self.create_tab_for_script(new_script_config)
            self.save_project()

    def validate_project_dependencies(self):
        if not self.current_project: return
        errors = self.config_manager.validate_project(self.current_project)
        if errors: messagebox.showwarning("Dependency Validation", "Issues found:\n\n" + "\n".join(errors))
        else: messagebox.showinfo("Dependency Validation", "✅ Project dependencies are valid!")

    def on_script_double_click(self, event):
        selected_indices = self.script_list.curselection()
        if not selected_indices: return
        script_config = self.current_project.scripts[selected_indices[0]]
        if script_config.id in self.tabs: self.editor_notebook.select(self.tabs[script_config.id])
        else: self.create_tab_for_script(script_config)

    def create_tab_for_script(self, script_config: ScriptConfig):
        if script_config.id in self.tabs: self.editor_notebook.select(self.tabs[script_config.id]); return
        tab = ScriptTab(self.editor_notebook, script_config, self)
        self.tabs[script_config.id] = tab
        self.editor_notebook.add(tab, text=script_config.name)
        self.editor_notebook.select(tab)
        
    def on_tab_change(self, event): pass

    # --- Run and Orchestration ---

    def run_project_orchestrated(self):
        """Runs all scripts in the project in the correct dependency order."""
        if not self.current_project: return
        try:
            execution_order = self.config_manager.get_execution_order(self.current_project)
            threading.Thread(target=self._run_all_worker, args=(execution_order,), daemon=True).start()
        except ValueError as e:
            messagebox.showerror("Dependency Error", str(e))

    def _run_all_worker(self, execution_order: List[str]):
        """Worker thread to run scripts sequentially."""
        print(f"Running project. Execution order: {execution_order}")
        for script_id in execution_order:
            if script_id in self.tabs:
                tab = self.tabs[script_id]
                print(f"--- Running script: {tab.config.name} ---")
                # We can't call UI methods directly from a thread, so we schedule them
                self.after(0, lambda t=tab: t.run_script())
                # Wait for the process to finish before starting the next one
                while script_id in self.processes and self.processes[script_id].poll() is None:
                    time.sleep(0.5)
                # Check for errors before proceeding
                if script_id in self.processes and self.processes[script_id].returncode != 0:
                    print(f"!!! Script {tab.config.name} failed. Halting project execution. !!!")
                    messagebox.showerror("Execution Halted", f"Script '{tab.config.name}' failed with a non-zero exit code. See console for details.", parent=self)
                    return
        print("--- Project execution finished ---")
        messagebox.showinfo("Execution Complete", "All scripts in the project have finished running.", parent=self)

    def stop_all_scripts(self):
        """Stops all currently running script processes."""
        for proc in self.processes.values():
            if proc.poll() is None: proc.terminate()
        self.processes.clear()
        messagebox.showinfo("Stopped", "All running script processes have been terminated.")

    # --- Other Functions ---
    def show_settings(self):
        key = simpledialog.askstring("Settings", "Enter your OpenAI API Key (optional):", parent=self.parent)
        if key: save_api_key(key); messagebox.showinfo("Success", "API Key saved.")

    def on_close(self):
        if messagebox.askokcancel("Quit", "Do you want to exit Synapse IDE?"):
            self.stop_all_scripts()
            self.parent.destroy()

# --- ScriptTab Class ---

class ScriptTab(tk.Frame):
    def __init__(self, parent_notebook, script_config: ScriptConfig, app_controller: 'SynapseIDE'):
        super().__init__(parent_notebook)
        self.notebook = parent_notebook
        self.config = script_config
        self.controller = app_controller
        self.output_queue = queue.Queue()
        self.autonomous_thread = None

        self.setup_ui()
        self.load_script_content()
        self.after(100, self.process_output_queue)

    def get_config(self) -> ScriptConfig:
        self.config.autonomous_mode = self.autonomous_var.get()
        return self.config

    def setup_ui(self):
        self.pack(fill=tk.BOTH, expand=True)
        main_pane = ttk.PanedWindow(self, orient=tk.VERTICAL)
        main_pane.pack(fill=tk.BOTH, expand=True)

        editor_frame = ttk.Frame(main_pane)
        main_pane.add(editor_frame, weight=3)
        
        toolbar = ttk.Frame(editor_frame)
        toolbar.pack(fill=tk.X, pady=5, padx=5)
        ttk.Button(toolbar, text="▶ Run Script", command=self.run_script).pack(side=tk.LEFT)
        ttk.Button(toolbar, text="⏹ Stop", command=self.stop_script).pack(side=tk.LEFT, padx=5)

        # --- NEW: Autonomous mode checkbox ---
        self.autonomous_var = tk.BooleanVar(value=self.config.autonomous_mode)
        ttk.Checkbutton(toolbar, text="Autonomous Mode (Auto-Run & Self-Heal)", variable=self.autonomous_var).pack(side=tk.RIGHT, padx=10)

        self.editor = scrolledtext.ScrolledText(editor_frame, wrap=tk.WORD, font=("Consolas", 12), undo=True, bg="#1e1f22", fg="white", insertbackground="white")
        self.editor.pack(fill=tk.BOTH, expand=True, padx=5, pady=(0, 5))

        info_notebook = ttk.Notebook(main_pane)
        main_pane.add(info_notebook, weight=1)
        console_frame = ttk.Frame(info_notebook); info_notebook.add(console_frame, text="Console")
        self.console = scrolledtext.ScrolledText(console_frame, wrap=tk.WORD, font=("Consolas", 10), bg="#1e1f22", fg="lightgrey")
        self.console.pack(fill=tk.BOTH, expand=True); self.console.tag_config("stderr", foreground="#ff6b6b"); self.console.tag_config("stdout", foreground="lightgrey"); self.console.tag_config("info", foreground="#00aaff")
        self.analysis_frame = ttk.Frame(info_notebook); info_notebook.add(self.analysis_frame, text="Analysis & Issues")
        self.ai_frame = ttk.Frame(info_notebook); info_notebook.add(self.ai_frame, text="AI Assist ✨")
        self.build_ai_assist_tab()

    def build_ai_assist_tab(self):
        """Populates the AI Assist tab, including the new Copilot button."""
        ttk.Button(self.ai_frame, text="Analyze Code (Pylint)", command=self.analyze_code).pack(pady=10, padx=10, fill=tk.X)
        ttk.Button(self.ai_frame, text="Get OpenAI Suggestion", command=lambda: self.get_ai_suggestion(use_copilot=False)).pack(pady=5, padx=10, fill=tk.X)
        # --- NEW: Copilot Button ---
        ttk.Button(self.ai_frame, text="Get GitHub Copilot Suggestion", command=lambda: self.get_ai_suggestion(use_copilot=True)).pack(pady=5, padx=10, fill=tk.X)
        ttk.Button(self.ai_frame, text="Attempt to Auto-Heal Runtime Error", command=self.auto_heal_error).pack(pady=5, padx=10, fill=tk.X)

    def load_script_content(self):
        try:
            if not self.config.file_path: self.config.file_path = f"{self.config.name.lower().replace(' ', '_')}.py"
            p = Path(self.config.file_path)
            p.parent.mkdir(parents=True, exist_ok=True)
            if not p.exists(): p.write_text(f'# Script: {self.config.name}\n\nprint("Hello from {self.config.name}")\n', encoding='utf-8')
            self.editor.delete("1.0", tk.END); self.editor.insert(tk.END, p.read_text(encoding='utf-8'))
        except Exception as e: self.console.insert(tk.END, f"Error loading script file: {e}\n", "stderr")

    def save_script_content(self):
        if self.config.file_path:
            try: self.editor.get("1.0", tk.END)
            except Exception as e: messagebox.showerror("Save Error", f"Could not save file {self.config.file_path}:\n{e}")

    # --- Script Execution and Autonomous Mode ---

    def run_script(self):
        """Decides whether to run normally or start the autonomous loop."""
        if self.autonomous_var.get():
            self.start_autonomous_loop()
        else:
            self.run_script_once()

    def run_script_once(self):
        """Runs the script a single time as a subprocess."""
        if self.config.id in self.controller.processes and self.controller.processes[self.config.id].poll() is None:
            messagebox.showwarning("Already Running", "This script is already running."); return
        self.save_script_content(); self.console.delete("1.0", tk.END)
        try:
            process = subprocess.Popen([sys.executable, "-u", self.config.file_path], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, encoding='utf-8', errors='replace')
            self.controller.processes[self.config.id] = process
            threading.Thread(target=self.monitor_pipe, args=(process.stdout, "stdout"), daemon=True).start()
            threading.Thread(target=self.monitor_pipe, args=(process.stderr, "stderr"), daemon=True).start()
        except Exception as e: self.console.insert(tk.END, f"Failed to start script: {e}\n", "stderr")

    def run_script_and_wait(self) -> (str, str):
        """Runs the script synchronously and returns its output and error streams."""
        self.save_script_content()
        try:
            result = subprocess.run([sys.executable, self.config.file_path], capture_output=True, text=True, encoding='utf-8', errors='replace')
            return result.stdout, result.stderr
        except Exception as e:
            return "", f"Failed to execute script for autonomous mode: {e}"

    def start_autonomous_loop(self):
        """Starts the self-healing autonomous loop in a separate thread."""
        if self.autonomous_thread and self.autonomous_thread.is_alive():
            messagebox.showwarning("Already Running", "Autonomous mode is already active for this script."); return
        self.console.delete("1.0", tk.END)
        self.console_insert("--- Starting Autonomous Mode ---\n", "info")
        self.autonomous_thread = threading.Thread(target=self._autonomous_worker, daemon=True)
        self.autonomous_thread.start()

    def _autonomous_worker(self):
        """The worker thread that runs the self-healing loop."""
        max_attempts = 5
        for attempt in range(max_attempts):
            if not self.autonomous_var.get():
                self.console_insert("Autonomous mode halted by user.\n", "info"); return

            self.console_insert(f"\n[Attempt {attempt + 1}/{max_attempts}] Running script...\n", "info")
            stdout, stderr = self.run_script_and_wait()

            if stdout: self.console_insert(stdout, "stdout")
            if stderr: self.console_insert(stderr, "stderr")

            if stderr:
                self.console_insert("Error detected. Attempting self-heal...\n", "info")
                healer = AutoHealer(self.config.file_path)
                if not healer.is_ready():
                    self.console_insert("Cannot heal: OpenAI key not configured.\n", "stderr"); break
                
                code = self.editor.get("1.0", tk.END)
                context = healer.research_error_online(stderr)
                fix = healer.propose_fix(code, stderr, context)

                if "Auto-Heal Error" in fix or "AI could not generate a fix" in fix:
                    self.console_insert(f"AI failed to generate a fix. Halting.\n{fix}\n", "stderr"); break
                
                self.console_insert("AI proposed a fix. Applying and re-running...\n", "info")
                self.after(0, self.set_editor_content, fix) # Schedule UI update
                self.save_script_content()
                time.sleep(1) # Give a moment before the next run
            else:
                self.console_insert("--- Script ran successfully. Autonomous mode complete. ---\n", "info"); break
        else:
            self.console_insert(f"--- Reached max {max_attempts} attempts. Halting autonomous mode. ---\n", "info")
        
        self.after(0, self.autonomous_var.set, False) # Turn off the checkbox in the UI

    def stop_script(self):
        self.autonomous_var.set(False) # Stop autonomous loop if it's running
        if self.config.id in self.controller.processes:
            proc = self.controller.processes[self.config.id]
            if proc.poll() is None:
                proc.terminate()
                self.console.insert(tk.END, "\n--- Script terminated by user ---\n")
            del self.controller.processes[self.config.id]

    def monitor_pipe(self, pipe, tag):
        try:
            for line in iter(pipe.readline, ''): self.output_queue.put((line, tag))
        finally: pipe.close()

    def process_output_queue(self):
        try:
            while not self.output_queue.empty():
                line, tag = self.output_queue.get_nowait()
                self.console.insert(tk.END, line, tag)
                self.console.see(tk.END)
        finally: self.after(100, self.process_output_queue)
    
    # --- UI Updaters ---

    def console_insert(self, text, tag):
        """Thread-safe way to insert text into the console."""
        self.output_queue.put((text, tag))

    def set_editor_content(self, content):
        """Thread-safe way to set the editor's content."""
        self.editor.delete("1.0", tk.END)
        self.editor.insert("1.0", content)

    # --- AI and Analysis Methods ---

    def analyze_code(self):
        self.save_script_content()
        analyzer = CodeAnalyzer(self.editor.get("1.0", tk.END))
        results = analyzer.analyze()
        for widget in self.analysis_frame.winfo_children(): widget.destroy()
        ttk.Label(self.analysis_frame, text=f"Analysis Summary: {results['summary']}").pack(anchor='w', padx=10, pady=5)
        if results['issues']:
            tree = ttk.Treeview(self.analysis_frame, columns=('line', 'code', 'message'), show='headings')
            tree.heading('line', text='Line'); tree.heading('code', text='Code'); tree.heading('message', text='Message')
            tree.column('line', width=50, anchor='center'); tree.column('code', width=80, anchor='center')
            for issue in results['issues']: tree.insert('', tk.END, values=(issue['line'], issue['type_code'], issue['message']))
            tree.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)

    def get_ai_suggestion(self, use_copilot=False):
        """Gets and displays an AI-powered code suggestion from either OpenAI or Copilot."""
        self.save_script_content()
        code = self.editor.get("1.0", tk.END)
        suggester = AISuggestor()
        
        provider_name = "GitHub Copilot" if use_copilot else "OpenAI"
        self.console_insert(f"Requesting suggestion from {provider_name}...\n", "info")

        if use_copilot:
            # The tools file doesn't have a separate copilot function, so we'll just note it
            # In a real implementation, you would call a different method here.
            suggestion = suggester.get_suggestion(code, []) # Placeholder
            self.console_insert("Note: Copilot integration is a placeholder. Using standard OpenAI suggestion.\n", "info")
        else:
            if not suggester.is_ready(): messagebox.showwarning("AI Not Configured", "Please set your OpenAI API key."); return
            suggestion = suggester.get_suggestion(code, [])

        win = tk.Toplevel(self); win.title(f"{provider_name} Suggestion")
        text_widget = scrolledtext.ScrolledText(win, wrap=tk.WORD, font=("Consolas", 12))
        text_widget.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        text_widget.insert(tk.END, suggestion)
        ttk.Button(win, text="Apply Suggestion", command=lambda: [self.set_editor_content(suggestion), win.destroy()]).pack(pady=10)

    def auto_heal_error(self):
        self.save_script_content()
        healer = AutoHealer(self.config.file_path)
        if not healer.is_ready(): messagebox.showwarning("AI Not Configured", "Auto-Heal requires an OpenAI API key."); return
        stdout, stderr = healer.diagnose_runtime_error()
        if not stderr: messagebox.showinfo("No Error", "Script ran without any runtime errors."); return
        self.console_insert(f"--- Runtime Error ---\n{stderr}\n--- Starting Auto-Heal ---\n", "stderr")
        context = healer.research_error_online(stderr)
        code = self.editor.get("1.0", tk.END)
        fix = healer.propose_fix(code, stderr, context)
        if messagebox.askyesno("Apply Fix?", f"AI proposes the following fix. Apply it?\n\n---\n{fix[:500]}...\n---"):
            self.set_editor_content(fix); self.save_script_content()
            messagebox.showinfo("Fix Applied", "The fix has been applied. Please try running again.")

# --- Main Execution ---

def main():
    root = ThemedTk(theme="clam")
    root.title(APP_NAME)
    root.geometry("1400x900")
    ide_app = SynapseIDE(root)
    root.protocol("WM_DELETE_WINDOW", ide_app.on_close)
    root.mainloop()

if __name__ == '__main__':
    main()

========================================
# File: C:\Users\Saem1001\Documents\GitHub\ai_detect\net\neural_ide_lite_2\synapse_tools.py
========================================

"""
Synapse Tools: A consolidated backend for analysis, AI assistance, and auto-healing.
This module provides the core logic for the IDE's advanced features, offering a
clean interface for the main application to use.
"""

import subprocess
import os
import sys
import json
import requests
from bs4 import BeautifulSoup
from openai import OpenAI

# --- Configuration for API Keys ---
# The API key will be stored in a file within the app's config directory for persistence.
CONFIG_DIR = os.path.join(os.path.expanduser("~"), ".synapse_ide")
API_KEY_FILE = os.path.join(CONFIG_DIR, "openai.key")

def save_api_key(api_key: str):
    """Saves the OpenAI API key to a local file for persistence."""
    os.makedirs(os.path.dirname(API_KEY_FILE), exist_ok=True)
    with open(API_KEY_FILE, 'w') as f:
        f.write(api_key)

def load_api_key() -> str | None:
    """Loads the OpenAI API key from the local file."""
    if os.path.exists(API_KEY_FILE):
        with open(API_KEY_FILE, 'r') as f:
            return f.read().strip()
    return os.getenv("OPENAI_API_KEY") # Fallback to environment variable

# --- Code Analysis ---

class CodeAnalyzer:
    """
    Analyzes Python code using Pylint to find errors, warnings, and style issues.
    It returns structured data that's easy for the UI to display.
    """
    def __init__(self, code_content: str):
        """Initializes with the code content, which is written to a temporary file for analysis."""
        self.temp_file_path = "temp_script_for_analysis.py"
        with open(self.temp_file_path, "w", encoding="utf-8") as f:
            f.write(code_content)

    def analyze(self) -> dict:
        """
        Runs Pylint and returns a structured dictionary of the findings.
        """
        print("Running static analysis with Pylint...")
        results = {"score": 10.0, "summary": "Excellent! No issues found.", "issues": []}
        
        try:
            from pylint.lint import Run
            from pylint.reporters.text import TextReporter
            from io import StringIO

            pylint_output = StringIO()
            reporter = TextReporter(pylint_output)
            
            # Run Pylint with a focused set of checks.
            Run([self.temp_file_path, "--errors-only", "--disable=missing-docstring"], reporter=reporter, do_exit=False)
            
            output_str = pylint_output.getvalue()
            
            # Parse Pylint output into a structured list of issues
            for line in output_str.splitlines():
                if ":" in line and any(c in line for c in "WCREF"): # Standard Pylint message codes
                    parts = line.split(':')
                    if len(parts) >= 4 and parts[1].strip().isdigit():
                        issue = {
                            "line": int(parts[1].strip()),
                            "type_code": parts[2].strip(),
                            "message": ":".join(parts[3:]).strip()
                        }
                        results["issues"].append(issue)
            
            # Update summary based on findings
            if results["issues"]:
                error_count = sum(1 for i in results["issues"] if i['type_code'].startswith('E'))
                warning_count = len(results["issues"]) - error_count
                results["summary"] = f"Found {error_count} error(s) and {warning_count} warning(s)."

        except ImportError:
            results["summary"] = "Pylint not found. Please install it to enable code analysis."
        except Exception as e:
            results["summary"] = f"An unexpected error occurred during analysis: {e}"
        finally:
            if os.path.exists(self.temp_file_path):
                os.remove(self.temp_file_path)
        
        return results

# --- AI-Powered Assistance ---

class AISuggestor:
    """Provides code suggestions and improvements using OpenAI's models."""
    def __init__(self, api_key: str | None = None):
        self.api_key = api_key or load_api_key()
        self.openai_client = None
        if self.api_key:
            try:
                self.openai_client = OpenAI(api_key=self.api_key)
            except Exception as e:
                print(f"Failed to initialize OpenAI client: {e}")

    def is_ready(self) -> bool:
        """Checks if the suggestor is configured with an API key."""
        return self.openai_client is not None

    def get_suggestion(self, code: str, analysis_issues: list) -> str:
        """
        Requests a code improvement suggestion from OpenAI's GPT-4o-mini model,
        providing context about the code and any issues found by the analyzer.
        """
        if not self.is_ready():
            return "AI Suggestor is not configured. Please provide an OpenAI API key in the settings."

        issue_summary = "\n".join([f"- Line {i['line']}: {i['message']} ({i['type_code']})" for i in analysis_issues])
        prompt = f"""
        You are an expert Python programming assistant. Your task is to fix and improve the following code snippet from an IDE.

        Please adhere to these rules:
        1. Correct the specific issues listed below.
        2. Improve the code's readability and efficiency, following PEP 8 standards.
        3. Add comments only where the logic is complex or non-obvious.
        4. Return ONLY the complete, corrected Python code. Do not include any explanations, markdown, or other text.

        --- START OF CODE ---
        {code}
        --- END OF CODE ---

        --- ISSUES FOUND ---
        {issue_summary if issue_summary else "No specific issues found, but please review for general improvements."}
        --- END OF ISSUES ---
        """
        
        try:
            print("Sending request to OpenAI for code suggestion...")
            response = self.openai_client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[{"role": "user", "content": prompt}]
            )
            suggestion = response.choices[0].message.content.strip()
            # Clean up the response to ensure it's just code
            if suggestion.startswith("```python"):
                suggestion = suggestion.split("```python\n", 1)[1].rsplit("\n```", 1)[0]
            return suggestion
        
        except Exception as e:
            return f"# AI Error: Could not get a suggestion.\n# Reason: {e}"

# --- Auto-Healing for Runtime Errors ---

class AutoHealer:
    """Diagnoses and proposes fixes for runtime errors by combining execution analysis, web research, and AI."""
    def __init__(self, file_path: str, api_key: str | None = None):
        self.file_path = file_path
        self.api_key = api_key or load_api_key()
        self.openai_client = OpenAI(api_key=self.api_key) if self.api_key else None

    def is_ready(self) -> bool:
        """Checks if the healer is configured with an API key."""
        return self.openai_client is not None

    def diagnose_runtime_error(self) -> tuple[str | None, str | None]:
        """Runs the script to capture stdout and, more importantly, any runtime errors (stderr)."""
        print(f"Diagnosing runtime error for: {self.file_path}")
        try:
            result = subprocess.run(
                [sys.executable, self.file_path],
                capture_output=True, text=True, check=False, encoding='utf-8'
            )
            return result.stdout, result.stderr
        except FileNotFoundError:
            return None, f"Healing Error: The script at {self.file_path} was not found."
        except Exception as e:
            return None, f"Healing Error: A system error occurred while running the script: {e}"

    def research_error_online(self, error_message: str) -> str:
        """Performs a web search for the error message, focusing on Stack Overflow for context."""
        if not error_message: return "No error message to research."

        # Extract the most descriptive line from the traceback for a better search query
        last_line = error_message.strip().split('\n')[-1]
        query = f"site:stackoverflow.com python {last_line}"
        print(f"Researching online for: '{query}'")

        try:
            headers = {'User-Agent': 'Mozilla/5.0'}
            response = requests.get("https://www.google.com/search", params={'q': query}, headers=headers)
            response.raise_for_status()
            soup = BeautifulSoup(response.text, 'html.parser')
            link_tag = soup.find('a', href=lambda href: href and "[stackoverflow.com/questions](https://stackoverflow.com/questions)" in href)
            if not link_tag: return "Could not find a relevant Stack Overflow page."

            url = link_tag['href'].split('&')[0].replace('/url?q=', '')
            print(f"Found potential solution: {url}")
            return f"Context found at: {url}" # For now, just return the URL, the AI can use the error message primarily.
        except requests.exceptions.RequestException as e:
            return f"Web search failed: {e}"

    def propose_fix(self, original_code: str, error_message: str, research_context: str) -> str:
        """Uses OpenAI to synthesize a fix based on the code, error, and online research."""
        if not self.is_ready():
            return "# Auto-Heal Error: AI is not configured. Please set your OpenAI API key."

        prompt = f"""
        You are an automated Python debugging assistant. Your task is to fix a script that failed with a runtime error.

        Here is the original code that caused the error:
        ---
        {original_code}
        ---

        When executed, it produced this error traceback:
        ---
        {error_message}
        ---

        An automated web search found this potentially related context:
        ---
        {research_context}
        ---

        Based on all this information, please generate the complete, corrected Python code.
        Your output must ONLY be the Python code itself, without any extra explanations or markdown formatting.
        """
        print("Generating AI-powered fix for runtime error...")
        try:
            response = self.openai_client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[{"role": "user", "content": prompt}]
            )
            fixed_code = response.choices[0].message.content.strip()
            if fixed_code.startswith("```python"):
                fixed_code = fixed_code.split("```python\n", 1)[1].rsplit("\n```", 1)[0]
            return fixed_code
        except Exception as e:
            return f"# Auto-Heal Error: The AI could not generate a fix.\n# Reason: {e}"
