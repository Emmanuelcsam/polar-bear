
========================================
# File: /home/jarvis/Documents/GitHub/WhatNowAI/app.py
========================================

"""
WhatNowAI Flask Application

A multi-step onboarding application that helps users determine their next steps
based on their location, interests, and social media presence.
"""
import logging.config
from flask import Flask

from routes import main_bp
from config.settings import FLASK_CONFIG, LOGGING_CONFIG, AUDIO_DIR, check_api_keys
from services.tts_service import TTSService

# Configure logging
logging.config.dictConfig(LOGGING_CONFIG)
logger = logging.getLogger(__name__)


def create_app() -> Flask:
    """
    Application factory function
    
    Returns:
        Configured Flask application instance
    """
    app = Flask(__name__)
    
    # Register blueprints
    app.register_blueprint(main_bp)
    
    # Initialize services
    tts_service = TTSService(str(AUDIO_DIR))
    
    # Cleanup old audio files on startup
    try:
        tts_service.cleanup_old_audio()
        logger.info("Audio cleanup completed")
    except Exception as e:
        logger.warning(f"Audio cleanup failed: {e}")
    
    logger.info("WhatNowAI application initialized successfully")
    return app


def main():
    """Main entry point"""
    # Check API keys on startup
    check_api_keys()
    
    app = create_app()
    
    logger.info(f"Starting WhatNowAI on {FLASK_CONFIG['HOST']}:{FLASK_CONFIG['PORT']}")
    app.run(
        debug=FLASK_CONFIG['DEBUG'],
        host=FLASK_CONFIG['HOST'],
        port=FLASK_CONFIG['PORT']
    )


if __name__ == '__main__':
    main()

========================================
# File: /home/jarvis/Documents/GitHub/WhatNowAI/test_location_data.py
========================================


========================================
# File: /home/jarvis/Documents/GitHub/WhatNowAI/test_secrets.py
========================================

#!/usr/bin/env python3
"""
Test script to verify API keys are being loaded correctly from secrets.txt
"""

import sys
from pathlib import Path

# Add the project root to the path
project_root = Path(__file__).parent
sys.path.insert(0, str(project_root))

from config.settings import (
    TICKETMASTER_API_KEY, 
    OPENAI_API_KEY, 
    check_api_keys,
    _secrets
)

def test_secrets_loading():
    """Test that secrets are being loaded correctly"""
    print("ðŸ§ª Testing Secrets Loading")
    print("=" * 40)
    
    print(f"Raw secrets loaded: {list(_secrets.keys())}")
    print(f"Secrets content (safe): {[(k, v[:10] + '...' if len(v) > 10 else v) for k, v in _secrets.items()]}")
    
    print(f"\nTicketmaster API Key: {'SET' if TICKETMASTER_API_KEY else 'NOT SET'}")
    if TICKETMASTER_API_KEY:
        print(f"Key preview: {TICKETMASTER_API_KEY[:10]}...")
        print(f"Key length: {len(TICKETMASTER_API_KEY)}")
    
    print(f"\nOpenAI API Key: {'SET' if OPENAI_API_KEY else 'NOT SET'}")
    if OPENAI_API_KEY:
        print(f"Key preview: {OPENAI_API_KEY[:10]}...")
        print(f"Key length: {len(OPENAI_API_KEY)}")
    
    print("\n" + "=" * 40)
    check_api_keys()

if __name__ == "__main__":
    test_secrets_loading()

========================================
# File: /home/jarvis/Documents/GitHub/WhatNowAI/routes.py
========================================

"""
Flask application routes
"""
from flask import Blueprint, render_template, request, jsonify, abort, send_file
import logging
import time
from typing import Dict, Any

from services.tts_service import TTSService, get_introduction_text, INTRODUCTION_TEXTS
from services.geocoding_service import GeocodingService
from services.ticketmaster_service import TicketmasterService
from services.mapping_service import MappingService
from utils.helpers import validate_coordinates, generate_response_text
from config.settings import (AUDIO_DIR, DEFAULT_TTS_VOICE, TICKETMASTER_API_KEY, 
                           TICKETMASTER_CONFIG, MAP_CONFIG)
from searchmethods.background_search import UserProfile, perform_background_search

logger = logging.getLogger(__name__)

# Create blueprint
main_bp = Blueprint('main', __name__)

# Initialize services
tts_service = TTSService(str(AUDIO_DIR), DEFAULT_TTS_VOICE)
geocoding_service = GeocodingService()
ticketmaster_service = TicketmasterService(TICKETMASTER_API_KEY, TICKETMASTER_CONFIG)
mapping_service = MappingService(MAP_CONFIG)


@main_bp.route('/')
def home():
    """Render the homepage with the form"""
    return render_template('home.html')


@main_bp.route('/tts/introduction/<step>', methods=['POST'])
def generate_introduction_tts(step: str):
    """Generate TTS for introduction steps"""
    try:
        # Get any location data from request for context
        data = request.get_json() if request.is_json else {}
        location_data = data.get('location')
        
        # Generate dynamic text based on time and location
        text = get_introduction_text(step, location_data)
        
        # Fallback to static text if dynamic generation fails
        if not text:
            text = INTRODUCTION_TEXTS.get(step)
            
        if not text:
            return jsonify({
                'success': False,
                'message': 'Invalid introduction step'
            }), 400
        
        audio_id, audio_path = tts_service.generate_audio_sync(text)
        
        if audio_id:
            return jsonify({
                'success': True,
                'audio_id': audio_id,
                'text': text
            })
        else:
            return jsonify({
                'success': False,
                'message': 'Failed to generate audio'
            }), 500
            
    except Exception as e:
        logger.error(f"Error generating introduction TTS: {e}")
        return jsonify({
            'success': False,
            'message': 'An error occurred while generating audio'
        }), 500


@main_bp.route('/submit', methods=['POST'])
def submit_info():
    """Handle form submission with user's name and activity"""
    try:
        data = request.get_json()
        name = data.get('name', '').strip()
        activity = data.get('activity', '').strip()
        social = data.get('social', {})
        
        if not name or not activity:
            return jsonify({
                'success': False,
                'message': 'Please provide both your name and what you want to do.'
            }), 400
        
        # Process the user input - start background processing
        response_message = f"Hello {name}! I'm processing your request to {activity}. Please wait while I work on this..."
        
        return jsonify({
            'success': True,
            'message': response_message,
            'name': name,
            'activity': activity,
            'social': social,
            'processing': True
        })
    
    except Exception as e:
        logger.error(f"Error in submit_info: {e}")
        return jsonify({
            'success': False,
            'message': 'An error occurred while processing your request.'
        }), 500


@main_bp.route('/chat', methods=['POST'])
def chat():
    """Handle chat messages"""
    try:
        data = request.get_json()
        message = data.get('message', '').strip()
        
        if not message:
            return jsonify({
                'success': False,
                'message': 'Please provide a message.'
            }), 400
        
        # Simple response logic (you can enhance this with AI)
        response = f"I received your message: '{message}'. How can I help you further?"
        
        return jsonify({
            'success': True,
            'response': response
        })
    
    except Exception as e:
        logger.error(f"Error in chat: {e}")
        return jsonify({
            'success': False,
            'message': 'An error occurred while processing your message.'
        }), 500


@main_bp.route('/process', methods=['POST'])
def process_request():
    """Handle background processing of user request"""
    try:
        data = request.get_json()
        name = data.get('name', '').strip()
        activity = data.get('activity', '').strip()
        location_data = data.get('location', {})
        social_data = data.get('social', {})
        
        if not name or not activity:
            return jsonify({
                'success': False,
                'message': 'Missing name or activity information.'
            }), 400
        
        # Perform background search
        logger.info(f"Starting background search for user: {name}")
        
        # Create user profile for search
        user_profile = UserProfile(
            name=name,
            location=location_data.get('city', '') + ', ' + location_data.get('country', ''),
            social_handles={
                'twitter': social_data.get('twitter', ''),
                'instagram': social_data.get('instagram', ''),
                'github': social_data.get('github', ''),
                'linkedin': social_data.get('linkedin', ''),
                'tiktok': social_data.get('tiktok', ''),
                'youtube': social_data.get('youtube', '')
            },
            activity=activity
        )
        
        # Perform background search (this may take some time)
        search_results = None
        search_summaries = None
        
        try:
            search_data = perform_background_search(user_profile)
            search_results = search_data.get('raw_results', {})
            search_summaries = search_data.get('summaries', {})
            logger.info(f"Background search completed. Found {search_data.get('total_results', 0)} total results")
        except Exception as search_error:
            logger.warning(f"Background search failed: {search_error}")
            search_summaries = {
                'general': 'Background search temporarily unavailable.',
                'social': 'Social media search temporarily unavailable.',
                'location': 'Location search temporarily unavailable.',
                'activity': 'Activity search temporarily unavailable.'
            }
        
        # Generate response text with search context
        result = generate_response_text(name, activity, location_data, social_data, search_summaries)
        
        return jsonify({
            'success': True,
            'result': result,
            'name': name,
            'activity': activity,
            'location': location_data,
            'social': social_data,
            'search_summaries': search_summaries,
            'total_search_results': len(search_results) if search_results else 0,
            'redirect_to_map': True,  # Signal frontend to redirect to map
            'map_url': '/map'
        })
    
    except Exception as e:
        logger.error(f"Error in process_request: {e}")
        return jsonify({
            'success': False,
            'message': 'An error occurred while processing your request.'
        }), 500


@main_bp.route('/geocode', methods=['POST'])
def reverse_geocode():
    """Reverse geocode latitude/longitude to get address information"""
    try:
        data = request.get_json()
        latitude = data.get('latitude')
        longitude = data.get('longitude')
        
        # Try to convert to float if they're strings
        try:
            if latitude is not None:
                latitude = float(latitude)
            if longitude is not None:
                longitude = float(longitude)
        except (ValueError, TypeError) as e:
            logger.error(f"Failed to convert coordinates to float in geocode: {e}")
            return jsonify({
                'success': False,
                'message': 'Invalid coordinate format. Coordinates must be numbers.'
            }), 400
        
        if not validate_coordinates(latitude, longitude):
            return jsonify({
                'success': False,
                'message': 'Invalid latitude or longitude coordinates.'
            }), 400
        
        location_info = geocoding_service.reverse_geocode(latitude, longitude)
        
        if location_info:
            return jsonify({
                'success': True,
                'location': location_info
            })
        else:
            return jsonify({
                'success': False,
                'message': 'Failed to geocode location.'
            }), 500
            
    except Exception as e:
        logger.error(f"Error in reverse_geocode: {e}")
        return jsonify({
            'success': False,
            'message': 'An error occurred while processing location.'
        }), 500


@main_bp.route('/audio/<audio_id>')
def serve_audio(audio_id: str):
    """Serve generated audio files"""
    try:
        if not tts_service.audio_exists(audio_id):
            abort(404)
        
        audio_path = tts_service.get_audio_path(audio_id)
        return send_file(audio_path, mimetype='audio/mpeg')
        
    except Exception as e:
        logger.error(f"Audio serve error: {e}")
        abort(500)


@main_bp.route('/map/events', methods=['POST'])
def get_map_events():
    """Get events and activities for map display"""
    try:
        data = request.get_json()
        location_data = data.get('location', {})
        user_interests = data.get('interests', [])
        user_activity = data.get('activity', '')
        
        latitude = location_data.get('latitude')
        longitude = location_data.get('longitude')
        
        # Debug logging
        logger.info(f"Received location_data: {location_data}")
        logger.info(f"Raw coordinates - lat: {latitude} (type: {type(latitude)}), lon: {longitude} (type: {type(longitude)})")
        
        # Try to convert to float if they're strings
        try:
            if latitude is not None:
                latitude = float(latitude)
            if longitude is not None:
                longitude = float(longitude)
        except (ValueError, TypeError) as e:
            logger.error(f"Failed to convert coordinates to float: {e}")
            return jsonify({
                'success': False,
                'message': 'Invalid coordinate format. Coordinates must be numbers.'
            }), 400
        
        if not validate_coordinates(latitude, longitude):
            logger.error(f"Got invalid coordinates: {latitude}, {longitude}")
            return jsonify({
                'success': False,
                'message': 'Invalid location coordinates. Latitude must be between -90 and 90, longitude between -180 and 180.'
            }), 400
        
        # Clear previous markers
        mapping_service.clear_markers()
        
        # Get events from Ticketmaster
        logger.info(f"Searching Ticketmaster events for location: {latitude}, {longitude}")
        
        try:
            ticketmaster_events = ticketmaster_service.search_events(
                location=location_data,
                user_interests=user_interests,
                user_activity=user_activity
            )
            
            if ticketmaster_events:
                mapping_service.add_ticketmaster_events(ticketmaster_events)
                logger.info(f"Added {len(ticketmaster_events)} Ticketmaster events to map")
            else:
                logger.info("No Ticketmaster events found")
                
        except Exception as tm_error:
            logger.warning(f"Ticketmaster search failed: {tm_error}")
        
        # TODO: Add other API integrations here
        # mapping_service.add_eventbrite_events(eventbrite_events)
        # mapping_service.add_meetup_events(meetup_events)
        
        # Get map data
        map_data = mapping_service.get_map_data(latitude, longitude)
        category_stats = mapping_service.get_category_stats()
        
        return jsonify({
            'success': True,
            'map_data': map_data,
            'category_stats': category_stats,
            'total_events': len(mapping_service.get_all_markers())
        })
        
    except Exception as e:
        logger.error(f"Error getting map events: {e}")
        return jsonify({
            'success': False,
            'message': 'An error occurred while loading events.'
        }), 500


@main_bp.route('/map/search', methods=['POST'])
def search_map_events():
    """Search events on the map"""
    try:
        data = request.get_json()
        query = data.get('query', '').strip()
        
        if not query:
            return jsonify({
                'success': False,
                'message': 'Please provide a search query.'
            }), 400
        
        # Search markers
        matching_markers = mapping_service.search_markers(query)
        
        return jsonify({
            'success': True,
            'markers': [marker.to_dict() for marker in matching_markers],
            'total_results': len(matching_markers)
        })
        
    except Exception as e:
        logger.error(f"Error searching map events: {e}")
        return jsonify({
            'success': False,
            'message': 'An error occurred while searching events.'
        }), 500


@main_bp.route('/map')
def map_view():
    """Render the map page"""
    # The map page will get user data from sessionStorage via JavaScript
    # We provide empty defaults that will be overridden by the frontend
    return render_template('map.html', 
                         name='', 
                         activity='', 
                         location={}, 
                         social={})

========================================
# File: /home/jarvis/Documents/GitHub/WhatNowAI/test_coordinate_fixes.py
========================================


========================================
# File: /home/jarvis/Documents/GitHub/WhatNowAI/demo_improved_search.py
========================================

#!/usr/bin/env python3
"""
Demo script showing the improved user-focused search functionality
"""

import sys
import os
import json
from pathlib import Path

# Add the project root to the path
project_root = Path(__file__).parent
sys.path.insert(0, str(project_root))

from searchmethods.background_search import UserProfile, perform_background_search


def demo_user_focused_search():
    """Demonstrate the user-focused search improvements"""
    
    print("ðŸŽ¯ User-Focused Search Demo")
    print("=" * 50)
    print("This demo shows how the search now focuses on:")
    print("âœ… Specific user information (not celebrities)")
    print("âœ… Local activities relevant to user interests")
    print("âœ… Multiple social media platforms")
    print("âœ… Personalized recommendations")
    print()
    
    # Test with a realistic user profile
    demo_profile = UserProfile(
        name="Alex Johnson",  # More generic name to avoid celebrity matches
        location="Austin, TX",
        social_handles={
            "github": "alexanderjohnson",
            "linkedin": "alex-johnson-dev",
            "twitter": "alexj_dev",
            "instagram": "alexj_photos",
            "youtube": "alexjtutorials"
        },
        activity="learn web development"
    )
    
    print(f"ðŸ‘¤ Demo Profile:")
    print(f"   Name: {demo_profile.name}")
    print(f"   Location: {demo_profile.location}")
    print(f"   Social Handles: {demo_profile.social_handles}")
    print(f"   Activity: {demo_profile.activity}")
    print()
    
    print("ðŸ” Starting user-focused search...")
    print("   - Filtering out celebrity/famous person results")
    print("   - Focusing on local activities and communities")
    print("   - Searching across all provided social platforms")
    print("   - Finding personalized learning resources")
    print()
    
    try:
        results = perform_background_search(demo_profile)
        
        print("âœ… Search completed!")
        print(f"ðŸ“Š Total focused results: {results.get('total_results', 0)}")
        print()
        
        # Show how results are now more targeted
        summaries = results.get('summaries', {})
        raw_results = results.get('raw_results', {})
        
        print("ðŸ“‹ Targeted Search Results:")
        print("-" * 40)
        
        categories = ['general', 'social', 'location', 'activity']
        for category in categories:
            summary = summaries.get(category, 'No results')
            result_count = len(raw_results.get(category, []))
            
            print(f"ðŸ·ï¸  {category.upper()} ({result_count} results):")
            print(f"   {summary[:150]}...")
            print()
        
        # Show some specific improvements
        print("ðŸŽ¯ Search Improvements Demonstrated:")
        print("-" * 40)
        
        general_results = raw_results.get('general', [])
        if general_results:
            print(f"âœ… General search avoided celebrity matches:")
            for i, result in enumerate(general_results[:2]):
                print(f"   {i+1}. {result.title[:60]}...")
        
        location_results = raw_results.get('location', [])
        if location_results:
            print(f"\nâœ… Location search found local activities:")
            for i, result in enumerate(location_results[:2]):
                print(f"   {i+1}. {result.title[:60]}...")
        
        activity_results = raw_results.get('activity', [])
        if activity_results:
            print(f"\nâœ… Activity search found learning resources:")
            for i, result in enumerate(activity_results[:2]):
                print(f"   {i+1}. {result.title[:60]}...")
        
        print(f"\nðŸŒŸ Key Improvements:")
        print(f"   â€¢ More relevant, user-specific results")
        print(f"   â€¢ Local activity recommendations")
        print(f"   â€¢ Educational content prioritization")
        print(f"   â€¢ Multi-platform social media coverage")
        print(f"   â€¢ Celebrity/famous person filtering")
        
    except Exception as e:
        print(f"âŒ Error during search: {str(e)}")
        import traceback
        traceback.print_exc()


if __name__ == "__main__":
    demo_user_focused_search()

========================================
# File: /home/jarvis/Documents/GitHub/WhatNowAI/searchmethods/__init__.py
========================================

"""
Search methods package for WhatNowAI
Provides background search and web scraping functionality
"""

from .background_search import (
    BackgroundSearchService,
    UserProfile,
    SearchResult,
    perform_background_search
)

__all__ = [
    'BackgroundSearchService',
    'UserProfile', 
    'SearchResult',
    'perform_background_search'
]

========================================
# File: /home/jarvis/Documents/GitHub/WhatNowAI/searchmethods/background_search.py
========================================

"""
Background search service for gathering user and location context
Uses web scraping and search engines to find relevant information
"""

import asyncio
import aiohttp
import logging
from typing import Dict, List, Optional, Any
from dataclasses import dataclass
from urllib.parse import quote_plus, urljoin, urlparse
import json
import re
from bs4 import BeautifulSoup
import time
from concurrent.futures import ThreadPoolExecutor, as_completed
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

logger = logging.getLogger(__name__)


@dataclass
class UserProfile:
    """User profile data structure"""
    name: str
    location: str = ""
    social_handles: Dict[str, str] = None
    activity: str = ""
    
    def __post_init__(self):
        if self.social_handles is None:
            self.social_handles = {}


@dataclass
class SearchResult:
    """Search result data structure"""
    source: str
    title: str
    url: str
    content: str
    relevance_score: float = 0.0
    timestamp: str = ""


class BackgroundSearchService:
    """Service for performing background searches on user information"""
    
    def __init__(self, config: Dict[str, Any] = None):
        """
        Initialize the background search service
        
        Args:
            config: Configuration dictionary with search parameters
        """
        from config.settings import SEARCH_CONFIG
        
        self.config = config or SEARCH_CONFIG
        self.session = None
        self.results_cache = {}
        
    def _setup_session(self) -> requests.Session:
        """Setup requests session with retries and proper headers"""
        session = requests.Session()
        
        # Setup retry strategy
        retry_strategy = Retry(
            total=3,
            status_forcelist=[429, 500, 502, 503, 504],
            allowed_methods=["HEAD", "GET", "OPTIONS"]  # Updated parameter name
        )
        
        adapter = HTTPAdapter(max_retries=retry_strategy)
        session.mount("http://", adapter)
        session.mount("https://", adapter)
        
        # Set headers
        session.headers.update({
            'User-Agent': self.config.get('USER_AGENT', 'WhatNowAI/1.0'),
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Accept-Encoding': 'gzip, deflate',
            'Connection': 'keep-alive',
        })
        
        return session
    
    def search_user_info(self, user_profile: UserProfile) -> Dict[str, List[SearchResult]]:
        """
        Search for information about the user focusing only on social media and local activities
        
        Args:
            user_profile: User profile containing name, location, social handles, etc.
            
        Returns:
            Dictionary of search results organized by source
        """
        logger.info(f"Starting focused search for user: {user_profile.name}")
        
        results = {
            'general': [],  # Will remain empty - no general searches
            'social': [],
            'location': [],
            'activity': []
        }
        
        if not self.session:
            self.session = self._setup_session()
        
        import time
        start_time = time.time()
        search_timeout = 10  # 10 second limit
        
        try:
            # Only search social media platforms if handles are provided
            if user_profile.social_handles:
                # Check if we still have time
                if time.time() - start_time < search_timeout:
                    social_results = self._search_social_media(user_profile.social_handles)
                    results['social'].extend(social_results)
                    logger.info(f"Found {len(social_results)} social media results")
            
            # Search location-specific information if we have time
            if user_profile.location and (time.time() - start_time < search_timeout):
                location_results = self._search_location_info(user_profile.location, user_profile.activity)
                results['location'].extend(location_results)
                logger.info(f"Found {len(location_results)} location results")
            
            # Search activity-related information if we have time
            if user_profile.activity and (time.time() - start_time < search_timeout):
                activity_results = self._search_activity_info(user_profile.activity, user_profile.location)
                results['activity'].extend(activity_results)
                logger.info(f"Found {len(activity_results)} activity results")
            
            # Log if we hit the timeout
            elapsed_time = time.time() - start_time
            if elapsed_time >= search_timeout:
                logger.warning(f"Search timeout reached ({elapsed_time:.1f}s), returning partial results")
            else:
                logger.info(f"Search completed in {elapsed_time:.1f}s")
                
        except Exception as e:
            logger.error(f"Error during focused search: {str(e)}")
        
        return results
    
    def _search_general_info(self, name: str) -> List[SearchResult]:
        """Search for specific information about this person (not celebrities)"""
        results = []
        
        # Focus on finding the actual user, not celebrities with the same name
        # Use more specific search terms to filter out famous people
        specific_queries = [
            f'"{name}" -wikipedia -celebrity -famous -actor -singer -politician',
            f'"{name}" profile personal',
            f'"{name}" professional background'
        ]
        
        # Use DuckDuckGo for privacy-focused search
        for query in specific_queries:
            encoded_query = quote_plus(query)
            search_urls = [
                f"https://duckduckgo.com/html/?q={encoded_query}",
            ]
            
            for url in search_urls:
                try:
                    response = self.session.get(url, timeout=self.config.get('TIMEOUT', 30))
                    if response.status_code == 200:
                        search_results = self._parse_search_results(response.text, 'general')
                        # Filter out celebrity/famous person results
                        filtered_results = [r for r in search_results if not self._is_celebrity_result(r)]
                        results.extend(filtered_results[:3])  # Limit to 3 per query
                        time.sleep(1)  # Rate limiting
                except Exception as e:
                    logger.warning(f"Failed to search {url}: {str(e)}")
                    continue
        
        return results[:self.config.get('MAX_RESULTS_PER_SOURCE', 8)]
    
    def _is_celebrity_result(self, result: SearchResult) -> bool:
        """Check if a search result is about a celebrity/famous person"""
        celebrity_keywords = [
            'wikipedia', 'celebrity', 'famous', 'actor', 'actress', 'singer', 
            'musician', 'politician', 'athlete', 'sports', 'movie', 'film',
            'album', 'song', 'tv show', 'series', 'biography', 'born in',
            'filmography', 'discography', 'awards', 'grammy', 'oscar', 'emmy'
        ]
        
        content_lower = result.content.lower()
        title_lower = result.title.lower()
        
        return any(keyword in content_lower or keyword in title_lower for keyword in celebrity_keywords)
    
    def _search_social_media(self, social_handles: Dict[str, str]) -> List[SearchResult]:
        """Search social media platforms for user information - fast and focused"""
        results = []
        start_time = time.time()
        timeout_per_platform = 2  # Max 2 seconds per platform
        
        for platform, handle in social_handles.items():
            if not handle:
                continue
            
            # Check timeout
            if time.time() - start_time > 8:  # Reserve 2 seconds for other searches
                logger.warning("Social media search timeout reached, skipping remaining platforms")
                break
                
            try:
                platform_start = time.time()
                
                if platform.lower() == 'github':
                    # GitHub API is fastest, prioritize it
                    platform_results = self._search_github_info(handle)
                    results.extend(platform_results)
                elif platform.lower() in ['twitter', 'linkedin', 'instagram', 'tiktok', 'youtube']:
                    # Quick search for other platforms
                    platform_results = self._quick_social_search(platform, handle)
                    results.extend(platform_results)
                
                # Check if this platform took too long
                if time.time() - platform_start > timeout_per_platform:
                    logger.warning(f"{platform} search took too long, skipping remaining platforms")
                    break
                    
            except Exception as e:
                logger.warning(f"Failed to search {platform} for {handle}: {str(e)}")
                continue
        
        return results[:self.config.get('MAX_RESULTS_PER_SOURCE', 3)]
    
    def _quick_social_search(self, platform: str, handle: str) -> List[SearchResult]:
        """Quick search for social media platforms with minimal processing"""
        results = []
        
        try:
            # Simple site-specific search
            query = quote_plus(f"site:{platform}.com {handle}")
            url = f"https://duckduckgo.com/html/?q={query}"
            
            response = self.session.get(url, timeout=3)  # Short timeout
            if response.status_code == 200:
                # Quick parse - just get first few results
                soup = BeautifulSoup(response.text, 'html.parser')
                result_elements = soup.find_all('div', class_='result')[:2]  # Max 2 results
                
                for element in result_elements:
                    try:
                        title_elem = element.find('a', class_='result__a')
                        snippet_elem = element.find('a', class_='result__snippet')
                        
                        if title_elem and snippet_elem:
                            result = SearchResult(
                                source='social',
                                title=title_elem.get_text(strip=True)[:100],  # Truncate for speed
                                url=title_elem.get('href', ''),
                                content=snippet_elem.get_text(strip=True)[:200],  # Truncate for speed
                                relevance_score=0.7
                            )
                            results.append(result)
                    except:
                        continue
                        
        except Exception as e:
            logger.warning(f"Quick search failed for {platform}: {str(e)}")
        
        return results
    
    def _search_location_info(self, location: str, activity: str = "") -> List[SearchResult]:
        """Fast search for location-specific activities"""
        results = []
        
        if not self.config.get('LOCAL_ACTIVITY_SEARCH', True):
            return results
        
        # Limit to most important queries for speed
        queries = [
            f"things to do {location} today",
        ]
        
        # Add one activity-specific query if provided
        if activity:
            queries.append(f"{activity} {location} classes")
        
        for query in queries[:2]:  # Max 2 queries for speed
            try:
                encoded_query = quote_plus(query)
                url = f"https://duckduckgo.com/html/?q={encoded_query}"
                
                response = self.session.get(url, timeout=self.config.get('TIMEOUT', 5))
                if response.status_code == 200:
                    search_results = self._quick_parse_results(response.text, 'location')
                    results.extend(search_results[:2])  # Max 2 per query
                    
            except Exception as e:
                logger.warning(f"Failed location search for {query}: {str(e)}")
                continue
        
        return results[:self.config.get('MAX_RESULTS_PER_SOURCE', 3)]
    
    def _search_activity_info(self, activity: str, location: str = "") -> List[SearchResult]:
        """Fast search for activity-related information"""
        results = []
        
        # Limit to essential queries for speed
        queries = [
            f"how to get started with {activity}",
        ]
        
        # Add location-specific query if provided
        if location:
            queries.append(f"{activity} beginner guide {location}")
        
        for query in queries[:2]:  # Max 2 queries for speed
            try:
                encoded_query = quote_plus(query)
                url = f"https://duckduckgo.com/html/?q={encoded_query}"
                
                response = self.session.get(url, timeout=self.config.get('TIMEOUT', 5))
                if response.status_code == 200:
                    search_results = self._quick_parse_results(response.text, 'activity')
                    results.extend(search_results[:2])  # Max 2 per query
                    
            except Exception as e:
                logger.warning(f"Failed activity search for {query}: {str(e)}")
                continue
        
        return results[:self.config.get('MAX_RESULTS_PER_SOURCE', 3)]
    
    def _quick_parse_results(self, html_content: str, source_type: str) -> List[SearchResult]:
        """Fast parsing of search results with minimal processing"""
        results = []
        
        try:
            soup = BeautifulSoup(html_content, 'html.parser')
            result_elements = soup.find_all('div', class_='result')[:3]  # Max 3 for speed
            
            for element in result_elements:
                try:
                    title_elem = element.find('a', class_='result__a')
                    snippet_elem = element.find('a', class_='result__snippet')
                    
                    if title_elem and snippet_elem:
                        result = SearchResult(
                            source=source_type,
                            title=title_elem.get_text(strip=True)[:80],  # Truncate for speed
                            url=title_elem.get('href', ''),
                            content=snippet_elem.get_text(strip=True)[:150],  # Truncate for speed
                            relevance_score=0.5
                        )
                        results.append(result)
                        
                except Exception:
                    continue
                    
        except Exception as e:
            logger.warning(f"Quick parse failed: {str(e)}")
        
        return results
    
    def _search_twitter_info(self, handle: str) -> List[SearchResult]:
        """Search for Twitter profile information (public data only)"""
        results = []
        
        # Search for public information about the Twitter handle
        query = quote_plus(f"site:twitter.com {handle}")
        url = f"https://duckduckgo.com/html/?q={query}"
        
        try:
            response = self.session.get(url, timeout=self.config.get('TIMEOUT', 30))
            if response.status_code == 200:
                results = self._parse_search_results(response.text, 'social')
        except Exception as e:
            logger.warning(f"Failed to search Twitter info for {handle}: {str(e)}")
        
        return results
    
    def _search_linkedin_info(self, handle: str) -> List[SearchResult]:
        """Search for LinkedIn profile information (public data only)"""
        results = []
        
        # Search for public LinkedIn information
        query = quote_plus(f"site:linkedin.com {handle}")
        url = f"https://duckduckgo.com/html/?q={query}"
        
        try:
            response = self.session.get(url, timeout=self.config.get('TIMEOUT', 30))
            if response.status_code == 200:
                results = self._parse_search_results(response.text, 'social')
        except Exception as e:
            logger.warning(f"Failed to search LinkedIn info for {handle}: {str(e)}")
        
        return results
    
    def _search_github_info(self, handle: str) -> List[SearchResult]:
        """Search for GitHub profile information using GitHub API"""
        results = []
        
        try:
            # Try to get public GitHub profile information
            api_url = f"https://api.github.com/users/{handle}"
            response = self.session.get(api_url, timeout=self.config.get('TIMEOUT', 30))
            
            if response.status_code == 200:
                data = response.json()
                
                # Create a search result from GitHub profile
                result = SearchResult(
                    source='github',
                    title=f"GitHub Profile: {data.get('name', handle)}",
                    url=data.get('html_url', f"https://github.com/{handle}"),
                    content=f"Bio: {data.get('bio', 'No bio available')}. "
                           f"Public repos: {data.get('public_repos', 0)}. "
                           f"Followers: {data.get('followers', 0)}. "
                           f"Location: {data.get('location', 'Not specified')}.",
                    relevance_score=0.8
                )
                results.append(result)
                
        except Exception as e:
            logger.warning(f"Failed to search GitHub info for {handle}: {str(e)}")
        
        return results
    
    def _search_instagram_info(self, handle: str) -> List[SearchResult]:
        """Search for Instagram profile information (public data only)"""
        results = []
        
        # Search for public Instagram information
        query = quote_plus(f"site:instagram.com {handle}")
        url = f"https://duckduckgo.com/html/?q={query}"
        
        try:
            response = self.session.get(url, timeout=self.config.get('TIMEOUT', 30))
            if response.status_code == 200:
                results = self._parse_search_results(response.text, 'social')
        except Exception as e:
            logger.warning(f"Failed to search Instagram info for {handle}: {str(e)}")
        
        return results
    
    def _search_tiktok_info(self, handle: str) -> List[SearchResult]:
        """Search for TikTok profile information (public data only)"""
        results = []
        
        # Search for public TikTok information
        query = quote_plus(f"site:tiktok.com @{handle}")
        url = f"https://duckduckgo.com/html/?q={query}"
        
        try:
            response = self.session.get(url, timeout=self.config.get('TIMEOUT', 30))
            if response.status_code == 200:
                results = self._parse_search_results(response.text, 'social')
        except Exception as e:
            logger.warning(f"Failed to search TikTok info for {handle}: {str(e)}")
        
        return results
    
    def _search_youtube_info(self, handle: str) -> List[SearchResult]:
        """Search for YouTube channel information (public data only)"""
        results = []
        
        # Search for public YouTube information
        queries = [
            quote_plus(f"site:youtube.com {handle}"),
            quote_plus(f"site:youtube.com/c/{handle}"),
            quote_plus(f"site:youtube.com/@{handle}")
        ]
        
        for query in queries:
            try:
                url = f"https://duckduckgo.com/html/?q={query}"
                response = self.session.get(url, timeout=self.config.get('TIMEOUT', 30))
                if response.status_code == 200:
                    search_results = self._parse_search_results(response.text, 'social')
                    results.extend(search_results[:2])
                    time.sleep(1)
            except Exception as e:
                logger.warning(f"Failed to search YouTube info for {handle}: {str(e)}")
                continue
        
        return results

    def _parse_search_results(self, html_content: str, source_type: str) -> List[SearchResult]:
        """Parse HTML search results and extract relevant information"""
        results = []
        
        try:
            soup = BeautifulSoup(html_content, 'html.parser')
            
            # Parse DuckDuckGo results
            if 'duckduckgo.com' in html_content or 'ddg' in html_content:
                results.extend(self._parse_duckduckgo_results(soup, source_type))
            # Parse Bing results
            elif 'bing.com' in html_content:
                results.extend(self._parse_bing_results(soup, source_type))
                
        except Exception as e:
            logger.warning(f"Failed to parse search results: {str(e)}")
        
        return results
    
    def _parse_duckduckgo_results(self, soup: BeautifulSoup, source_type: str) -> List[SearchResult]:
        """Parse DuckDuckGo search results"""
        results = []
        
        # Find result elements (DuckDuckGo HTML structure)
        result_elements = soup.find_all('div', class_='result')
        
        for element in result_elements[:self.config.get('MAX_RESULTS_PER_SOURCE', 10)]:
            try:
                title_elem = element.find('a', class_='result__a')
                snippet_elem = element.find('a', class_='result__snippet')
                
                if title_elem and snippet_elem:
                    title = title_elem.get_text(strip=True)
                    url = title_elem.get('href', '')
                    content = snippet_elem.get_text(strip=True)
                    
                    if title and url and content:
                        result = SearchResult(
                            source=source_type,
                            title=title,
                            url=url,
                            content=content,
                            relevance_score=0.5
                        )
                        results.append(result)
                        
            except Exception as e:
                logger.warning(f"Failed to parse individual result: {str(e)}")
                continue
        
        return results
    
    def _parse_bing_results(self, soup: BeautifulSoup, source_type: str) -> List[SearchResult]:
        """Parse Bing search results"""
        results = []
        
        # Find result elements (Bing HTML structure)
        result_elements = soup.find_all('li', class_='b_algo')
        
        for element in result_elements[:self.config.get('MAX_RESULTS_PER_SOURCE', 10)]:
            try:
                title_elem = element.find('h2')
                if title_elem:
                    title_link = title_elem.find('a')
                    if title_link:
                        title = title_link.get_text(strip=True)
                        url = title_link.get('href', '')
                        
                        # Find snippet
                        snippet_elem = element.find('p')
                        content = snippet_elem.get_text(strip=True) if snippet_elem else ""
                        
                        if title and url:
                            result = SearchResult(
                                source=source_type,
                                title=title,
                                url=url,
                                content=content,
                                relevance_score=0.5
                            )
                            results.append(result)
                            
            except Exception as e:
                logger.warning(f"Failed to parse individual Bing result: {str(e)}")
                continue
        
        return results
    
    def summarize_search_results(self, search_results: Dict[str, List[SearchResult]]) -> Dict[str, str]:
        """
        Summarize search results into a concise format - optimized for speed
        
        Args:
            search_results: Dictionary of search results by category
            
        Returns:
            Dictionary of summarized information by category
        """
        summaries = {}
        
        for category, results in search_results.items():
            if not results:
                if category == 'general':
                    summaries[category] = "General search skipped for faster personalization."
                else:
                    summaries[category] = f"No relevant {category} information found."
                continue
            
            # Quick summary generation for speed
            if category == 'social':
                platforms = set()
                for result in results:
                    if 'github' in result.url.lower():
                        platforms.add('GitHub')
                    elif 'twitter' in result.url.lower():
                        platforms.add('Twitter')
                    elif 'linkedin' in result.url.lower():
                        platforms.add('LinkedIn')
                    elif 'instagram' in result.url.lower():
                        platforms.add('Instagram')
                    elif 'tiktok' in result.url.lower():
                        platforms.add('TikTok')
                    elif 'youtube' in result.url.lower():
                        platforms.add('YouTube')
                
                if platforms:
                    platform_list = ', '.join(sorted(platforms))
                    summaries[category] = f"Found social presence on: {platform_list}. This provides context for personalized recommendations."
                else:
                    summaries[category] = f"Found {len(results)} social media references for personalization context."
            
            elif category == 'location':
                summaries[category] = f"Found {len(results)} local activities and events in your area for relevant suggestions."
            
            elif category == 'activity':
                summaries[category] = f"Found {len(results)} learning resources and guides for your activity interests."
            
            else:
                # Generic summary for any other categories
                summaries[category] = f"Found {len(results)} relevant results for enhanced personalization."
        
        return summaries
    
    def close(self):
        """Clean up resources"""
        if self.session:
            self.session.close()


# Convenience function for easy integration
def perform_background_search(user_profile: UserProfile) -> Dict[str, Any]:
    """
    Perform background search and return summarized results
    
    Args:
        user_profile: User profile information
        
    Returns:
        Dictionary containing raw results and summaries
    """
    search_service = BackgroundSearchService()
    
    try:
        # Perform the search
        raw_results = search_service.search_user_info(user_profile)
        
        # Summarize the results
        summaries = search_service.summarize_search_results(raw_results)
        
        return {
            'raw_results': raw_results,
            'summaries': summaries,
            'total_results': sum(len(results) for results in raw_results.values())
        }
        
    finally:
        search_service.close()


if __name__ == "__main__":
    # Test the search functionality
    test_profile = UserProfile(
        name="John Doe",
        location="San Francisco, CA",
        social_handles={"github": "johndoe", "twitter": "johndoe"},
        activity="learn python programming"
    )
    
    results = perform_background_search(test_profile)
    print(json.dumps(results['summaries'], indent=2))

========================================
# File: /home/jarvis/Documents/GitHub/WhatNowAI/utils/__init__.py
========================================

# Utils package

========================================
# File: /home/jarvis/Documents/GitHub/WhatNowAI/utils/helpers.py
========================================

"""
Utility functions for data processing
"""
import re
from typing import Dict, Any, Optional


def clean_text_for_tts(text: str) -> str:
    """
    Clean text for better TTS pronunciation
    
    Args:
        text: Input text to clean
        
    Returns:
        Cleaned text suitable for TTS
    """
    if not text:
        return ""
    
    # Remove markdown formatting
    text = re.sub(r'\*\*(.*?)\*\*', r'\1', text)  # Remove bold
    text = re.sub(r'\*(.*?)\*', r'\1', text)      # Remove italic
    text = re.sub(r'`(.*?)`', r'\1', text)        # Remove code
    
    # Replace multiple newlines with periods
    text = re.sub(r'\n\n+', '. ', text)
    text = re.sub(r'\n', '. ', text)
    
    # Clean up multiple periods
    text = re.sub(r'\.{2,}', '.', text)
    
    # Remove extra whitespace
    text = re.sub(r'\s+', ' ', text).strip()
    
    return text


def validate_coordinates(latitude: Optional[float], longitude: Optional[float]) -> bool:
    """
    Validate latitude and longitude coordinates
    
    Args:
        latitude: Latitude value
        longitude: Longitude value
        
    Returns:
        True if coordinates are valid, False otherwise
    """
    if latitude is None or longitude is None:
        return False
    
    try:
        lat = float(latitude)
        lon = float(longitude)
        
        # Check if coordinates are in valid range
        if -90 <= lat <= 90 and -180 <= lon <= 180:
            return True
        return False
    except (ValueError, TypeError, OverflowError):
        return False


def sanitize_social_handle(handle: str) -> str:
    """
    Sanitize social media handle
    
    Args:
        handle: Raw social media handle
        
    Returns:
        Cleaned handle without @ symbol
    """
    if not handle:
        return ""
    
    # Remove @ symbol and whitespace
    return handle.replace('@', '').strip()


def format_location_string(location_data: Dict[str, Any]) -> str:
    """
    Format location data into a readable string
    
    Args:
        location_data: Dictionary containing location information
        
    Returns:
        Formatted location string
    """
    if not location_data:
        return "Unknown location"
    
    city = location_data.get('city', 'Unknown')
    country = location_data.get('country', 'Unknown')
    zipcode = location_data.get('zipcode', 'Unknown')
    
    location_str = f"{city}, {country}"
    if zipcode != 'Unknown':
        location_str += f" ({zipcode})"
    
    return location_str


def generate_response_text(name: str, activity: str, location_data: Dict, social_data: Dict, search_summaries: Dict = None) -> str:
    """
    Generate the main response text for user request
    
    Args:
        name: User's name
        activity: User's desired activity
        location_data: Location information
        social_data: Social media information
        search_summaries: Background search summaries (optional)
        
    Returns:
        Formatted response text
    """
    location_str = format_location_string(location_data)
    
    result = f"Great news, {name}! I've analyzed your request to {activity} in {location_str}.\n\n"
    
    # Add background search context if available
    if search_summaries:
        result += "Based on my background research, here's what I found:\n\n"
        
        # Add location insights
        if search_summaries.get('location') and 'No relevant' not in search_summaries['location']:
            result += f"ðŸ“ **Location Insights**: {search_summaries['location']}\n\n"
        
        # Add activity insights
        if search_summaries.get('activity') and 'No relevant' not in search_summaries['activity']:
            result += f"ðŸŽ¯ **Activity Insights**: {search_summaries['activity']}\n\n"
        
        # Add social media insights
        if search_summaries.get('social') and 'No relevant' not in search_summaries['social']:
            result += f"ðŸ‘¥ **Social Context**: {search_summaries['social']}\n\n"
    
    # Add social media context if provided
    twitter_handle = sanitize_social_handle(social_data.get('twitter', ''))
    instagram_handle = sanitize_social_handle(social_data.get('instagram', ''))
    
    if twitter_handle or instagram_handle:
        result += f"I noticed you're active on social media"
        if twitter_handle and instagram_handle:
            result += f" (@{twitter_handle} on X, @{instagram_handle} on Instagram)"
        elif twitter_handle:
            result += f" (@{twitter_handle} on X)"
        elif instagram_handle:
            result += f" (@{instagram_handle} on Instagram)"
        result += f". This gives me additional context about your interests!\n\n"
    
    # Add personalized recommendations based on search results
    result += f"Here are my personalized recommendations for you:\n\n"
    
    # Add location-specific suggestions
    country = location_data.get('country', 'Unknown')
    result += f"1. **Start with the basics**: Break down '{activity}' into smaller, manageable steps\n" \
              f"2. **Local resources**: Research what's available in {country} to help with {activity}\n" \
              f"3. **Requirements check**: Look for any location-specific requirements or regulations\n" \
              f"4. **Timeline planning**: Set realistic milestones and deadlines\n" \
              f"5. **Community connection**: Find local groups or communities interested in {activity}\n\n"
    
    # Add social media suggestions if applicable
    if twitter_handle or instagram_handle:
        result += f"6. **Social sharing**: Document your {activity} journey to connect with like-minded people\n" \
                 f"7. **Follow experts**: Connect with relevant accounts and hashtags related to {activity}\n\n"
    
    # Add search-informed suggestions
    if search_summaries and any('No relevant' not in summary for summary in search_summaries.values()):
        result += f"8. **Research-based insights**: Based on my background research, focus on the most promising approaches mentioned above\n\n"
    
    # Add precise location info if available
    latitude = location_data.get('latitude')
    longitude = location_data.get('longitude')
    if validate_coordinates(latitude, longitude):
        result += f"ðŸ“ **Precise location advantage**: With your exact coordinates ({latitude:.4f}, {longitude:.4f}), " \
                 f"I can provide hyper-local recommendations.\n\n"
    
    result += f"ðŸ’¡ **Next steps**: Would you like me to create a detailed, step-by-step action plan " \
              f"tailored specifically to your location and background?"
    
    return result

========================================
# File: /home/jarvis/Documents/GitHub/WhatNowAI/config/settings.py
========================================

"""
Application configuration
"""
import os
from pathlib import Path

# Base directory
BASE_DIR = Path(__file__).parent.parent

def load_secrets():
    """Load API keys and secrets from secrets.txt file"""
    secrets = {}
    secrets_file = BASE_DIR / 'secrets.txt'
    
    if secrets_file.exists():
        try:
            with open(secrets_file, 'r') as f:
                for line in f:
                    line = line.strip()
                    if line and '=' in line and not line.startswith('#'):
                        key, value = line.split('=', 1)
                        secrets[key.strip()] = value.strip()
        except Exception as e:
            print(f"Warning: Could not load secrets.txt: {e}")
    
    return secrets

# Load secrets from file
_secrets = load_secrets()

# Audio configuration
AUDIO_DIR = BASE_DIR / 'static' / 'audio'
DEFAULT_TTS_VOICE = "en-US-JennyNeural"
AUDIO_CLEANUP_HOURS = 24

# Flask configuration
FLASK_CONFIG = {
    'DEBUG': True,
    'HOST': '0.0.0.0',
    'PORT': 5002
}

# Logging configuration
LOGGING_CONFIG = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'default': {
            'format': '[%(asctime)s] %(levelname)s in %(module)s: %(message)s',
        }
    },
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
            'level': 'INFO',
            'formatter': 'default',
            'stream': 'ext://sys.stdout'
        }
    },
    'root': {
        'level': 'INFO',
        'handlers': ['console']
    }
}

# Geocoding configuration
GEOCODING_CONFIG = {
    'USER_AGENT': 'WhatNowAI/1.0',
    'TIMEOUT': 10
}

# API Keys from secrets.txt file and environment variables (env vars take precedence)
ASSEMBLY_AI_KEY = os.getenv('ASSEMBLY_AI_KEY', _secrets.get('ASSEMBLY_AI_KEY', ''))
HUGGINGFACE_TOKEN = os.getenv('HUGGINGFACE_TOKEN', _secrets.get('HUGGINGFACE_TOKEN', ''))
TICKETMASTER_API_KEY = os.getenv('TICKETMASTER_API_KEY', _secrets.get('TICKETMASTER_CONSUMER_KEY', ''))
OPENAI_API_KEY = os.getenv('OPENAI_API_KEY', _secrets.get('OPENAI_API_KEY', ''))

# Debug function to check API key status
def check_api_keys():
    """Check which API keys are available"""
    keys_status = {
        'TICKETMASTER_API_KEY': 'SET' if TICKETMASTER_API_KEY else 'NOT SET',
        'OPENAI_API_KEY': 'SET' if OPENAI_API_KEY else 'NOT SET',
        'ASSEMBLY_AI_KEY': 'SET' if ASSEMBLY_AI_KEY else 'NOT SET',
        'HUGGINGFACE_TOKEN': 'SET' if HUGGINGFACE_TOKEN else 'NOT SET'
    }
    
    print("ðŸ”‘ API Keys Status:")
    for key, status in keys_status.items():
        print(f"   {key}: {status}")
        if status == 'SET' and key == 'TICKETMASTER_API_KEY':
            print(f"   {key} value: {TICKETMASTER_API_KEY[:10]}...")
    
    return keys_status

# Search configuration
SEARCH_CONFIG = {
    'MAX_RESULTS_PER_SOURCE': 3,  # Reduced for faster searches
    'TIMEOUT': 5,  # Reduced timeout per request
    'USER_AGENT': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
    'SOCIAL_PLATFORMS': ['twitter', 'linkedin', 'instagram', 'github', 'tiktok', 'youtube'],
    'MAX_CONCURRENT_REQUESTS': 3,  # Reduced for faster processing
    'FOCUS_ON_USER': True,  # Only search for the specific user, not celebrities/general info
    'LOCAL_ACTIVITY_SEARCH': True,  # Include local activity searches
    'SEARCH_TIMEOUT': 10,  # Total search timeout in seconds
    'SKIP_GENERAL_SEARCH': True  # Skip general name searches
}

# Ticketmaster API configuration
TICKETMASTER_CONFIG = {
    'BASE_URL': 'https://app.ticketmaster.com/discovery/v2',
    'SEARCH_RADIUS': 50,  # miles
    'MAX_EVENTS': 20,
    'DEFAULT_CATEGORIES': ['music', 'sports', 'arts', 'miscellaneous'],
    'TIMEOUT': 10
}

# Map configuration
MAP_CONFIG = {
    'DEFAULT_ZOOM': 12,
    'MAX_MARKERS': 50,
    'TILE_SERVER': 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
    'ATTRIBUTION': '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
}

========================================
# File: /home/jarvis/Documents/GitHub/WhatNowAI/config/__init__.py
========================================

# Config package

========================================
# File: /home/jarvis/Documents/GitHub/WhatNowAI/services/geocoding_service.py
========================================

"""
Geocoding service for location handling
"""
import requests
import logging
from typing import Dict, Optional

logger = logging.getLogger(__name__)


class GeocodingService:
    """Service for handling geocoding operations"""
    
    def __init__(self, user_agent: str = "WhatNowAI/1.0"):
        """
        Initialize geocoding service
        
        Args:
            user_agent: User agent string for API requests
        """
        self.user_agent = user_agent
        self.base_url = "https://nominatim.openstreetmap.org/reverse"
    
    def reverse_geocode(self, latitude: float, longitude: float) -> Optional[Dict]:
        """
        Reverse geocode coordinates to address information
        
        Args:
            latitude: Latitude coordinate
            longitude: Longitude coordinate
            
        Returns:
            Dictionary with location information or None if failed
        """
        try:
            params = {
                'format': 'json',
                'lat': latitude,
                'lon': longitude,
                'zoom': 18,
                'addressdetails': 1
            }
            
            headers = {
                'User-Agent': self.user_agent
            }
            
            response = requests.get(
                self.base_url, 
                params=params, 
                headers=headers, 
                timeout=10
            )
            
            if response.status_code == 200:
                geo_data = response.json()
                return self._extract_location_info(geo_data, latitude, longitude)
            else:
                logger.error(f"Geocoding API returned status {response.status_code}")
                return None
                
        except requests.RequestException as e:
            logger.error(f"Geocoding request error: {e}")
            return None
        except Exception as e:
            logger.error(f"Geocoding error: {e}")
            return None
    
    def _extract_location_info(self, geo_data: Dict, latitude: float, longitude: float) -> Dict:
        """
        Extract relevant location information from geocoding response
        
        Args:
            geo_data: Raw geocoding response
            latitude: Original latitude
            longitude: Original longitude
            
        Returns:
            Cleaned location information dictionary
        """
        address = geo_data.get('address', {})
        
        # Extract city with fallback options
        city = (address.get('city') or 
                address.get('town') or 
                address.get('village') or 
                address.get('hamlet') or 
                'Unknown')
        
        return {
            'country': address.get('country', 'Unknown'),
            'city': city,
            'zipcode': address.get('postcode', 'Unknown'),
            'latitude': latitude,
            'longitude': longitude,
            'full_address': geo_data.get('display_name', 'Unknown')
        }

========================================
# File: /home/jarvis/Documents/GitHub/WhatNowAI/services/ticketmaster_service.py
========================================

"""
Ticketmaster API service for finding events and activities
"""

import requests
import logging
from typing import Dict, List, Optional, Any
from dataclasses import dataclass
from datetime import datetime, timedelta
import json

logger = logging.getLogger(__name__)


@dataclass
class Event:
    """Event data structure"""
    id: str
    name: str
    url: str
    date: str
    time: str
    venue: str
    address: str
    city: str
    latitude: float
    longitude: float
    category: str
    subcategory: str = ""
    price_min: Optional[float] = None
    price_max: Optional[float] = None
    image_url: str = ""
    description: str = ""
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert event to dictionary for JSON serialization"""
        return {
            'id': self.id,
            'name': self.name,
            'url': self.url,
            'date': self.date,
            'time': self.time,
            'venue': self.venue,
            'address': self.address,
            'city': self.city,
            'latitude': self.latitude,
            'longitude': self.longitude,
            'category': self.category,
            'subcategory': self.subcategory,
            'price_min': self.price_min,
            'price_max': self.price_max,
            'image_url': self.image_url,
            'description': self.description
        }


class TicketmasterService:
    """Service for interacting with Ticketmaster API"""
    
    def __init__(self, api_key: str, config: Dict[str, Any]):
        """
        Initialize Ticketmaster service
        
        Args:
            api_key: Ticketmaster API key
            config: Configuration dictionary
        """
        self.api_key = api_key
        self.config = config
        self.base_url = config.get('BASE_URL', 'https://app.ticketmaster.com/discovery/v2')
        self.session = requests.Session()
        
    def search_events(self, location: Dict[str, Any], user_interests: List[str] = None, 
                     user_activity: str = "") -> List[Event]:
        """
        Search for events near a location based on user interests
        
        Args:
            location: Dictionary with latitude, longitude, city, country
            user_interests: List of user interest categories
            user_activity: What the user wants to do
            
        Returns:
            List of Event objects
        """
        if not self.api_key:
            logger.warning("Ticketmaster API key not provided")
            return []
        
        latitude = location.get('latitude')
        longitude = location.get('longitude')
        
        # Convert to float if needed
        try:
            if latitude is not None:
                latitude = float(latitude)
            if longitude is not None:
                longitude = float(longitude)
        except (ValueError, TypeError) as e:
            logger.error(f"Failed to convert coordinates to float in Ticketmaster service: {e}")
            return []
        
        if not latitude or not longitude:
            logger.warning("Location coordinates not provided or invalid")
            return []
        
        events = []
        
        try:
            # Search for events based on location
            base_events = self._search_by_location(latitude, longitude)
            events.extend(base_events)
            
            # Search for events based on user interests/activity
            if user_interests or user_activity:
                interest_events = self._search_by_interests(latitude, longitude, user_interests, user_activity)
                events.extend(interest_events)
            
            # Remove duplicates based on event ID
            unique_events = {event.id: event for event in events}
            events = list(unique_events.values())
            
            # Sort by date
            events.sort(key=lambda e: e.date)
            
            # Limit results
            max_events = self.config.get('MAX_EVENTS', 20)
            return events[:max_events]
            
        except Exception as e:
            logger.error(f"Error searching Ticketmaster events: {e}")
            return []
    
    def _search_by_location(self, latitude: float, longitude: float) -> List[Event]:
        """Search for events by location"""
        events = []
        
        params = {
            'apikey': self.api_key,
            'latlong': f"{latitude},{longitude}",
            'radius': self.config.get('SEARCH_RADIUS', 50),
            'unit': 'miles',
            'size': 20,
            'sort': 'date,asc'
        }
        
        try:
            response = self._make_request('/events.json', params)
            if response and '_embedded' in response:
                events = self._parse_events(response['_embedded']['events'])
        except Exception as e:
            logger.error(f"Error searching events by location: {e}")
        
        return events
    
    def _search_by_interests(self, latitude: float, longitude: float, 
                           interests: List[str], activity: str) -> List[Event]:
        """Search for events based on user interests and activity"""
        events = []
        
        # Map user interests to Ticketmaster categories
        category_mapping = {
            'music': 'music',
            'sports': 'sports',
            'theater': 'arts',
            'comedy': 'arts',
            'family': 'family',
            'food': 'miscellaneous',
            'fitness': 'sports',
            'technology': 'miscellaneous',
            'art': 'arts',
            'dance': 'arts'
        }
        
        # Determine search categories
        search_categories = []
        if interests:
            for interest in interests:
                category = category_mapping.get(interest.lower())
                if category and category not in search_categories:
                    search_categories.append(category)
        
        # Use AI to determine category from activity if available
        if activity and not search_categories:
            search_categories = self._categorize_activity_with_ai(activity)
        
        # If no specific categories, use default
        if not search_categories:
            search_categories = self.config.get('DEFAULT_CATEGORIES', ['music', 'sports', 'arts'])
        
        # Search for each category
        for category in search_categories:
            try:
                params = {
                    'apikey': self.api_key,
                    'latlong': f"{latitude},{longitude}",
                    'radius': self.config.get('SEARCH_RADIUS', 50),
                    'unit': 'miles',
                    'size': 10,
                    'sort': 'date,asc',
                    'classificationName': category
                }
                
                response = self._make_request('/events.json', params)
                if response and '_embedded' in response:
                    category_events = self._parse_events(response['_embedded']['events'])
                    events.extend(category_events)
                    
            except Exception as e:
                logger.error(f"Error searching events for category {category}: {e}")
                continue
        
        return events
    
    def _categorize_activity_with_ai(self, activity: str) -> List[str]:
        """Use OpenAI to categorize user activity into Ticketmaster categories"""
        try:
            from config.settings import OPENAI_API_KEY
            if not OPENAI_API_KEY:
                return ['miscellaneous']
            
            import openai
            openai.api_key = OPENAI_API_KEY
            
            prompt = f"""
            Based on the activity "{activity}", suggest the most relevant Ticketmaster event categories.
            
            Available categories:
            - music (concerts, festivals, shows)
            - sports (games, tournaments, fitness events)
            - arts (theater, comedy, exhibitions, dance)
            - family (kid-friendly events)
            - miscellaneous (other events)
            
            Return only the category names as a comma-separated list, maximum 3 categories.
            Activity: {activity}
            Categories:
            """
            
            response = openai.Completion.create(
                engine="gpt-3.5-turbo-instruct",
                prompt=prompt,
                max_tokens=50,
                temperature=0.3
            )
            
            categories_text = response.choices[0].text.strip()
            categories = [cat.strip().lower() for cat in categories_text.split(',')]
            
            # Validate categories
            valid_categories = ['music', 'sports', 'arts', 'family', 'miscellaneous']
            return [cat for cat in categories if cat in valid_categories]
            
        except Exception as e:
            logger.warning(f"AI categorization failed: {e}")
            return ['miscellaneous']
    
    def _make_request(self, endpoint: str, params: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Make a request to the Ticketmaster API"""
        url = self.base_url + endpoint
        
        try:
            response = self.session.get(
                url, 
                params=params, 
                timeout=self.config.get('TIMEOUT', 10)
            )
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.RequestException as e:
            logger.error(f"Ticketmaster API request failed: {e}")
            return None
    
    def _parse_events(self, events_data: List[Dict[str, Any]]) -> List[Event]:
        """Parse events from Ticketmaster API response"""
        events = []
        
        for event_data in events_data:
            try:
                event = self._parse_single_event(event_data)
                if event:
                    events.append(event)
            except Exception as e:
                logger.warning(f"Failed to parse event: {e}")
                continue
        
        return events
    
    def _parse_single_event(self, event_data: Dict[str, Any]) -> Optional[Event]:
        """Parse a single event from API response"""
        try:
            # Basic event info
            event_id = event_data.get('id', '')
            name = event_data.get('name', 'Unknown Event')
            url = event_data.get('url', '')
            
            # Date and time
            dates = event_data.get('dates', {})
            start = dates.get('start', {})
            date = start.get('localDate', '')
            time = start.get('localTime', '')
            
            # Venue information
            venues = event_data.get('_embedded', {}).get('venues', [])
            if not venues:
                return None
            
            venue_data = venues[0]
            venue_name = venue_data.get('name', 'Unknown Venue')
            
            # Address
            address_data = venue_data.get('address', {})
            address = address_data.get('line1', '')
            
            city_data = venue_data.get('city', {})
            city = city_data.get('name', '')
            
            # Coordinates
            location_data = venue_data.get('location', {})
            try:
                latitude = float(location_data.get('latitude', 0))
                longitude = float(location_data.get('longitude', 0))
            except (ValueError, TypeError):
                return None
            
            if not latitude or not longitude:
                return None
            
            # Category
            classifications = event_data.get('classifications', [])
            category = 'miscellaneous'
            subcategory = ''
            
            if classifications:
                segment = classifications[0].get('segment', {})
                genre = classifications[0].get('genre', {})
                category = segment.get('name', 'miscellaneous').lower()
                subcategory = genre.get('name', '')
            
            # Price information
            price_ranges = event_data.get('priceRanges', [])
            price_min = None
            price_max = None
            
            if price_ranges:
                price_min = price_ranges[0].get('min')
                price_max = price_ranges[0].get('max')
            
            # Images
            images = event_data.get('images', [])
            image_url = ''
            if images:
                # Get the largest image
                image_url = max(images, key=lambda img: img.get('width', 0) * img.get('height', 0)).get('url', '')
            
            # Description
            description = event_data.get('info', '')
            
            return Event(
                id=event_id,
                name=name,
                url=url,
                date=date,
                time=time,
                venue=venue_name,
                address=address,
                city=city,
                latitude=latitude,
                longitude=longitude,
                category=category,
                subcategory=subcategory,
                price_min=price_min,
                price_max=price_max,
                image_url=image_url,
                description=description
            )
            
        except Exception as e:
            logger.error(f"Error parsing event data: {e}")
            return None

========================================
# File: /home/jarvis/Documents/GitHub/WhatNowAI/services/mapping_service.py
========================================

"""
Mapping service for displaying events and activities on an interactive map
"""

import logging
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
import json

logger = logging.getLogger(__name__)


@dataclass
class MapMarker:
    """Map marker data structure"""
    id: str
    name: str
    latitude: float
    longitude: float
    category: str
    subcategory: str = ""
    description: str = ""
    url: str = ""
    date: str = ""
    time: str = ""
    venue: str = ""
    address: str = ""
    price_min: Optional[float] = None
    price_max: Optional[float] = None
    image_url: str = ""
    source: str = "unknown"  # ticketmaster, eventbrite, etc.
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert marker to dictionary for JSON serialization"""
        return {
            'id': self.id,
            'name': self.name,
            'latitude': self.latitude,
            'longitude': self.longitude,
            'category': self.category,
            'subcategory': self.subcategory,
            'description': self.description,
            'url': self.url,
            'date': self.date,
            'time': self.time,
            'venue': self.venue,
            'address': self.address,
            'price_min': self.price_min,
            'price_max': self.price_max,
            'image_url': self.image_url,
            'source': self.source
        }


class MappingService:
    """Service for aggregating events from multiple APIs and displaying on a map"""
    
    def __init__(self, config: Dict[str, Any]):
        """
        Initialize mapping service
        
        Args:
            config: Configuration dictionary
        """
        self.config = config
        self.markers = []
        
    def clear_markers(self):
        """Clear all markers"""
        self.markers = []
    
    def add_ticketmaster_events(self, events: List[Any]):
        """Add events from Ticketmaster to the map"""
        for event in events:
            marker = MapMarker(
                id=f"tm_{event.id}",
                name=event.name,
                latitude=event.latitude,
                longitude=event.longitude,
                category=event.category,
                subcategory=event.subcategory,
                description=event.description,
                url=event.url,
                date=event.date,
                time=event.time,
                venue=event.venue,
                address=event.address,
                price_min=event.price_min,
                price_max=event.price_max,
                image_url=event.image_url,
                source="ticketmaster"
            )
            self.markers.append(marker)
    
    def add_eventbrite_events(self, events: List[Dict[str, Any]]):
        """Add events from Eventbrite to the map (placeholder for future integration)"""
        for event in events:
            try:
                marker = MapMarker(
                    id=f"eb_{event.get('id', '')}",
                    name=event.get('name', {}).get('text', 'Unknown Event'),
                    latitude=float(event.get('venue', {}).get('latitude', 0)),
                    longitude=float(event.get('venue', {}).get('longitude', 0)),
                    category=event.get('category', 'miscellaneous'),
                    description=event.get('description', {}).get('text', ''),
                    url=event.get('url', ''),
                    date=event.get('start', {}).get('local', '').split('T')[0],
                    time=event.get('start', {}).get('local', '').split('T')[1] if 'T' in event.get('start', {}).get('local', '') else '',
                    venue=event.get('venue', {}).get('name', ''),
                    address=event.get('venue', {}).get('address', {}).get('localized_address_display', ''),
                    source="eventbrite"
                )
                
                if marker.latitude and marker.longitude:
                    self.markers.append(marker)
                    
            except Exception as e:
                logger.warning(f"Failed to parse Eventbrite event: {e}")
                continue
    
    def add_meetup_events(self, events: List[Dict[str, Any]]):
        """Add events from Meetup to the map (placeholder for future integration)"""
        for event in events:
            try:
                venue = event.get('venue', {})
                marker = MapMarker(
                    id=f"mu_{event.get('id', '')}",
                    name=event.get('name', 'Unknown Event'),
                    latitude=float(venue.get('lat', 0)),
                    longitude=float(venue.get('lon', 0)),
                    category='meetup',
                    description=event.get('description', ''),
                    url=event.get('link', ''),
                    date=event.get('local_date', ''),
                    time=event.get('local_time', ''),
                    venue=venue.get('name', ''),
                    address=venue.get('address_1', ''),
                    source="meetup"
                )
                
                if marker.latitude and marker.longitude:
                    self.markers.append(marker)
                    
            except Exception as e:
                logger.warning(f"Failed to parse Meetup event: {e}")
                continue
    
    def add_custom_locations(self, locations: List[Dict[str, Any]]):
        """Add custom locations to the map"""
        for location in locations:
            try:
                marker = MapMarker(
                    id=f"custom_{location.get('id', len(self.markers))}",
                    name=location.get('name', 'Custom Location'),
                    latitude=float(location.get('latitude', 0)),
                    longitude=float(location.get('longitude', 0)),
                    category=location.get('category', 'custom'),
                    description=location.get('description', ''),
                    url=location.get('url', ''),
                    address=location.get('address', ''),
                    source="custom"
                )
                
                if marker.latitude and marker.longitude:
                    self.markers.append(marker)
                    
            except Exception as e:
                logger.warning(f"Failed to parse custom location: {e}")
                continue
    
    def get_markers_by_category(self, category: str) -> List[MapMarker]:
        """Get all markers for a specific category"""
        return [marker for marker in self.markers if marker.category.lower() == category.lower()]
    
    def get_markers_by_source(self, source: str) -> List[MapMarker]:
        """Get all markers from a specific source"""
        return [marker for marker in self.markers if marker.source.lower() == source.lower()]
    
    def get_all_markers(self) -> List[MapMarker]:
        """Get all markers"""
        return self.markers
    
    def get_map_data(self, center_lat: float, center_lng: float) -> Dict[str, Any]:
        """
        Get map data for frontend display
        
        Args:
            center_lat: Center latitude for the map
            center_lng: Center longitude for the map
            
        Returns:
            Dictionary containing map configuration and markers
        """
        # Limit markers for performance
        max_markers = self.config.get('MAX_MARKERS', 50)
        limited_markers = self.markers[:max_markers]
        
        # Group markers by category for better organization
        categories = {}
        for marker in limited_markers:
            category = marker.category
            if category not in categories:
                categories[category] = []
            categories[category].append(marker.to_dict())
        
        return {
            'center': {
                'latitude': center_lat,
                'longitude': center_lng
            },
            'zoom': self.config.get('DEFAULT_ZOOM', 12),
            'markers': [marker.to_dict() for marker in limited_markers],
            'categories': categories,
            'total_markers': len(self.markers),
            'sources': list(set(marker.source for marker in self.markers)),
            'tile_server': self.config.get('TILE_SERVER', 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png'),
            'attribution': self.config.get('ATTRIBUTION', '&copy; OpenStreetMap contributors')
        }
    
    def get_category_stats(self) -> Dict[str, int]:
        """Get statistics about markers by category"""
        stats = {}
        for marker in self.markers:
            category = marker.category
            stats[category] = stats.get(category, 0) + 1
        return stats
    
    def filter_markers_by_distance(self, center_lat: float, center_lng: float, 
                                 max_distance_km: float) -> List[MapMarker]:
        """
        Filter markers by distance from a center point
        
        Args:
            center_lat: Center latitude
            center_lng: Center longitude
            max_distance_km: Maximum distance in kilometers
            
        Returns:
            List of markers within the specified distance
        """
        import math
        
        def haversine_distance(lat1, lon1, lat2, lon2):
            """Calculate the haversine distance between two points"""
            R = 6371  # Earth's radius in kilometers
            
            lat1_rad = math.radians(lat1)
            lon1_rad = math.radians(lon1)
            lat2_rad = math.radians(lat2)
            lon2_rad = math.radians(lon2)
            
            dlat = lat2_rad - lat1_rad
            dlon = lon2_rad - lon1_rad
            
            a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2
            c = 2 * math.asin(math.sqrt(a))
            
            return R * c
        
        filtered_markers = []
        for marker in self.markers:
            distance = haversine_distance(
                center_lat, center_lng,
                marker.latitude, marker.longitude
            )
            if distance <= max_distance_km:
                filtered_markers.append(marker)
        
        return filtered_markers
    
    def search_markers(self, query: str) -> List[MapMarker]:
        """
        Search markers by name, description, or venue
        
        Args:
            query: Search query string
            
        Returns:
            List of matching markers
        """
        query_lower = query.lower()
        matching_markers = []
        
        for marker in self.markers:
            if (query_lower in marker.name.lower() or
                query_lower in marker.description.lower() or
                query_lower in marker.venue.lower() or
                query_lower in marker.category.lower()):
                matching_markers.append(marker)
        
        return matching_markers

========================================
# File: /home/jarvis/Documents/GitHub/WhatNowAI/services/__init__.py
========================================

# Services package

========================================
# File: /home/jarvis/Documents/GitHub/WhatNowAI/services/tts_service.py
========================================

"""
Text-to-Speech service using Edge TTS
"""
import asyncio
import edge_tts
import os
import uuid
from typing import Optional, Tuple, Dict
import logging
from datetime import datetime

logger = logging.getLogger(__name__)


class TTSService:
    """Text-to-Speech service for generating audio from text"""
    
    def __init__(self, audio_dir: str, voice: str = "en-US-JennyNeural"):
        """
        Initialize TTS service
        
        Args:
            audio_dir: Directory to save audio files
            voice: Voice to use for TTS
        """
        self.audio_dir = audio_dir
        self.voice = voice
        self._ensure_audio_dir()
    
    def _ensure_audio_dir(self) -> None:
        """Ensure audio directory exists"""
        os.makedirs(self.audio_dir, exist_ok=True)
    
    async def generate_audio(self, text: str, voice: Optional[str] = None) -> Tuple[Optional[str], Optional[str]]:
        """
        Generate audio from text using edge-tts
        
        Args:
            text: Text to convert to speech
            voice: Voice to use (optional, uses default if not provided)
            
        Returns:
            Tuple of (audio_id, audio_path) or (None, None) if failed
        """
        try:
            if not text.strip():
                logger.warning("Empty text provided for TTS generation")
                return None, None
            
            # Create unique filename
            audio_id = str(uuid.uuid4())
            audio_path = os.path.join(self.audio_dir, f"{audio_id}.mp3")
            
            # Use provided voice or default
            selected_voice = voice or self.voice
            
            # Generate speech
            communicate = edge_tts.Communicate(text, selected_voice)
            await communicate.save(audio_path)
            
            logger.info(f"Audio generated successfully: {audio_id}")
            return audio_id, audio_path
            
        except Exception as e:
            logger.error(f"TTS Error: {e}")
            return None, None
    
    def generate_audio_sync(self, text: str, voice: Optional[str] = None) -> Tuple[Optional[str], Optional[str]]:
        """
        Synchronous wrapper for TTS generation
        
        Args:
            text: Text to convert to speech
            voice: Voice to use (optional)
            
        Returns:
            Tuple of (audio_id, audio_path) or (None, None) if failed
        """
        try:
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            return loop.run_until_complete(self.generate_audio(text, voice))
        except Exception as e:
            logger.error(f"TTS Sync Error: {e}")
            return None, None
        finally:
            loop.close()
    
    def get_audio_path(self, audio_id: str) -> str:
        """Get full path for audio file"""
        return os.path.join(self.audio_dir, f"{audio_id}.mp3")
    
    def audio_exists(self, audio_id: str) -> bool:
        """Check if audio file exists"""
        return os.path.exists(self.get_audio_path(audio_id))
    
    def cleanup_old_audio(self, max_age_hours: int = 24) -> None:
        """Clean up old audio files"""
        try:
            import time
            current_time = time.time()
            max_age_seconds = max_age_hours * 3600
            
            for filename in os.listdir(self.audio_dir):
                if filename.endswith('.mp3'):
                    file_path = os.path.join(self.audio_dir, filename)
                    file_age = current_time - os.path.getctime(file_path)
                    
                    if file_age > max_age_seconds:
                        try:
                            os.remove(file_path)
                            logger.info(f"Cleaned up old audio file: {filename}")
                        except OSError as e:
                            logger.warning(f"Failed to remove old audio file {filename}: {e}")
                            
        except Exception as e:
            logger.error(f"Error during audio cleanup: {e}")


def get_time_based_greeting() -> str:
    """Get time-appropriate greeting"""
    hour = datetime.now().hour
    
    if 5 <= hour < 12:
        return "Good morning"
    elif 12 <= hour < 17:
        return "Good afternoon"
    elif 17 <= hour < 22:
        return "Good evening"
    else:
        return "Hello"


def get_introduction_text(step: str, location_data: Optional[Dict] = None) -> str:
    """
    Generate dynamic introduction text based on time, location, and step
    
    Args:
        step: The onboarding step
        location_data: Optional location information
        
    Returns:
        Personalized introduction text
    """
    greeting = get_time_based_greeting()
    
    # Extract location info if available
    location_context = ""
    if location_data:
        city = location_data.get('city', '')
        country = location_data.get('country', '')
        if city and country:
            location_context = f" from {city}, {country}"
        elif country:
            location_context = f" from {country}"
    
    texts = {
        "step_name": f"Welcome to WhatNow AI! First, I'd love to know your name!",
        
        "step_activity": f"Perfect! Now tell me, what would you like to do today?",
        
        "step_location": f"Great choice! To give you the best local recommendations, I'll need to know where you are.",
        
        "processing": f"Excellent! Now I'm creating your personalized recommendations. This will just take a moment."
    }
    
    return texts.get(step, "Let's continue!")


# Backward compatibility - keep static texts as fallback
INTRODUCTION_TEXTS = {
    "step_name": "First, what's your name? You can also share social media handles for better recommendations.",
    "step_activity": "Perfect! Now tell me, what would you like to do today?",
    "step_location": "Great! To give you local recommendations, I'll need your location. You can share it or skip this step.",
    "processing": "Excellent! I'm creating your personalized action plan. Just a moment please."
}
