<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zen Text Reader Pro - Ultimate Focus & Comprehension</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #6366f1;
            --secondary: #a78bfa;
            --accent: #f472b6;
            --success: #10b981;
            --warning: #f59e0b;
            --bg-dark: #0f0f23;
            --bg-light: #1a1a2e;
            --text: #e0e0ff;
            --text-dim: #a0a0c0;
            --glass: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-dark);
            color: var(--text);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        /* Light theme */
        body.light-theme {
            --bg-dark: #f3f4f6;
            --bg-light: #ffffff;
            --text: #1f2937;
            --text-dim: #6b7280;
            --glass: rgba(0, 0, 0, 0.02);
            --glass-border: rgba(0, 0, 0, 0.1);
        }

        /* Animated background */
        .background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background: linear-gradient(135deg, var(--bg-dark) 0%, var(--bg-light) 50%, var(--bg-dark) 100%);
            transition: all 0.5s ease;
        }

        .orb {
            position: absolute;
            border-radius: 50%;
            filter: blur(80px);
            opacity: 0.4;
            animation: float 20s infinite ease-in-out;
        }

        .orb1 {
            width: 600px;
            height: 600px;
            background: radial-gradient(circle, var(--primary) 0%, transparent 70%);
            top: -200px;
            left: -200px;
            animation-delay: 0s;
        }

        .orb2 {
            width: 400px;
            height: 400px;
            background: radial-gradient(circle, var(--secondary) 0%, transparent 70%);
            bottom: -100px;
            right: -100px;
            animation-delay: 10s;
        }

        .orb3 {
            width: 300px;
            height: 300px;
            background: radial-gradient(circle, var(--accent) 0%, transparent 70%);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            animation-delay: 5s;
        }

        @keyframes float {
            0%, 100% { transform: translate(0, 0) scale(1); }
            25% { transform: translate(100px, -100px) scale(1.1); }
            50% { transform: translate(-100px, 100px) scale(0.9); }
            75% { transform: translate(50px, 50px) scale(1.05); }
        }

        /* Main container */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
            position: relative;
            z-index: 1;
        }

        /* Header */
        .header {
            text-align: center;
            margin-bottom: 3rem;
            animation: fadeInDown 1s ease-out;
        }

        .header h1 {
            font-size: 3.5rem;
            font-weight: 800;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 50%, var(--accent) 100%);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 0.5rem;
            letter-spacing: -0.02em;
        }

        .header p {
            color: var(--text-dim);
            font-size: 1.2rem;
        }

        /* Features dropdown menu */
        .features-dropdown {
            position: relative;
            display: inline-block;
            margin-bottom: 2rem;
        }

        .features-btn {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border: none;
            border-radius: 10px;
            padding: 0.75rem 1.5rem;
            color: white;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: all 0.3s ease;
        }

        .features-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(99, 102, 241, 0.4);
        }

        .features-menu {
            position: absolute;
            top: 100%;
            left: 0;
            margin-top: 0.5rem;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 15px;
            backdrop-filter: blur(20px);
            min-width: 250px;
            opacity: 0;
            transform: translateY(-10px);
            pointer-events: none;
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .features-menu.active {
            opacity: 1;
            transform: translateY(0);
            pointer-events: all;
        }

        .feature-item {
            padding: 0.75rem 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
            border-radius: 10px;
            margin: 0.25rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .feature-item:hover {
            background: rgba(99, 102, 241, 0.2);
        }

        .feature-item.active {
            background: rgba(99, 102, 241, 0.3);
        }

        .feature-icon {
            font-size: 1.2rem;
        }

        .feature-text {
            flex: 1;
        }

        .feature-shortcut {
            font-size: 0.75rem;
            color: var(--text-dim);
            font-family: monospace;
        }

        /* Stats bar */
        .stats-bar {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 15px;
            padding: 1rem;
            margin-bottom: 2rem;
            display: flex;
            gap: 2rem;
            flex-wrap: wrap;
            align-items: center;
            backdrop-filter: blur(10px);
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .stat-label {
            color: var(--text-dim);
            font-size: 0.85rem;
        }

        .stat-value {
            font-weight: 600;
            color: var(--primary);
        }

        /* File upload area */
        .upload-area {
            background: var(--glass);
            border: 2px dashed var(--glass-border);
            border-radius: 20px;
            padding: 3rem;
            text-align: center;
            margin-bottom: 2rem;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .upload-area:hover {
            border-color: var(--primary);
            background: rgba(99, 102, 241, 0.1);
            transform: translateY(-2px);
        }

        .upload-area.dragover {
            border-color: var(--accent);
            background: rgba(244, 114, 182, 0.1);
            transform: scale(1.02);
        }

        .upload-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.1); opacity: 1; }
        }

        /* Main content area */
        .content-area {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 2rem;
            margin-top: 2rem;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .content-area.active {
            opacity: 1;
        }

        /* Text display */
        .text-display {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: 2.5rem;
            backdrop-filter: blur(10px);
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
            transition: all 0.3s ease;
        }

        .text-display.fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            max-height: 100vh;
            z-index: 9999;
            border-radius: 0;
            padding: 4rem;
            background: var(--bg-dark);
        }

        .text-content {
            font-size: 1.1rem;
            line-height: 1.8;
            color: var(--text);
            white-space: pre-wrap;
            word-wrap: break-word;
            position: relative;
        }

        /* Markdown styling */
        .text-content h1, .text-content h2, .text-content h3, .text-content h4, .text-content h5, .text-content h6 {
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
            font-weight: 700;
            line-height: 1.3;
        }

        .text-content h1 { font-size: 2rem; }
        .text-content h2 { font-size: 1.75rem; }
        .text-content h3 { font-size: 1.5rem; }
        .text-content h4 { font-size: 1.25rem; }
        .text-content h5 { font-size: 1.1rem; }
        .text-content h6 { font-size: 1rem; }

        .text-content p {
            margin-bottom: 1rem;
        }

        .text-content code {
            background: var(--glass);
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.9em;
        }

        .text-content pre {
            background: var(--glass);
            padding: 1rem;
            border-radius: 8px;
            overflow-x: auto;
            margin-bottom: 1rem;
        }

        .text-content pre code {
            background: none;
            padding: 0;
        }

        .text-content blockquote {
            border-left: 4px solid var(--primary);
            padding-left: 1rem;
            margin: 1rem 0;
            color: var(--text-dim);
        }

        .text-content ul, .text-content ol {
            margin-left: 2rem;
            margin-bottom: 1rem;
        }

        .text-content li {
            margin-bottom: 0.5rem;
        }

        .text-content a {
            color: var(--primary);
            text-decoration: none;
        }

        .text-content a:hover {
            text-decoration: underline;
        }

        .text-content::selection {
            background: var(--primary);
            color: white;
        }

        /* Bionic reading mode */
        .bionic-mode .word {
            display: inline-block;
        }

        .bionic-mode .word .bold {
            font-weight: 700;
        }

        /* Focus gradient mode */
        .focus-gradient::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(to bottom, 
                rgba(0,0,0,0.7) 0%,
                transparent 20%,
                transparent 80%,
                rgba(0,0,0,0.7) 100%);
            pointer-events: none;
            z-index: 1;
        }

        /* Reading progress bar */
        .reading-progress {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: var(--glass-border);
            z-index: 9998;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .reading-progress.active {
            opacity: 1;
        }

        .reading-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            width: 0%;
            transition: width 0.3s ease;
        }

        /* Reading controls */
        .reading-controls {
            display: flex;
            gap: 1rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }

        .control-btn {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 10px;
            padding: 0.5rem 1rem;
            color: var(--text);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .control-btn:hover {
            background: rgba(99, 102, 241, 0.2);
            border-color: var(--primary);
            transform: translateY(-2px);
        }

        .control-btn.active {
            background: var(--primary);
            color: white;
        }

        /* Speed reader modal */
        .speed-reader-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        .speed-reader-modal.active {
            display: flex;
        }

        .speed-reader-content {
            text-align: center;
            color: white;
        }

        .speed-word {
            font-size: 4rem;
            font-weight: 300;
            margin-bottom: 2rem;
            letter-spacing: 0.05em;
            min-height: 5rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .speed-controls {
            display: flex;
            gap: 1rem;
            justify-content: center;
            align-items: center;
        }

        .speed-control-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .speed-control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .wpm-display {
            color: var(--primary);
            font-weight: 600;
            margin: 0 1rem;
        }

        /* Pomodoro timer */
        .pomodoro-widget {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 15px;
            padding: 1rem;
            backdrop-filter: blur(10px);
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            z-index: 100;
        }

        .pomodoro-widget.active {
            display: flex;
        }

        .pomodoro-time {
            font-size: 2rem;
            font-weight: 700;
            color: var(--primary);
            font-variant-numeric: tabular-nums;
        }

        .pomodoro-controls {
            display: flex;
            gap: 0.5rem;
        }

        /* AI Chat Panel */
        .ai-panel {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: 1.5rem;
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            height: 80vh;
            transition: all 0.3s ease;
            position: relative;
        }

        .ai-panel.fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 10000;
            border-radius: 0;
            padding: 2rem;
            background: var(--bg-dark);
            max-width: none;
        }

        .ai-fullscreen-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            padding: 0.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            color: var(--text);
            font-size: 1.2rem;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .ai-fullscreen-btn:hover {
            background: rgba(99, 102, 241, 0.2);
            border-color: var(--primary);
        }

        .ai-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--glass-border);
        }

        .ai-icon {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 1rem;
            padding-right: 0.5rem;
        }

        .message {
            margin-bottom: 1rem;
            animation: fadeInUp 0.3s ease-out;
        }

        .message.user {
            text-align: right;
        }

        .message-bubble {
            display: inline-block;
            padding: 0.75rem 1rem;
            border-radius: 15px;
            max-width: 80%;
            word-wrap: break-word;
        }

        .message.user .message-bubble {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
        }

        .message.ai .message-bubble {
            background: var(--glass);
            border: 1px solid var(--glass-border);
        }

        /* Markdown styles in AI messages */
        .message-bubble h1 { font-size: 1.5rem; margin: 0.5rem 0; font-weight: 700; }
        .message-bubble h2 { font-size: 1.3rem; margin: 0.5rem 0; font-weight: 700; }
        .message-bubble h3 { font-size: 1.15rem; margin: 0.5rem 0; font-weight: 600; }
        .message-bubble h4 { font-size: 1.05rem; margin: 0.5rem 0; font-weight: 600; }
        .message-bubble h5 { font-size: 1rem; margin: 0.5rem 0; font-weight: 600; }
        .message-bubble h6 { font-size: 0.95rem; margin: 0.5rem 0; font-weight: 600; }
        
        .message-bubble p { margin: 0.5rem 0; }
        .message-bubble ul, .message-bubble ol { margin: 0.5rem 0; padding-left: 1.5rem; }
        .message-bubble li { margin: 0.25rem 0; }
        .message-bubble blockquote { 
            border-left: 3px solid var(--primary); 
            padding-left: 1rem; 
            margin: 0.5rem 0; 
            color: var(--text-dim);
        }
        .message-bubble pre {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            padding: 1rem;
            margin: 0.5rem 0;
            overflow-x: auto;
        }
        .message-bubble code {
            background: var(--glass);
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.9em;
        }
        .message-bubble pre code {
            background: none;
            padding: 0;
        }
        .message-bubble table {
            border-collapse: collapse;
            margin: 0.5rem 0;
            width: 100%;
        }
        .message-bubble td, .message-bubble th {
            padding: 0.5rem;
            border: 1px solid var(--glass-border);
        }
        .message-bubble hr {
            border: none;
            border-top: 1px solid var(--glass-border);
            margin: 1rem 0;
        }
        .message-bubble a {
            color: var(--primary);
            text-decoration: underline;
        }
        .message-bubble a:hover {
            color: var(--secondary);
        }
        .message-bubble strong {
            font-weight: 700;
        }
        .message-bubble em {
            font-style: italic;
        }
        .message-bubble del {
            text-decoration: line-through;
            opacity: 0.7;
        }

        .chat-input-area {
            display: flex;
            gap: 0.5rem;
        }

        .chat-input {
            flex: 1;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 10px;
            padding: 0.75rem;
            color: var(--text);
            font-size: 0.95rem;
            transition: all 0.3s ease;
        }

        .chat-input:focus {
            outline: none;
            border-color: var(--primary);
            background: rgba(99, 102, 241, 0.1);
        }

        .send-btn {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border: none;
            border-radius: 10px;
            padding: 0.75rem 1.5rem;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
        }

        .send-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(99, 102, 241, 0.4);
        }

        .send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Quick actions */
        .quick-actions {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .quick-action {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            padding: 0.4rem 0.8rem;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .quick-action:hover {
            background: rgba(99, 102, 241, 0.2);
            border-color: var(--primary);
        }

        /* API Key input */
        .api-key-section {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 15px;
            padding: 1rem;
            margin-bottom: 2rem;
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .api-key-input {
            flex: 1;
            background: transparent;
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            padding: 0.5rem;
            color: var(--text);
            font-family: monospace;
            transition: all 0.3s ease;
        }

        .api-key-input:focus {
            outline: none;
            border-color: var(--primary);
            background: rgba(99, 102, 241, 0.1);
        }

        .api-key-input:valid {
            border-color: var(--success);
        }

        .api-key-input:invalid {
            border-color: var(--warning);
        }

        /* Exit fullscreen button */
        .exit-fullscreen {
            position: absolute;
            top: 2rem;
            right: 2rem;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 10px;
            padding: 0.5rem 1rem;
            color: var(--text);
            cursor: pointer;
            display: none;
            z-index: 10000;
        }

        .text-display.fullscreen .exit-fullscreen {
            display: block;
        }

        /* TTS controls */
        .tts-controls {
            position: fixed;
            bottom: 2rem;
            left: 2rem;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 15px;
            padding: 1rem;
            backdrop-filter: blur(10px);
            display: none;
            flex-direction: column;
            gap: 1rem;
            z-index: 100;
            min-width: 300px;
        }

        .tts-controls.active {
            display: flex;
        }

        .tts-main-controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .tts-rate-control {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .tts-rate-slider {
            width: 100px;
        }

        .tts-engine-selector {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            padding: 0.5rem 0;
            border-top: 1px solid var(--glass-border);
            border-bottom: 1px solid var(--glass-border);
            margin: 0.5rem 0;
        }

        .tts-engine-btn {
            flex: 1;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            padding: 0.4rem 0.8rem;
            color: var(--text);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.85rem;
        }

        .tts-engine-btn:hover {
            background: rgba(99, 102, 241, 0.2);
            border-color: var(--primary);
        }

        .tts-engine-btn.active {
            background: var(--primary);
            color: white;
        }

        .edge-tts-options {
            display: none;
            flex-direction: column;
            gap: 0.5rem;
            padding: 0.5rem 0;
        }

        .edge-tts-options.active {
            display: flex;
        }

        .edge-voice-selector {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            padding: 0.5rem;
            color: var(--text);
            font-size: 0.9rem;
            cursor: pointer;
        }

        .edge-voice-selector:focus {
            outline: none;
            border-color: var(--primary);
        }

        .edge-tts-status {
            font-size: 0.8rem;
            color: var(--text-dim);
            text-align: center;
            padding: 0.25rem;
        }

        .edge-tts-loading {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            color: var(--primary);
        }

        /* Autoscroll controls */
        .autoscroll-controls {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 15px;
            padding: 1rem;
            backdrop-filter: blur(10px);
            display: none;
            flex-direction: column;
            gap: 0.75rem;
            z-index: 100;
            min-width: 200px;
        }

        .autoscroll-controls.active {
            display: flex;
        }

        .autoscroll-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-weight: 600;
            color: var(--text);
        }

        .autoscroll-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
            color: var(--text-dim);
        }

        .autoscroll-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--warning);
            animation: pulse 2s infinite;
        }

        .autoscroll-indicator.running {
            background: var(--success);
            animation: pulse 1s infinite;
        }

        .autoscroll-speed-control {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .autoscroll-speed-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85rem;
            color: var(--text-dim);
        }

        .autoscroll-speed-value {
            color: var(--primary);
            font-weight: 600;
            font-variant-numeric: tabular-nums;
        }

        .autoscroll-slider {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: var(--glass-border);
            border-radius: 3px;
            outline: none;
            cursor: pointer;
        }

        .autoscroll-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: var(--primary);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .autoscroll-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 10px rgba(99, 102, 241, 0.5);
        }

        .autoscroll-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: var(--primary);
            border-radius: 50%;
            cursor: pointer;
            border: none;
            transition: all 0.2s ease;
        }

        .autoscroll-slider::-moz-range-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 10px rgba(99, 102, 241, 0.5);
        }

        .autoscroll-controls-buttons {
            display: flex;
            gap: 0.5rem;
        }

        .autoscroll-btn {
            flex: 1;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            padding: 0.4rem 0.8rem;
            color: var(--text);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.85rem;
            text-align: center;
        }

        .autoscroll-btn:hover {
            background: rgba(99, 102, 241, 0.2);
            border-color: var(--primary);
        }

        .autoscroll-btn.active {
            background: var(--primary);
            color: white;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--glass);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--primary);
            border-radius: 4px;
        }

        /* Animations */
        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .content-area {
                grid-template-columns: 1fr;
            }
            
            .ai-panel {
                height: 60vh;
            }
        }

        /* Loading animation */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid var(--glass-border);
            border-radius: 50%;
            border-top-color: var(--primary);
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Syntax Highlighting */
        .syntax-noun { color: #4ade80; font-weight: 500; }
        .syntax-verb { color: #60a5fa; font-weight: 500; }
        .syntax-adjective { color: #f472b6; }
        .syntax-adverb { color: #c084fc; }
        .syntax-pronoun { color: #fbbf24; }
        .syntax-preposition { color: #94a3b8; }
        .syntax-conjunction { color: #94a3b8; }
        .syntax-interjection { color: #fb923c; font-weight: 600; }
        .syntax-number { color: #34d399; font-weight: 600; }
        .syntax-punctuation { color: var(--text-dim); }
        
        /* Code highlighting */
        .syntax-code {
            background: var(--glass);
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.9em;
            border: 1px solid var(--glass-border);
        }
        
        .syntax-code-block {
            display: block;
            background: var(--glass);
            padding: 1rem;
            border-radius: 8px;
            margin: 0.5rem 0;
            font-family: monospace;
            font-size: 0.9em;
            border: 1px solid var(--glass-border);
            overflow-x: auto;
        }
        
        .syntax-python { color: #3b82f6; }
        .syntax-javascript { color: #eab308; }
        .syntax-html { color: #f97316; }
        .syntax-css { color: #8b5cf6; }
        .syntax-sql { color: #06b6d4; }
        .syntax-json { color: #10b981; }
        .syntax-keyword { color: #f472b6; font-weight: 600; }
        .syntax-string { color: #84cc16; }
        .syntax-comment { color: var(--text-dim); font-style: italic; }
        .syntax-function { color: #fbbf24; }
        .syntax-variable { color: #60a5fa; }
        .syntax-operator { color: #e11d48; }
    </style>
</head>
<body>
    <div class="background">
        <div class="orb orb1"></div>
        <div class="orb orb2"></div>
        <div class="orb orb3"></div>
    </div>

    <div class="reading-progress">
        <div class="reading-progress-bar"></div>
    </div>

    <div class="container">
        <div class="header">
            <h1>Zen Text Reader Pro</h1>
            <p>Ultimate focus, comprehension, and speed reading toolkit</p>
        </div>

        <div class="features-dropdown">
            <button class="features-btn" onclick="toggleFeaturesMenu()">
                <span>üéØ</span> Features Menu
                <span>‚ñº</span>
            </button>
            <div class="features-menu" id="featuresMenu">
                <div class="feature-item" onclick="toggleFullscreen()">
                    <span class="feature-icon">‚õ∂</span>
                    <span class="feature-text">Fullscreen Mode</span>
                    <span class="feature-shortcut">Ctrl+F</span>
                </div>
                <div class="feature-item" onclick="startSpeedReader()">
                    <span class="feature-icon">‚ö°</span>
                    <span class="feature-text">Speed Reader</span>
                    <span class="feature-shortcut">Ctrl+S</span>
                </div>
                <div class="feature-item" onclick="toggleBionicMode()">
                    <span class="feature-icon">üëÅÔ∏è</span>
                    <span class="feature-text">Bionic Reading</span>
                    <span class="feature-shortcut">Ctrl+B</span>
                </div>
                <div class="feature-item" onclick="toggleFocusGradient()">
                    <span class="feature-icon">üéØ</span>
                    <span class="feature-text">Focus Gradient</span>
                </div>
                <div class="feature-item" onclick="togglePomodoro()">
                    <span class="feature-icon">‚è±Ô∏è</span>
                    <span class="feature-text">Pomodoro Timer</span>
                    <span class="feature-shortcut">Ctrl+P</span>
                </div>
                <div class="feature-item" onclick="toggleTTS()">
                    <span class="feature-icon">üîä</span>
                    <span class="feature-text">Text to Speech</span>
                    <span class="feature-shortcut">Ctrl+L</span>
                </div>
                <div class="feature-item" onclick="toggleTheme()">
                    <span class="feature-icon">üåì</span>
                    <span class="feature-text">Toggle Theme</span>
                </div>
                <div class="feature-item" onclick="changeTextSize('increase')">
                    <span class="feature-icon">üîç</span>
                    <span class="feature-text">Increase Text Size</span>
                </div>
                <div class="feature-item" onclick="changeTextSize('decrease')">
                    <span class="feature-icon">üîç</span>
                    <span class="feature-text">Decrease Text Size</span>
                </div>
                <div class="feature-item" onclick="toggleSyntaxHighlighting()">
                    <span class="feature-icon">üé®</span>
                    <span class="feature-text">Toggle Syntax Highlighting</span>
                    <span class="feature-shortcut">Ctrl+H</span>
                </div>
                <div class="feature-item" onclick="toggleAutoscroll()">
                    <span class="feature-icon">üìú</span>
                    <span class="feature-text">Auto Scroll</span>
                    <span class="feature-shortcut">Ctrl+R</span>
                </div>
            </div>
        </div>

        <div class="stats-bar">
            <div class="stat-item">
                <span class="stat-label">Words:</span>
                <span class="stat-value" id="wordCount">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Reading Time:</span>
                <span class="stat-value" id="readingTime">0 min</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Progress:</span>
                <span class="stat-value" id="progressPercent">0%</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Session:</span>
                <span class="stat-value" id="sessionTime">00:00</span>
            </div>
        </div>

        <div class="api-key-section">
            <span>üîë</span>
            <input type="password" class="api-key-input" id="apiKey" placeholder="Enter your Gemini API Key">
            <button class="control-btn" onclick="saveApiKey()">Save</button>
            <button class="control-btn" onclick="testApiKey()">Test</button>
        </div>

        <div class="upload-area" id="uploadArea">
            <div class="upload-icon">üìÑ</div>
            <h3>Drop your text or markdown file here or click to upload</h3>
            <p style="color: var(--text-dim); margin-top: 0.5rem;">Supports .txt and .md files</p>
            <input type="file" id="fileInput" accept=".txt,.md" style="display: none;">
        </div>

        <div class="content-area" id="contentArea">
            <div class="text-display" id="textDisplay">
                <button class="exit-fullscreen" onclick="exitFullscreen()">‚úï Exit Fullscreen</button>
                <div class="text-content" id="textContent"></div>
            </div>

            <div class="ai-panel" id="aiPanel">
                <button class="ai-fullscreen-btn" id="aiFullscreenBtn" onclick="toggleAIFullscreen()" title="Toggle fullscreen">‚õ∂</button>
                <div class="ai-header">
                    <div class="ai-icon">‚ú®</div>
                    <div>
                        <h3>AI Assistant</h3>
                        <p style="font-size: 0.85rem; color: var(--text-dim);">Ask questions & test comprehension</p>
                    </div>
                </div>

                <div class="quick-actions">
                    <div class="quick-action" onclick="askAI('Summarize this text')">Summarize</div>
                    <div class="quick-action" onclick="askAI('What are the key points?')">Key Points</div>
                    <div class="quick-action" onclick="askAI('Quiz me on this text')">Quiz Me</div>
                    <div class="quick-action" onclick="askAI('Explain difficult concepts')">Explain</div>
                </div>

                <div class="chat-messages" id="chatMessages"></div>

                <div class="chat-input-area">
                    <input type="text" class="chat-input" id="chatInput" placeholder="Ask about the text..." onkeypress="handleChatKeypress(event)">
                    <button class="send-btn" id="sendBtn" onclick="sendMessage()">Send</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Speed Reader Modal -->
    <div class="speed-reader-modal" id="speedReaderModal">
        <div class="speed-reader-content">
            <div class="speed-word" id="speedWord">Ready</div>
            <div class="speed-controls">
                <button class="speed-control-btn" onclick="changeSpeed(-50)">Slower</button>
                <button class="speed-control-btn" id="speedPlayPause" onclick="toggleSpeedReading()">Start</button>
                <button class="speed-control-btn" onclick="changeSpeed(50)">Faster</button>
                <span class="wpm-display" id="wpmDisplay">250 WPM</span>
                <button class="speed-control-btn" onclick="closeSpeedReader()">Close</button>
            </div>
        </div>
    </div>

    <!-- Pomodoro Widget -->
    <div class="pomodoro-widget" id="pomodoroWidget">
        <div class="pomodoro-time" id="pomodoroTime">25:00</div>
        <div class="pomodoro-controls">
            <button class="control-btn" onclick="startPomodoro()">‚ñ∂Ô∏è</button>
            <button class="control-btn" onclick="pausePomodoro()">‚è∏Ô∏è</button>
            <button class="control-btn" onclick="resetPomodoro()">üîÑ</button>
        </div>
    </div>

    <!-- TTS Controls -->
    <div class="tts-controls" id="ttsControls">
        <div class="tts-engine-selector">
            <button class="tts-engine-btn active" id="browserTTSBtn" onclick="switchTTSEngine('browser')">
                Browser TTS
            </button>
            <button class="tts-engine-btn" id="edgeTTSBtn" onclick="switchTTSEngine('edge')">
                Edge TTS
            </button>
        </div>
        
        <div class="tts-main-controls">
            <button class="control-btn" onclick="playPauseTTS()">‚èØÔ∏è</button>
            <button class="control-btn" onclick="stopTTS()">‚èπÔ∏è</button>
            <div class="tts-rate-control">
                <span>Speed:</span>
                <input type="range" class="tts-rate-slider" id="ttsRate" min="0.5" max="2" step="0.1" value="1" onchange="updateTTSRate()">
                <span id="ttsRateValue">1x</span>
            </div>
        </div>
        
        <div class="edge-tts-options" id="edgeTTSOptions">
            <select class="edge-voice-selector" id="edgeVoiceSelector" onchange="updateEdgeVoice()">
                <option value="en-US-JennyNeural">Jenny (US Female)</option>
                <option value="en-US-GuyNeural">Guy (US Male)</option>
                <option value="en-US-AriaNeural">Aria (US Female)</option>
                <option value="en-US-DavisNeural">Davis (US Male)</option>
                <option value="en-GB-SoniaNeural">Sonia (UK Female)</option>
                <option value="en-GB-RyanNeural">Ryan (UK Male)</option>
                <option value="en-AU-NatashaNeural">Natasha (AU Female)</option>
                <option value="en-AU-WilliamNeural">William (AU Male)</option>
            </select>
            <div class="edge-tts-status" id="edgeTTSStatus">Ready</div>
        </div>
    </div>

    <!-- Autoscroll Controls -->
    <div class="autoscroll-controls" id="autoscrollControls">
        <div class="autoscroll-header">
            <span>Auto Scroll</span>
            <div class="autoscroll-status">
                <div class="autoscroll-indicator" id="autoscrollIndicator"></div>
                <span id="autoscrollStatus">Paused</span>
            </div>
        </div>
        <div class="autoscroll-speed-control">
            <div class="autoscroll-speed-label">
                <span>Speed</span>
                <span class="autoscroll-speed-value" id="autoscrollSpeedValue">50 px/s</span>
            </div>
            <input type="range" class="autoscroll-slider" id="autoscrollSpeed" 
                   min="10" max="200" step="5" value="50" 
                   oninput="updateAutoscrollSpeed()">
        </div>
        <div class="autoscroll-controls-buttons">
            <button class="autoscroll-btn" id="autoscrollPlayPause" onclick="toggleAutoscrollPlayPause()">
                ‚ñ∂Ô∏è Start
            </button>
            <button class="autoscroll-btn" onclick="resetAutoscroll()">
                üîÑ Reset
            </button>
        </div>
    </div>

    <script>
        // State variables
        let currentText = '';
        let apiKey = '';
        let focusMode = false;
        let currentFontSize = 1.1;
        let bionicMode = false;
        let focusGradient = false;
        let isFullscreen = false;
        let speedReading = false;
        let currentWordIndex = 0;
        let wordsPerMinute = 250;
        let speedInterval = null;
        let words = [];
        let sessionStartTime = Date.now();
        let sessionInterval = null;
        let pomodoroInterval = null;
        let pomodoroTime = 25 * 60;
        let ttsUtterance = null;
        let isTTSPlaying = false;
        let readingProgress = 0;
        let isMarkdown = false;
        let debugMode = true; // Enable debug logging for API issues
        let isAIFullscreen = false;
        let syntaxHighlightingEnabled = true;
        let autoscrollInterval = null;
        let autoscrollSpeed = 50; // pixels per second
        let isAutoscrolling = false;
        let autoscrollPaused = false;
        let ttsEngine = 'browser'; // 'browser' or 'edge'
        let edgeVoice = 'en-US-JennyNeural';
        let edgeAudio = null;
        let edgeAudioContext = null;
        let isEdgeTTSPlaying = false;

        // Initialize
        window.onload = () => {
            try {
                const savedKey = localStorage.getItem('geminiApiKey');
                if (savedKey) {
                    document.getElementById('apiKey').value = savedKey;
                    apiKey = savedKey;
                    console.log('API key loaded from storage');
                }
                
                // Set the provided API key if none is saved
                const providedKey = 'AIzaSyAYBfMZU6dFu_Qql8nARSTwlNevYCUP15k';
                if (!savedKey && providedKey) {
                    document.getElementById('apiKey').value = providedKey;
                    apiKey = providedKey;
                    localStorage.setItem('geminiApiKey', apiKey);
                    console.log('Using provided API key');
                }
            } catch (e) {
                console.error('Error loading API key:', e);
            }

            // Start session timer
            startSessionTimer();

            // Set up scroll tracking
            setupScrollTracking();

            // Close features menu when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.features-dropdown')) {
                    const menu = document.getElementById('featuresMenu');
                    if (menu) {
                        menu.classList.remove('active');
                    }
                }
            });
            
            // Add initial welcome message
            setTimeout(() => {
                if (!currentText) {
                    addMessage('ai', 'Welcome to Zen Text Reader Pro! Upload a text file to get started, and make sure to add your Gemini API key for AI assistance.');
                }
            }, 1000);
        };

        // Features menu
        function toggleFeaturesMenu() {
            const menu = document.getElementById('featuresMenu');
            menu.classList.toggle('active');
        }

        // Save API key
        function saveApiKey() {
            try {
                const keyInput = document.getElementById('apiKey');
                const newApiKey = keyInput.value.trim();
                
                if (!newApiKey) {
                    alert('Please enter an API key');
                    keyInput.style.borderColor = '#f59e0b';
                    setTimeout(() => {
                        keyInput.style.borderColor = '';
                    }, 2000);
                    return;
                }
                
                // Basic validation for Gemini API key format
                if (!newApiKey.startsWith('AIza') || newApiKey.length < 30) {
                    alert('Invalid API key format. Gemini API keys should start with "AIza" and be at least 30 characters long.');
                    keyInput.style.borderColor = '#f59e0b';
                    setTimeout(() => {
                        keyInput.style.borderColor = '';
                    }, 2000);
                    return;
                }
                
                apiKey = newApiKey;
                localStorage.setItem('geminiApiKey', apiKey);
                
                keyInput.style.borderColor = '#10b981';
                setTimeout(() => {
                    keyInput.style.borderColor = '';
                }, 2000);
                
                // Show success message
                addMessage('ai', 'API key saved successfully! You can now use the AI assistant.');
            } catch (e) {
                console.error('Error saving API key:', e);
                alert('Failed to save API key: ' + e.message);
            }
        }

        // Test API key
        async function testApiKey() {
            const keyInput = document.getElementById('apiKey');
            const testKey = keyInput.value.trim();
            
            if (!testKey) {
                alert('Please enter an API key first');
                return;
            }
            
            // Temporarily set the API key for testing
            const originalKey = apiKey;
            apiKey = testKey;
            
            const testBtn = event.target;
            testBtn.disabled = true;
            testBtn.textContent = 'Testing...';
            
            try {
                // Test with a simple prompt
                const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`;
                
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        contents: [{
                            parts: [{
                                text: 'Hello! This is a test message. Please respond with "API key is working correctly."'
                            }]
                        }],
                        generationConfig: {
                            temperature: 0.7,
                            maxOutputTokens: 100
                        }
                    })
                });

                if (response.ok) {
                    const data = await response.json();
                    if (data.candidates && data.candidates[0] && data.candidates[0].content) {
                        keyInput.style.borderColor = '#10b981';
                        addMessage('ai', '‚úÖ API key test successful! Your key is working correctly.');
                        
                        // Save the working key
                        localStorage.setItem('geminiApiKey', testKey);
                    } else {
                        throw new Error('Invalid response format');
                    }
                } else {
                    const errorData = await response.text();
                    throw new Error(`API test failed: ${response.status} - ${errorData}`);
                }
            } catch (error) {
                console.error('API key test failed:', error);
                keyInput.style.borderColor = '#f59e0b';
                
                let errorMessage = '‚ùå API key test failed: ';
                if (error.message.includes('401') || error.message.includes('403')) {
                    errorMessage += 'Invalid API key. Please check your key.';
                } else if (error.message.includes('429')) {
                    errorMessage += 'Rate limit exceeded. Try again later.';
                } else {
                    errorMessage += 'Connection error. Check your internet and API key.';
                }
                
                addMessage('ai', errorMessage);
                apiKey = originalKey; // Restore original key
            } finally {
                testBtn.disabled = false;
                testBtn.textContent = 'Test';
                
                setTimeout(() => {
                    keyInput.style.borderColor = '';
                }, 3000);
            }
        }

        // File upload handling
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');

        uploadArea.addEventListener('click', () => fileInput.click());

        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            
            const file = e.dataTransfer.files[0];
            if (file && (file.type === 'text/plain' || file.name.endsWith('.md'))) {
                readFile(file);
            } else {
                alert('Please upload a .txt or .md file');
            }
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                readFile(file);
            }
        });

        function readFile(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    currentText = e.target.result;
                    isMarkdown = file.name.endsWith('.md');
                    displayText(currentText);
                    document.getElementById('contentArea').classList.add('active');
                    updateStats();
                    
                    // Add initial AI message
                    if (apiKey) {
                        addMessage('ai', 'Text loaded! I can help you understand it better. Try asking for a summary, quiz yourself, or ask about specific concepts.');
                    } else {
                        addMessage('ai', 'Text loaded! Add your Gemini API key to enable AI assistance for summaries, quizzes, and explanations.');
                    }
                } catch (error) {
                    console.error('Error reading file:', error);
                    alert('Failed to read file');
                }
            };
            reader.onerror = () => {
                alert('Failed to read file');
            };
            reader.readAsText(file);
        }

        function displayText(text) {
            const textContent = document.getElementById('textContent');
            
            try {
                if (isMarkdown) {
                    textContent.innerHTML = parseMarkdown(text);
                } else if (bionicMode) {
                    textContent.innerHTML = applyBionicReading(text);
                } else {
                    textContent.textContent = text;
                }
                
                words = text.replace(/[#*`\[\]()]/g, '').split(/\s+/).filter(word => word.length > 0);
                
                // Update stats and show reading progress
                updateStats();
                document.querySelector('.reading-progress').classList.add('active');
            } catch (e) {
                console.error('Error displaying text:', e);
                textContent.textContent = text; // Fallback to plain text
            }
        }

        // Simple markdown parser
        function parseMarkdown(text) {
            try {
                let html = text;
                
                // Headers
                html = html.replace(/^### (.*$)/gim, '<h3>$1</h3>');
                html = html.replace(/^## (.*$)/gim, '<h2>$1</h2>');
                html = html.replace(/^# (.*$)/gim, '<h1>$1</h1>');
                
                // Bold
                html = html.replace(/\*\*\*(.+?)\*\*\*/g, '<strong><em>$1</em></strong>');
                html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
                html = html.replace(/__(.+?)__/g, '<strong>$1</strong>');
                
                // Italic
                html = html.replace(/\*(.+?)\*/g, '<em>$1</em>');
                html = html.replace(/_(.+?)_/g, '<em>$1</em>');
                
                // Links
                html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank">$1</a>');
                
                // Inline code
                html = html.replace(/`([^`]+)`/g, '<code>$1</code>');
                
                // Code blocks
                html = html.replace(/```(.*?)\n([\s\S]*?)```/g, '<pre><code>$2</code></pre>');
                
                // Blockquotes
                html = html.replace(/^> (.*$)/gim, '<blockquote>$1</blockquote>');
                
                // Lists
                html = html.replace(/^\* (.+)/gim, '<li>$1</li>');
                html = html.replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>');
                html = html.replace(/^\d+\. (.+)/gim, '<li>$1</li>');
                
                // Paragraphs
                html = html.replace(/\n\n/g, '</p><p>');
                html = '<p>' + html + '</p>';
                
                // Clean up
                html = html.replace(/<p><\/p>/g, '');
                html = html.replace(/<p>(<h[1-6]>)/g, '$1');
                html = html.replace(/(<\/h[1-6]>)<\/p>/g, '$1');
                
                if (bionicMode) {
                    // Apply bionic reading to text content only
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = html;
                    applyBionicToElement(tempDiv);
                    html = tempDiv.innerHTML;
                }
                
                return html;
            } catch (e) {
                console.error('Error parsing markdown:', e);
                return text; // Return original text on error
            }
        }

        function applyBionicToElement(element) {
            const textNodes = [];
            const walker = document.createTreeWalker(
                element,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );
            
            let node;
            while (node = walker.nextNode()) {
                if (node.textContent.trim() && !node.parentElement.matches('code, pre')) {
                    textNodes.push(node);
                }
            }
            
            textNodes.forEach(node => {
                const bionicHtml = applyBionicReading(node.textContent);
                const span = document.createElement('span');
                span.innerHTML = bionicHtml;
                node.parentNode.replaceChild(span, node);
            });
        }

        // Stats updating
        function updateStats() {
            try {
                const wordCount = words.length;
                const avgWPM = 200; // Average reading speed
                const readingTime = Math.ceil(wordCount / avgWPM);
                
                document.getElementById('wordCount').textContent = wordCount;
                document.getElementById('readingTime').textContent = `${readingTime} min`;
                updateProgressPercent();
            } catch (e) {
                console.error('Error updating stats:', e);
            }
        }

        function updateProgressPercent() {
            try {
                const progressElement = document.getElementById('progressPercent');
                if (progressElement) {
                    progressElement.textContent = `${Math.round(readingProgress)}%`;
                }
                
                const progressBar = document.querySelector('.reading-progress-bar');
                if (progressBar) {
                    progressBar.style.width = `${readingProgress}%`;
                }
            } catch (e) {
                console.error('Error updating progress:', e);
            }
        }

        // Session timer
        function startSessionTimer() {
            sessionInterval = setInterval(() => {
                try {
                    const elapsed = Math.floor((Date.now() - sessionStartTime) / 1000);
                    const minutes = Math.floor(elapsed / 60);
                    const seconds = elapsed % 60;
                    document.getElementById('sessionTime').textContent = 
                        `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                } catch (e) {
                    console.error('Error updating session timer:', e);
                }
            }, 1000);
        }

        // Scroll tracking
        function setupScrollTracking() {
            const textDisplay = document.getElementById('textDisplay');
            textDisplay.addEventListener('scroll', () => {
                try {
                    const scrollPercent = (textDisplay.scrollTop / 
                        Math.max(1, textDisplay.scrollHeight - textDisplay.clientHeight)) * 100;
                    readingProgress = Math.min(100, Math.max(0, scrollPercent));
                    updateProgressPercent();
                } catch (e) {
                    console.error('Error tracking scroll:', e);
                }
            });
        }

        // Text controls
        function changeTextSize(action) {
            try {
                const textContent = document.getElementById('textContent');
                if (action === 'increase') {
                    currentFontSize = Math.min(2, currentFontSize + 0.1);
                } else {
                    currentFontSize = Math.max(0.8, currentFontSize - 0.1);
                }
                textContent.style.fontSize = currentFontSize + 'rem';
            } catch (e) {
                console.error('Error changing text size:', e);
            }
        }

        // Theme toggle
        function toggleTheme() {
            document.body.classList.toggle('light-theme');
            updateFeatureItemState('theme', document.body.classList.contains('light-theme'));
        }

        // Fullscreen mode
        function toggleFullscreen() {
            const textDisplay = document.getElementById('textDisplay');
            isFullscreen = !isFullscreen;
            
            try {
                if (isFullscreen) {
                    textDisplay.classList.add('fullscreen');
                    if (textDisplay.requestFullscreen) {
                        textDisplay.requestFullscreen().catch(err => {
                            console.error('Error entering fullscreen:', err);
                            isFullscreen = false;
                            textDisplay.classList.remove('fullscreen');
                        });
                    }
                } else {
                    exitFullscreen();
                }
                updateFeatureItemState('fullscreen', isFullscreen);
            } catch (e) {
                console.error('Error toggling fullscreen:', e);
            }
        }

        function exitFullscreen() {
            const textDisplay = document.getElementById('textDisplay');
            textDisplay.classList.remove('fullscreen');
            isFullscreen = false;
            
            if (document.exitFullscreen && document.fullscreenElement) {
                document.exitFullscreen().catch(err => {
                    console.error('Error exiting fullscreen:', err);
                });
            }
            updateFeatureItemState('fullscreen', false);
        }

        // Bionic reading mode
        function toggleBionicMode() {
            bionicMode = !bionicMode;
            displayText(currentText);
            updateFeatureItemState('bionic', bionicMode);
        }

        function applyBionicReading(text) {
            try {
                return text.split(/\s+/).map(word => {
                    if (!word) return '';
                    if (word.length <= 3) {
                        return `<span class="word"><span class="bold">${word}</span></span>`;
                    }
                    const boldLength = Math.ceil(word.length * 0.4);
                    const boldPart = word.slice(0, boldLength);
                    const normalPart = word.slice(boldLength);
                    return `<span class="word"><span class="bold">${boldPart}</span>${normalPart}</span>`;
                }).join(' ');
            } catch (e) {
                console.error('Error applying bionic reading:', e);
                return text;
            }
        }

        // Focus gradient
        function toggleFocusGradient() {
            focusGradient = !focusGradient;
            const textContent = document.getElementById('textContent');
            
            if (focusGradient) {
                textContent.classList.add('focus-gradient');
            } else {
                textContent.classList.remove('focus-gradient');
            }
            updateFeatureItemState('focus', focusGradient);
        }

        // Speed reader
        function startSpeedReader() {
            if (!currentText || words.length === 0) {
                alert('Please load a text file first');
                return;
            }
            
            document.getElementById('speedReaderModal').classList.add('active');
            currentWordIndex = 0;
            updateSpeedDisplay();
        }

        function closeSpeedReader() {
            stopSpeedReading();
            document.getElementById('speedReaderModal').classList.remove('active');
        }

        function toggleSpeedReading() {
            if (speedReading) {
                stopSpeedReading();
            } else {
                startSpeedReading();
            }
        }

        function startSpeedReading() {
            if (currentWordIndex >= words.length) {
                currentWordIndex = 0;
            }
            
            speedReading = true;
            document.getElementById('speedPlayPause').textContent = 'Pause';
            
            const interval = 60000 / wordsPerMinute;
            speedInterval = setInterval(() => {
                if (currentWordIndex < words.length) {
                    document.getElementById('speedWord').textContent = words[currentWordIndex];
                    currentWordIndex++;
                } else {
                    stopSpeedReading();
                    document.getElementById('speedWord').textContent = 'Complete!';
                }
            }, interval);
        }

        function stopSpeedReading() {
            speedReading = false;
            document.getElementById('speedPlayPause').textContent = 'Start';
            if (speedInterval) {
                clearInterval(speedInterval);
                speedInterval = null;
            }
        }

        function changeSpeed(delta) {
            wordsPerMinute = Math.max(100, Math.min(800, wordsPerMinute + delta));
            updateSpeedDisplay();
            
            if (speedReading) {
                stopSpeedReading();
                startSpeedReading();
            }
        }

        function updateSpeedDisplay() {
            document.getElementById('wpmDisplay').textContent = `${wordsPerMinute} WPM`;
        }

        // Pomodoro timer
        function togglePomodoro() {
            const widget = document.getElementById('pomodoroWidget');
            const isActive = widget.classList.toggle('active');
            updateFeatureItemState('pomodoro', isActive);
        }

        function startPomodoro() {
            if (pomodoroInterval) return;
            
            pomodoroInterval = setInterval(() => {
                if (pomodoroTime > 0) {
                    pomodoroTime--;
                    updatePomodoroDisplay();
                } else {
                    // Timer finished
                    alert('Pomodoro session complete! Take a break.');
                    resetPomodoro();
                }
            }, 1000);
        }

        function pausePomodoro() {
            if (pomodoroInterval) {
                clearInterval(pomodoroInterval);
                pomodoroInterval = null;
            }
        }

        function resetPomodoro() {
            pausePomodoro();
            pomodoroTime = 25 * 60;
            updatePomodoroDisplay();
        }

        function updatePomodoroDisplay() {
            const minutes = Math.floor(pomodoroTime / 60);
            const seconds = pomodoroTime % 60;
            document.getElementById('pomodoroTime').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // Text-to-Speech
        function toggleTTS() {
            const controls = document.getElementById('ttsControls');
            const isActive = controls.classList.toggle('active');
            updateFeatureItemState('tts', isActive);
            
            if (!isTTSPlaying && !isEdgeTTSPlaying && currentText && isActive) {
                if (ttsEngine === 'browser') {
                    startTTS();
                } else {
                    startEdgeTTS();
                }
            }
        }

        function switchTTSEngine(engine) {
            // Stop current TTS
            stopTTS();
            stopEdgeTTS();
            
            ttsEngine = engine;
            
            // Update UI
            document.getElementById('browserTTSBtn').classList.toggle('active', engine === 'browser');
            document.getElementById('edgeTTSBtn').classList.toggle('active', engine === 'edge');
            document.getElementById('edgeTTSOptions').classList.toggle('active', engine === 'edge');
            
            console.log(`Switched to ${engine} TTS engine`);
        }

        function updateEdgeVoice() {
            edgeVoice = document.getElementById('edgeVoiceSelector').value;
            console.log(`Selected Edge voice: ${edgeVoice}`);
        }

        // Browser TTS functions
        function startTTS() {
            if (!currentText) return;
            
            try {
                stopTTS(); // Stop any ongoing speech
                
                ttsUtterance = new SpeechSynthesisUtterance(currentText);
                ttsUtterance.rate = parseFloat(document.getElementById('ttsRate').value);
                
                ttsUtterance.onend = () => {
                    isTTSPlaying = false;
                };
                
                ttsUtterance.onerror = (event) => {
                    console.error('TTS error:', event);
                    isTTSPlaying = false;
                };
                
                speechSynthesis.speak(ttsUtterance);
                isTTSPlaying = true;
            } catch (e) {
                console.error('Error starting TTS:', e);
                alert('Text-to-speech is not supported in your browser');
            }
        }

        function playPauseTTS() {
            if (ttsEngine === 'browser') {
                try {
                    if (speechSynthesis.paused) {
                        speechSynthesis.resume();
                    } else if (speechSynthesis.speaking) {
                        speechSynthesis.pause();
                    } else {
                        startTTS();
                    }
                } catch (e) {
                    console.error('Error toggling TTS:', e);
                }
            } else {
                // Edge TTS
                if (isEdgeTTSPlaying) {
                    pauseEdgeTTS();
                } else {
                    startEdgeTTS();
                }
            }
        }

        function stopTTS() {
            try {
                speechSynthesis.cancel();
                isTTSPlaying = false;
            } catch (e) {
                console.error('Error stopping TTS:', e);
            }
        }

        // Edge TTS functions
        async function startEdgeTTS() {
            if (!currentText) return;
            
            const statusEl = document.getElementById('edgeTTSStatus');
            statusEl.innerHTML = '<div class="edge-tts-loading"><span class="loading"></span> Generating audio...</div>';
            
            try {
                // Create Edge TTS API request
                const response = await generateEdgeTTSAudio(currentText, edgeVoice);
                
                if (response.ok) {
                    const audioBlob = await response.blob();
                    playEdgeTTSAudio(audioBlob);
                    statusEl.textContent = 'Playing';
                } else {
                    throw new Error('Failed to generate audio');
                }
            } catch (e) {
                console.error('Edge TTS error:', e);
                statusEl.textContent = 'Error - Falling back to browser TTS';
                
                // Fallback to browser TTS
                switchTTSEngine('browser');
                startTTS();
            }
        }

        async function generateEdgeTTSAudio(text, voice) {
            // Since Edge TTS requires a server endpoint, we'll simulate it
            // In a real implementation, this would call your Edge TTS server
            
            // For demonstration, we'll use a mock response
            // In production, replace this with actual Edge TTS API call
            return new Promise((resolve) => {
                setTimeout(() => {
                    // Simulate API response
                    console.log(`Would generate Edge TTS with voice: ${voice}`);
                    console.log(`Text length: ${text.length} characters`);
                    
                    // Return a mock successful response
                    resolve({
                        ok: false, // Set to false to demonstrate fallback
                        blob: async () => new Blob(['mock audio data'], { type: 'audio/mp3' })
                    });
                }, 1000);
            });
        }

        function playEdgeTTSAudio(audioBlob) {
            try {
                // Create audio context if not exists
                if (!edgeAudioContext) {
                    edgeAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                // Create audio element
                edgeAudio = new Audio(URL.createObjectURL(audioBlob));
                edgeAudio.playbackRate = parseFloat(document.getElementById('ttsRate').value);
                
                edgeAudio.onended = () => {
                    isEdgeTTSPlaying = false;
                    document.getElementById('edgeTTSStatus').textContent = 'Ready';
                };
                
                edgeAudio.onerror = (e) => {
                    console.error('Edge audio playback error:', e);
                    isEdgeTTSPlaying = false;
                    document.getElementById('edgeTTSStatus').textContent = 'Error';
                };
                
                edgeAudio.play();
                isEdgeTTSPlaying = true;
            } catch (e) {
                console.error('Error playing Edge TTS audio:', e);
            }
        }

        function pauseEdgeTTS() {
            if (edgeAudio && !edgeAudio.paused) {
                edgeAudio.pause();
                document.getElementById('edgeTTSStatus').textContent = 'Paused';
            } else if (edgeAudio && edgeAudio.paused) {
                edgeAudio.play();
                document.getElementById('edgeTTSStatus').textContent = 'Playing';
            }
        }

        function stopEdgeTTS() {
            if (edgeAudio) {
                edgeAudio.pause();
                edgeAudio.currentTime = 0;
                isEdgeTTSPlaying = false;
                document.getElementById('edgeTTSStatus').textContent = 'Ready';
            }
        }

        function updateTTSRate() {
            const rate = document.getElementById('ttsRate').value;
            document.getElementById('ttsRateValue').textContent = `${rate}x`;
            
            if (ttsEngine === 'browser' && ttsUtterance) {
                ttsUtterance.rate = parseFloat(rate);
            } else if (ttsEngine === 'edge' && edgeAudio) {
                edgeAudio.playbackRate = parseFloat(rate);
            }
        }

        // Toggle syntax highlighting
        function toggleSyntaxHighlighting() {
            syntaxHighlightingEnabled = !syntaxHighlightingEnabled;
            updateFeatureItemState('syntax', syntaxHighlightingEnabled);
            
            // Store original messages before re-rendering
            const aiMessages = document.querySelectorAll('.message.ai');
            aiMessages.forEach(messageDiv => {
                const bubble = messageDiv.querySelector('.message-bubble');
                // Store original text if not already stored
                if (!messageDiv.dataset.originalText) {
                    messageDiv.dataset.originalText = bubble.textContent;
                }
                
                // Re-render with current settings
                const originalText = messageDiv.dataset.originalText;
                let processedContent = parseAIMarkdown(originalText);
                
                if (syntaxHighlightingEnabled) {
                    processedContent = applySyntaxHighlightingToHTML(processedContent);
                }
                
                bubble.innerHTML = processedContent;
            });
        }

        // Autoscroll functions
        function toggleAutoscroll() {
            const controls = document.getElementById('autoscrollControls');
            const isActive = controls.classList.toggle('active');
            updateFeatureItemState('autoscroll', isActive);
            
            if (!isActive && isAutoscrolling) {
                stopAutoscroll();
            }
        }

        function toggleAutoscrollPlayPause() {
            if (isAutoscrolling) {
                pauseAutoscroll();
            } else {
                startAutoscroll();
            }
        }

        function startAutoscroll() {
            if (!currentText) {
                alert('Please load a text file first');
                return;
            }
            
            const textDisplay = document.getElementById('textDisplay');
            const playPauseBtn = document.getElementById('autoscrollPlayPause');
            const indicator = document.getElementById('autoscrollIndicator');
            const status = document.getElementById('autoscrollStatus');
            
            isAutoscrolling = true;
            autoscrollPaused = false;
            
            playPauseBtn.innerHTML = '‚è∏Ô∏è Pause';
            playPauseBtn.classList.add('active');
            indicator.classList.add('running');
            status.textContent = 'Scrolling';
            
            // Calculate scroll increment based on speed (pixels per second)
            const scrollIncrement = autoscrollSpeed / 60; // 60fps
            
            autoscrollInterval = setInterval(() => {
                if (!autoscrollPaused) {
                    const currentScroll = textDisplay.scrollTop;
                    const maxScroll = textDisplay.scrollHeight - textDisplay.clientHeight;
                    
                    if (currentScroll < maxScroll) {
                        textDisplay.scrollTop += scrollIncrement;
                    } else {
                        // Reached the end
                        stopAutoscroll();
                        alert('Reached the end of the document');
                    }
                }
            }, 1000 / 60); // 60fps for smooth scrolling
        }

        function pauseAutoscroll() {
            if (!isAutoscrolling) return;
            
            const playPauseBtn = document.getElementById('autoscrollPlayPause');
            const indicator = document.getElementById('autoscrollIndicator');
            const status = document.getElementById('autoscrollStatus');
            
            autoscrollPaused = true;
            playPauseBtn.innerHTML = '‚ñ∂Ô∏è Resume';
            playPauseBtn.classList.remove('active');
            indicator.classList.remove('running');
            status.textContent = 'Paused';
        }

        function stopAutoscroll() {
            if (autoscrollInterval) {
                clearInterval(autoscrollInterval);
                autoscrollInterval = null;
            }
            
            const playPauseBtn = document.getElementById('autoscrollPlayPause');
            const indicator = document.getElementById('autoscrollIndicator');
            const status = document.getElementById('autoscrollStatus');
            
            isAutoscrolling = false;
            autoscrollPaused = false;
            
            playPauseBtn.innerHTML = '‚ñ∂Ô∏è Start';
            playPauseBtn.classList.remove('active');
            indicator.classList.remove('running');
            status.textContent = 'Stopped';
        }

        function resetAutoscroll() {
            stopAutoscroll();
            const textDisplay = document.getElementById('textDisplay');
            textDisplay.scrollTop = 0;
            updateStats(); // Update reading progress
        }

        function updateAutoscrollSpeed() {
            const slider = document.getElementById('autoscrollSpeed');
            const speedValue = document.getElementById('autoscrollSpeedValue');
            
            autoscrollSpeed = parseInt(slider.value);
            speedValue.textContent = `${autoscrollSpeed} px/s`;
            
            // If currently scrolling, restart with new speed
            if (isAutoscrolling && !autoscrollPaused) {
                stopAutoscroll();
                startAutoscroll();
            }
        }

        // Update feature menu item states
        function updateFeatureItemState(feature, isActive) {
            const featureMap = {
                'fullscreen': 0,
                'speed': 1,
                'bionic': 2,
                'focus': 3,
                'pomodoro': 4,
                'tts': 5,
                'theme': 6,
                'increase': 7,
                'decrease': 8,
                'syntax': 9,
                'autoscroll': 10
            };
            
            const items = document.querySelectorAll('.feature-item');
            const index = featureMap[feature];
            
            if (index !== undefined && items[index]) {
                if (isActive) {
                    items[index].classList.add('active');
                } else {
                    items[index].classList.remove('active');
                }
            }
        }

        // Chat functionality
        function addMessage(type, content) {
            try {
                const chatMessages = document.getElementById('chatMessages');
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${type}`;
                
                const bubbleDiv = document.createElement('div');
                bubbleDiv.className = 'message-bubble';
                
                // Process AI messages
                if (type === 'ai') {
                    // Store original text for toggle functionality
                    messageDiv.dataset.originalText = content;
                    
                    // First parse markdown
                    let processedContent = parseAIMarkdown(content);
                    
                    // Then apply syntax highlighting if enabled
                    if (syntaxHighlightingEnabled) {
                        processedContent = applySyntaxHighlightingToHTML(processedContent);
                    }
                    
                    bubbleDiv.innerHTML = processedContent;
                } else {
                    bubbleDiv.textContent = content;
                }
                
                messageDiv.appendChild(bubbleDiv);
                chatMessages.appendChild(messageDiv);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            } catch (e) {
                console.error('Error adding message:', e);
            }
        }

        async function sendMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            
            if (!message) return;
            
            if (!apiKey) {
                addMessage('ai', 'Please add your Gemini API key first and click Save.');
                return;
            }
            
            if (!currentText) {
                addMessage('ai', 'Please upload a text file first.');
                return;
            }
            
            addMessage('user', message);
            input.value = '';
            
            const sendBtn = document.getElementById('sendBtn');
            sendBtn.disabled = true;
            sendBtn.innerHTML = '<span class="loading"></span>';
            
            try {
                const response = await callGeminiAPI(message);
                addMessage('ai', response);
            } catch (error) {
                console.error('API error:', error);
                console.error('Error details:', {
                    message: error.message,
                    stack: error.stack,
                    apiKey: apiKey ? `${apiKey.substring(0, 10)}...` : 'Not set'
                });
                
                let errorMessage = 'Sorry, I encountered an error. ';
                
                if (error.message.includes('401') || error.message.includes('Authentication failed')) {
                    errorMessage += 'Please check your API key - it may be invalid or expired.';
                } else if (error.message.includes('403') || error.message.includes('Access forbidden')) {
                    errorMessage += 'Access denied. Please ensure your API key has the necessary permissions.';
                } else if (error.message.includes('429') || error.message.includes('Rate limit')) {
                    errorMessage += 'API rate limit exceeded. Please wait a moment and try again.';
                } else if (error.message.includes('quota') || error.message.includes('QUOTA_EXCEEDED')) {
                    errorMessage += 'API quota exceeded. Please check your Google Cloud billing status.';
                } else if (error.message.includes('Network error')) {
                    errorMessage += 'Network connection error. Please check your internet connection.';
                } else if (error.message.includes('safety') || error.message.includes('SAFETY')) {
                    errorMessage += error.message;
                } else {
                    errorMessage += error.message || 'Please check your API key and try again.';
                }
                
                addMessage('ai', errorMessage);
            } finally {
                sendBtn.disabled = false;
                sendBtn.innerHTML = 'Send';
            }
        }

        async function callGeminiAPI(userMessage) {
            if (!apiKey) {
                throw new Error('API key is required');
            }
            
            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`;
            
            const selectedText = window.getSelection().toString();
            const contextText = selectedText || currentText;
            
            // Limit context to avoid token limits
            const maxContextLength = 4000;
            const truncatedContext = contextText.length > maxContextLength 
                ? contextText.substring(0, maxContextLength) + '...'
                : contextText;
            
            let prompt = '';
            
            if (userMessage.toLowerCase().includes('quiz')) {
                prompt = `Based on the following text, create 5 multiple-choice questions to test comprehension. Format each question with the question, 4 options (A, B, C, D), and indicate the correct answer.

Text: ${truncatedContext}`;
            } else if (userMessage.toLowerCase().includes('summarize')) {
                prompt = `Please provide a concise summary of the following text in 3-5 bullet points:

Text: ${truncatedContext}`;
            } else if (userMessage.toLowerCase().includes('key points')) {
                prompt = `What are the key points and main ideas in the following text? List them as bullet points:

Text: ${truncatedContext}`;
            } else if (userMessage.toLowerCase().includes('explain')) {
                prompt = `Please explain any difficult concepts or technical terms from the following text in simple language:

Text: ${truncatedContext}`;
            } else {
                prompt = `You are a helpful reading assistant. The user is reading the following text:

---
${truncatedContext}
---

User question: ${userMessage}

Please provide a helpful, concise response based on the text provided.`;
            }

            try {
                const requestBody = {
                    contents: [{
                        parts: [{
                            text: prompt
                        }]
                    }],
                    generationConfig: {
                        temperature: 0.7,
                        topK: 40,
                        topP: 0.95,
                        maxOutputTokens: 2048
                    }
                };
                
                if (debugMode) {
                    console.log('Gemini API Request:', {
                        url: url.replace(apiKey, 'API_KEY_HIDDEN'),
                        method: 'POST',
                        promptLength: prompt.length,
                        promptPreview: prompt.substring(0, 100) + '...'
                    });
                }
                
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    const errorData = await response.text();
                    let errorMessage = `API request failed: ${response.status}`;
                    
                    try {
                        const errorJson = JSON.parse(errorData);
                        if (errorJson.error && errorJson.error.message) {
                            errorMessage += ` - ${errorJson.error.message}`;
                            
                            // Provide specific guidance for common errors
                            if (errorJson.error.message.includes('API_KEY_INVALID')) {
                                errorMessage = 'Invalid API key. Please check your Gemini API key.';
                            } else if (errorJson.error.message.includes('QUOTA_EXCEEDED')) {
                                errorMessage = 'API quota exceeded. Please check your Google Cloud billing.';
                            } else if (errorJson.error.message.includes('RATE_LIMIT_EXCEEDED')) {
                                errorMessage = 'Rate limit exceeded. Please wait a moment and try again.';
                            }
                        }
                    } catch (e) {
                        if (response.status === 400) {
                            errorMessage = 'Bad request. The API key may be invalid or the request format is incorrect.';
                        } else if (response.status === 401) {
                            errorMessage = 'Authentication failed. Please check your API key.';
                        } else if (response.status === 403) {
                            errorMessage = 'Access forbidden. Your API key may not have the necessary permissions.';
                        } else if (response.status === 429) {
                            errorMessage = 'Too many requests. Please wait a moment and try again.';
                        }
                    }
                    
                    throw new Error(errorMessage);
                }

                const data = await response.json();
                
                if (debugMode) {
                    console.log('Gemini API Response:', {
                        status: response.status,
                        hasData: !!data,
                        hasCandidates: !!(data && data.candidates),
                        candidatesCount: data && data.candidates ? data.candidates.length : 0,
                        finishReason: data && data.candidates && data.candidates[0] ? data.candidates[0].finishReason : 'N/A'
                    });
                }
                
                // Validate response structure
                if (!data || !data.candidates || !Array.isArray(data.candidates) || data.candidates.length === 0) {
                    console.error('Invalid API response structure:', data);
                    throw new Error('Invalid API response: No candidates found. The API may have rejected the request.');
                }
                
                const candidate = data.candidates[0];
                
                // Check for safety ratings or blocked content
                if (candidate.finishReason === 'SAFETY') {
                    throw new Error('The response was blocked due to safety filters. Try rephrasing your question.');
                }
                
                if (!candidate.content || !candidate.content.parts || !Array.isArray(candidate.content.parts) || candidate.content.parts.length === 0) {
                    console.error('Invalid candidate structure:', candidate);
                    throw new Error('Invalid API response: No content found in the response.');
                }
                
                const responseText = candidate.content.parts[0].text;
                if (!responseText || typeof responseText !== 'string') {
                    throw new Error('Invalid API response: No text content found in the response.');
                }
                
                return responseText.trim();
                
            } catch (error) {
                if (error instanceof TypeError && error.message.includes('fetch')) {
                    throw new Error('Network error: Please check your internet connection');
                }
                throw error;
            }
        }

        function askAI(question) {
            document.getElementById('chatInput').value = question;
            sendMessage();
        }

        function handleChatKeypress(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Don't trigger shortcuts when typing in input fields
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                return;
            }
            
            if (e.ctrlKey || e.metaKey) {
                switch(e.key.toLowerCase()) {
                    case 'f':
                        e.preventDefault();
                        toggleFullscreen();
                        break;
                    case 's':
                        e.preventDefault();
                        startSpeedReader();
                        break;
                    case 'b':
                        e.preventDefault();
                        toggleBionicMode();
                        break;
                    case 'p':
                        e.preventDefault();
                        togglePomodoro();
                        break;
                    case 'l':
                        e.preventDefault();
                        toggleTTS();
                        break;
                    case 'h':
                        e.preventDefault();
                        toggleSyntaxHighlighting();
                        break;
                    case 'a':
                        e.preventDefault();
                        toggleAIFullscreen();
                        break;
                    case 'r':
                        e.preventDefault();
                        toggleAutoscroll();
                        break;
                }
            } else if (e.key === 'Escape') {
                if (isFullscreen) {
                    exitFullscreen();
                }
                if (isAIFullscreen) {
                    toggleAIFullscreen();
                }
                if (document.getElementById('speedReaderModal').classList.contains('active')) {
                    closeSpeedReader();
                }
                if (document.getElementById('autoscrollControls').classList.contains('active')) {
                    toggleAutoscroll();
                }
            } else if (e.key === ' ' && document.getElementById('autoscrollControls').classList.contains('active')) {
                // Space bar to play/pause autoscroll when the control panel is active
                e.preventDefault();
                toggleAutoscrollPlayPause();
            }
        });

        // Clean up on page unload
        window.addEventListener('beforeunload', () => {
            if (sessionInterval) clearInterval(sessionInterval);
            if (pomodoroInterval) clearInterval(pomodoroInterval);
            if (speedInterval) clearInterval(speedInterval);
            if (autoscrollInterval) clearInterval(autoscrollInterval);
            stopTTS();
            stopEdgeTTS();
        });

        // AI Fullscreen toggle
        function toggleAIFullscreen() {
            const aiPanel = document.getElementById('aiPanel');
            const btn = document.getElementById('aiFullscreenBtn');
            isAIFullscreen = !isAIFullscreen;
            
            if (isAIFullscreen) {
                aiPanel.classList.add('fullscreen');
                btn.innerHTML = '‚úï';
                btn.title = 'Exit fullscreen';
                
                // Hide other elements
                document.querySelector('.content-area').style.gridTemplateColumns = '1fr';
                document.getElementById('textDisplay').style.display = 'none';
            } else {
                aiPanel.classList.remove('fullscreen');
                btn.innerHTML = '‚õ∂';
                btn.title = 'Toggle fullscreen';
                
                // Restore layout
                document.querySelector('.content-area').style.gridTemplateColumns = '1fr 400px';
                document.getElementById('textDisplay').style.display = 'block';
            }
        }

        // Parse markdown for AI responses
        function parseAIMarkdown(text) {
            try {
                let html = text;
                
                // Escape HTML to prevent XSS
                html = html.replace(/&/g, '&amp;')
                          .replace(/</g, '&lt;')
                          .replace(/>/g, '&gt;');
                
                // Code blocks FIRST (before other replacements)
                // Triple backtick code blocks with optional language
                html = html.replace(/```(\w+)?\n([\s\S]*?)```/g, (match, lang, code) => {
                    const language = lang ? lang.toLowerCase() : '';
                    const highlightedCode = highlightCode(code.trim(), language);
                    return `<pre class="syntax-code-block"><code class="language-${language}">${highlightedCode}</code></pre>`;
                });
                
                // Inline code (must be after code blocks)
                html = html.replace(/`([^`\n]+)`/g, '<code class="syntax-code">$1</code>');
                
                // Headers (h1-h6)
                html = html.replace(/^#{6}\s+(.+)$/gm, '<h6>$1</h6>');
                html = html.replace(/^#{5}\s+(.+)$/gm, '<h5>$1</h5>');
                html = html.replace(/^#{4}\s+(.+)$/gm, '<h4>$1</h4>');
                html = html.replace(/^#{3}\s+(.+)$/gm, '<h3>$1</h3>');
                html = html.replace(/^#{2}\s+(.+)$/gm, '<h2>$1</h2>');
                html = html.replace(/^#{1}\s+(.+)$/gm, '<h1>$1</h1>');
                
                // Bold and italic (order matters)
                html = html.replace(/\*\*\*(.+?)\*\*\*/g, '<strong><em>$1</em></strong>');
                html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
                html = html.replace(/__(.+?)__/g, '<strong>$1</strong>');
                html = html.replace(/\*([^*\n]+?)\*/g, '<em>$1</em>');
                html = html.replace(/_([^_\n]+?)_/g, '<em>$1</em>');
                
                // Strikethrough
                html = html.replace(/~~(.+?)~~/g, '<del>$1</del>');
                
                // Links
                html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" style="color: var(--primary); text-decoration: underline;">$1</a>');
                
                // Blockquotes
                html = html.replace(/^&gt; (.+)$/gm, '<blockquote style="border-left: 3px solid var(--primary); padding-left: 1rem; margin: 0.5rem 0; color: var(--text-dim);">$1</blockquote>');
                
                // Horizontal rules
                html = html.replace(/^(---|\*\*\*|___)$/gm, '<hr style="border: none; border-top: 1px solid var(--glass-border); margin: 1rem 0;">');
                
                // Lists
                // Unordered lists
                html = html.replace(/^[\*\-]\s+(.+)$/gm, '<li>$1</li>');
                // Wrap consecutive li elements in ul
                html = html.replace(/(<li>.*<\/li>\s*)+/g, (match) => {
                    return '<ul style="margin: 0.5rem 0; padding-left: 1.5rem;">' + match + '</ul>';
                });
                
                // Ordered lists
                html = html.replace(/^\d+\.\s+(.+)$/gm, '<li>$1</li>');
                // This is a simplified approach - in production you'd want more sophisticated list handling
                
                // Tables (basic support)
                html = html.replace(/\|(.+)\|/g, (match, content) => {
                    const cells = content.split('|').map(cell => cell.trim());
                    if (cells.every(cell => cell.match(/^:?-+:?$/))) {
                        return ''; // Skip separator rows
                    }
                    const cellTags = cells.map(cell => `<td style="padding: 0.5rem; border: 1px solid var(--glass-border);">${cell}</td>`).join('');
                    return `<tr>${cellTags}</tr>`;
                });
                // Wrap table rows in table
                html = html.replace(/(<tr>.*<\/tr>\s*)+/g, (match) => {
                    return '<table style="border-collapse: collapse; margin: 0.5rem 0;">' + match + '</table>';
                });
                
                // Line breaks
                html = html.replace(/\n\n/g, '</p><p>');
                html = html.replace(/\n/g, '<br>');
                
                // Wrap in paragraphs
                if (!html.startsWith('<')) {
                    html = '<p>' + html + '</p>';
                }
                
                // Clean up empty paragraphs
                html = html.replace(/<p><\/p>/g, '');
                html = html.replace(/<p>(<h[1-6]>)/g, '$1');
                html = html.replace(/(<\/h[1-6]>)<\/p>/g, '$1');
                html = html.replace(/<p>(<pre>)/g, '$1');
                html = html.replace(/(<\/pre>)<\/p>/g, '$1');
                html = html.replace(/<p>(<ul>)/g, '$1');
                html = html.replace(/(<\/ul>)<\/p>/g, '$1');
                html = html.replace(/<p>(<blockquote>)/g, '$1');
                html = html.replace(/(<\/blockquote>)<\/p>/g, '$1');
                html = html.replace(/<p>(<table>)/g, '$1');
                html = html.replace(/(<\/table>)<\/p>/g, '$1');
                html = html.replace(/<p>(<hr)/g, '$1');
                html = html.replace(/(<hr[^>]*>)<\/p>/g, '$1');
                
                return html;
            } catch (e) {
                console.error('Error parsing markdown:', e);
                return text; // Return original text on error
            }
        }

        // Apply syntax highlighting to HTML content
        function applySyntaxHighlightingToHTML(html) {
            try {
                // Create a temporary container
                const temp = document.createElement('div');
                temp.innerHTML = html;
                
                // Find all text nodes and apply highlighting
                const walker = document.createTreeWalker(
                    temp,
                    NodeFilter.SHOW_TEXT,
                    {
                        acceptNode: function(node) {
                            // Skip nodes inside code, pre, or already highlighted elements
                            const parent = node.parentElement;
                            if (parent.matches('code, pre, .syntax-code, .syntax-code-block, [class^="syntax-"]')) {
                                return NodeFilter.FILTER_REJECT;
                            }
                            return NodeFilter.FILTER_ACCEPT;
                        }
                    },
                    false
                );
                
                const textNodes = [];
                let node;
                while (node = walker.nextNode()) {
                    if (node.textContent.trim()) {
                        textNodes.push(node);
                    }
                }
                
                // Apply highlighting to each text node
                textNodes.forEach(node => {
                    const highlighted = highlightNaturalLanguage(node.textContent);
                    if (highlighted !== node.textContent) {
                        const span = document.createElement('span');
                        span.innerHTML = highlighted;
                        node.parentNode.replaceChild(span, node);
                    }
                });
                
                return temp.innerHTML;
            } catch (e) {
                console.error('Error applying syntax highlighting to HTML:', e);
                return html;
            }
        }

        // Syntax highlighting functions
        function applySyntaxHighlighting(text) {
            // First detect and highlight code blocks
            text = highlightCodeBlocks(text);
            
            // Then apply natural language syntax highlighting
            text = highlightNaturalLanguage(text);
            
            return text;
        }

        function highlightCodeBlocks(text) {
            // Detect inline code with backticks
            text = text.replace(/`([^`]+)`/g, '<span class="syntax-code">$1</span>');
            
            // Detect code blocks with language hints
            const codeBlockRegex = /```(\w+)?\n([\s\S]*?)```/g;
            text = text.replace(codeBlockRegex, (match, lang, code) => {
                const language = lang ? lang.toLowerCase() : 'plain';
                return `<div class="syntax-code-block syntax-${language}">${highlightCode(code.trim(), language)}</div>`;
            });
            
            // Detect Python code patterns
            const pythonRegex = /(def\s+\w+\s*\([^)]*\)|import\s+\w+|from\s+\w+\s+import|print\s*\([^)]*\)|if\s+.*:|for\s+\w+\s+in\s+.*:)/g;
            text = text.replace(pythonRegex, (match) => {
                if (!match.includes('class="syntax-')) {
                    return `<span class="syntax-code syntax-python">${match}</span>`;
                }
                return match;
            });
            
            // Detect JavaScript/function patterns
            const jsRegex = /(function\s+\w+\s*\([^)]*\)|const\s+\w+\s*=|let\s+\w+\s*=|var\s+\w+\s*=|console\.log\([^)]*\)|=>\s*{)/g;
            text = text.replace(jsRegex, (match) => {
                if (!match.includes('class="syntax-')) {
                    return `<span class="syntax-code syntax-javascript">${match}</span>`;
                }
                return match;
            });
            
            return text;
        }

        function highlightCode(code, language) {
            // Basic syntax highlighting for code
            let highlighted = code;
            
            // Keywords
            const keywords = {
                python: /\b(def|class|import|from|if|else|elif|for|while|return|try|except|finally|with|as|lambda|yield|break|continue|pass|raise|assert|del|global|nonlocal|in|is|not|and|or|True|False|None)\b/g,
                javascript: /\b(function|const|let|var|if|else|for|while|return|try|catch|finally|class|extends|new|this|super|import|export|default|async|await|yield|break|continue|throw|typeof|instanceof|in|of|true|false|null|undefined)\b/g,
                general: /\b(if|else|for|while|return|function|class|import|export|const|let|var|true|false|null)\b/g
            };
            
            const keywordRegex = keywords[language] || keywords.general;
            highlighted = highlighted.replace(keywordRegex, '<span class="syntax-keyword">$&</span>');
            
            // Strings
            highlighted = highlighted.replace(/(["'])(?:(?=(\\?))\2.)*?\1/g, '<span class="syntax-string">$&</span>');
            
            // Comments
            if (language === 'python') {
                highlighted = highlighted.replace(/#.*/g, '<span class="syntax-comment">$&</span>');
            } else {
                highlighted = highlighted.replace(/\/\/.*/g, '<span class="syntax-comment">$&</span>');
                highlighted = highlighted.replace(/\/\*[\s\S]*?\*\//g, '<span class="syntax-comment">$&</span>');
            }
            
            // Numbers
            highlighted = highlighted.replace(/\b\d+\.?\d*\b/g, '<span class="syntax-number">$&</span>');
            
            // Functions
            highlighted = highlighted.replace(/(\w+)(?=\s*\()/g, '<span class="syntax-function">$1</span>');
            
            // Operators
            highlighted = highlighted.replace(/([+\-*/%=<>!&|^~?:])/g, '<span class="syntax-operator">$1</span>');
            
            return highlighted;
        }

        function highlightNaturalLanguage(text) {
            // Skip if text already contains syntax highlighting
            if (text.includes('class="syntax-')) {
                return text;
            }
            
            // Common word patterns for parts of speech
            const patterns = {
                // Common verbs (past, present, future tenses)
                verbs: /\b(is|are|was|were|be|been|being|have|has|had|do|does|did|will|would|shall|should|may|might|must|can|could|said|say|says|saying|go|goes|going|went|gone|get|gets|getting|got|make|makes|making|made|take|takes|taking|took|taken|come|comes|coming|came|see|sees|seeing|saw|seen|know|knows|knowing|knew|known|think|thinks|thinking|thought|look|looks|looking|looked|want|wants|wanting|wanted|give|gives|giving|gave|given|use|uses|using|used|find|finds|finding|found|tell|tells|telling|told|ask|asks|asking|asked|work|works|working|worked|seem|seems|seeming|seemed|feel|feels|feeling|felt|try|tries|trying|tried|leave|leaves|leaving|left|call|calls|calling|called)\b/gi,
                
                // Common nouns
                nouns: /\b(time|person|year|way|day|man|thing|woman|life|child|world|school|state|family|student|group|country|problem|hand|part|place|case|week|company|system|program|question|work|government|number|night|point|home|water|room|mother|area|money|story|fact|month|lot|right|study|book|eye|job|word|business|issue|side|kind|head|house|service|friend|father|power|hour|game|line|end|member|law|car|city|community|name)\b/gi,
                
                // Common adjectives
                adjectives: /\b(good|new|first|last|long|great|little|own|other|old|right|big|high|different|small|large|next|early|young|important|few|public|bad|same|able|best|better|sure|clear|easy|hard|hot|cold|full|free|recent|strong|weak|whole|true|false|major|minor|happy|sad|beautiful|ugly|fast|slow|rich|poor|thick|thin)\b/gi,
                
                // Common adverbs
                adverbs: /\b(very|really|quite|just|too|also|never|always|sometimes|often|usually|already|still|even|only|much|however|perhaps|maybe|probably|certainly|definitely|absolutely|extremely|simply|actually|finally|especially|immediately|directly|exactly|completely|entirely|rapidly|quickly|slowly|carefully)\b/gi,
                
                // Pronouns
                pronouns: /\b(i|me|my|mine|myself|you|your|yours|yourself|he|him|his|himself|she|her|hers|herself|it|its|itself|we|us|our|ours|ourselves|they|them|their|theirs|themselves|this|that|these|those|who|whom|whose|which|what|where|when|why|how)\b/gi,
                
                // Numbers
                numbers: /\b\d+\.?\d*\b/g,
                
                // Prepositions
                prepositions: /\b(in|on|at|by|for|with|about|against|between|into|through|during|before|after|above|below|to|from|up|down|out|off|over|under|again|further|then|once|of|as|an|the)\b/gi
            };
            
            // Apply highlighting in order (to avoid conflicts)
            const words = text.split(/(\s+|[.,!?;:])/);
            const highlightedWords = words.map(word => {
                // Skip if already highlighted or is whitespace/punctuation
                if (!word.trim() || /^[.,!?;:\s]+$/.test(word)) {
                    return word;
                }
                
                // Check each pattern
                if (patterns.numbers.test(word)) {
                    return `<span class="syntax-number">${word}</span>`;
                } else if (patterns.pronouns.test(word)) {
                    return `<span class="syntax-pronoun">${word}</span>`;
                } else if (patterns.verbs.test(word)) {
                    return `<span class="syntax-verb">${word}</span>`;
                } else if (patterns.adjectives.test(word)) {
                    return `<span class="syntax-adjective">${word}</span>`;
                } else if (patterns.adverbs.test(word)) {
                    return `<span class="syntax-adverb">${word}</span>`;
                } else if (patterns.prepositions.test(word)) {
                    return `<span class="syntax-preposition">${word}</span>`;
                } else if (patterns.nouns.test(word)) {
                    return `<span class="syntax-noun">${word}</span>`;
                }
                
                return word;
            });
            
            return highlightedWords.join('');
        }

        // Test function for debugging
        function testAllFeatures() {
            console.log('Testing all features...');
            
            // Test theme toggle
            console.log('Theme toggle:', document.body.classList.contains('light-theme') ? 'Light' : 'Dark');
            
            // Test text size
            console.log('Font size:', currentFontSize);
            
            // Test bionic mode
            console.log('Bionic mode:', bionicMode);
            
            // Test focus gradient
            console.log('Focus gradient:', focusGradient);
            
            // Test fullscreen
            console.log('Fullscreen:', isFullscreen);
            
            // Test AI fullscreen
            console.log('AI Fullscreen:', isAIFullscreen);
            
            // Test stats
            console.log('Word count:', words.length);
            console.log('Reading progress:', readingProgress + '%');
            
            // Test pomodoro
            console.log('Pomodoro time:', pomodoroTime);
            
            // Test speed reader
            console.log('WPM:', wordsPerMinute);
            console.log('Current word index:', currentWordIndex);
            
            // Test TTS
            console.log('TTS playing:', isTTSPlaying);
            console.log('TTS rate:', document.getElementById('ttsRate').value);
            
            console.log('All features tested!');
        }

        // Add test function to window for debugging
        window.testReader = testAllFeatures;

        // Comprehensive Unit Testing Suite
        class ZenReaderTestSuite {
            constructor() {
                this.tests = [];
                this.passed = 0;
                this.failed = 0;
                this.errors = [];
            }

            async runAllTests() {
                console.log('üß™ Starting Zen Reader Test Suite...\n');
                this.passed = 0;
                this.failed = 0;
                this.errors = [];

                // Test categories
                await this.testInitialization();
                await this.testFileHandling();
                await this.testTextDisplay();
                await this.testReadingFeatures();
                await this.testAIIntegration();
                await this.testAutoscroll();
                await this.testKeyboardShortcuts();
                await this.testUIComponents();
                await this.testMarkdownParsing();
                await this.testSyntaxHighlighting();
                await this.testStateManagement();
                await this.testEdgeTTS();

                // Summary
                console.log('\nüìä Test Summary:');
                console.log(`‚úÖ Passed: ${this.passed}`);
                console.log(`‚ùå Failed: ${this.failed}`);
                console.log(`üìà Total: ${this.passed + this.failed}`);
                
                if (this.errors.length > 0) {
                    console.log('\nüêõ Errors:');
                    this.errors.forEach((error, index) => {
                        console.error(`${index + 1}. ${error}`);
                    });
                }

                return {
                    passed: this.passed,
                    failed: this.failed,
                    errors: this.errors,
                    success: this.failed === 0
                };
            }

            assert(condition, testName, errorMsg = '') {
                if (condition) {
                    this.passed++;
                    console.log(`‚úÖ ${testName}`);
                } else {
                    this.failed++;
                    console.error(`‚ùå ${testName}`);
                    if (errorMsg) {
                        this.errors.push(`${testName}: ${errorMsg}`);
                    }
                }
            }

            async testInitialization() {
                console.log('\nüîß Testing Initialization...');
                
                // Test API key loading
                const savedKey = localStorage.getItem('geminiApiKey');
                this.assert(
                    apiKey === savedKey || apiKey === 'AIzaSyAYBfMZU6dFu_Qql8nARSTwlNevYCUP15k',
                    'API key initialization',
                    `Expected API key to be loaded, got: ${apiKey ? 'loaded' : 'not loaded'}`
                );

                // Test initial state
                this.assert(currentFontSize === 1.1, 'Initial font size');
                this.assert(wordsPerMinute === 250, 'Initial WPM');
                this.assert(pomodoroTime === 25 * 60, 'Initial pomodoro time');
                this.assert(autoscrollSpeed === 50, 'Initial autoscroll speed');
                this.assert(syntaxHighlightingEnabled === true, 'Syntax highlighting enabled by default');
            }

            async testFileHandling() {
                console.log('\nüìÅ Testing File Handling...');
                
                // Test file reading simulation
                const testText = 'This is a test text for unit testing.';
                const mockFile = new Blob([testText], { type: 'text/plain' });
                mockFile.name = 'test.txt';
                
                // Simulate file read
                currentText = testText;
                isMarkdown = false;
                displayText(currentText);
                
                this.assert(currentText === testText, 'File content loaded');
                this.assert(words.length > 0, 'Words array populated');
                this.assert(document.getElementById('wordCount').textContent !== '0', 'Word count updated');
            }

            async testTextDisplay() {
                console.log('\nüìù Testing Text Display...');
                
                const textContent = document.getElementById('textContent');
                
                // Test plain text display
                displayText('Test plain text');
                this.assert(
                    textContent.textContent.includes('Test plain text'),
                    'Plain text display'
                );

                // Test markdown detection
                isMarkdown = true;
                displayText('# Test Header\n**Bold text**');
                this.assert(
                    textContent.innerHTML.includes('<h1>') || textContent.innerHTML.includes('Test Header'),
                    'Markdown parsing'
                );
                isMarkdown = false;
            }

            async testReadingFeatures() {
                console.log('\nüìñ Testing Reading Features...');
                
                // Test theme toggle
                const initialTheme = document.body.classList.contains('light-theme');
                toggleTheme();
                this.assert(
                    document.body.classList.contains('light-theme') !== initialTheme,
                    'Theme toggle'
                );
                toggleTheme(); // Reset

                // Test text size
                const initialSize = currentFontSize;
                changeTextSize('increase');
                this.assert(currentFontSize > initialSize, 'Increase text size');
                changeTextSize('decrease');
                this.assert(currentFontSize === initialSize, 'Decrease text size');

                // Test bionic mode
                bionicMode = false;
                toggleBionicMode();
                this.assert(bionicMode === true, 'Enable bionic mode');
                toggleBionicMode();
                this.assert(bionicMode === false, 'Disable bionic mode');

                // Test focus gradient
                focusGradient = false;
                toggleFocusGradient();
                this.assert(focusGradient === true, 'Enable focus gradient');
                const textContent = document.getElementById('textContent');
                this.assert(
                    textContent.classList.contains('focus-gradient'),
                    'Focus gradient class applied'
                );
                toggleFocusGradient();

                // Test pomodoro
                const pomodoroWidget = document.getElementById('pomodoroWidget');
                togglePomodoro();
                this.assert(
                    pomodoroWidget.classList.contains('active'),
                    'Pomodoro widget activated'
                );
                togglePomodoro();
            }

            async testAIIntegration() {
                console.log('\nü§ñ Testing AI Integration...');
                
                // Test API key validation
                const testKey = 'AIzaSyAYBfMZU6dFu_Qql8nARSTwlNevYCUP15k';
                this.assert(
                    testKey.startsWith('AIza') && testKey.length >= 30,
                    'API key format validation'
                );

                // Test message addition
                const chatMessages = document.getElementById('chatMessages');
                const initialCount = chatMessages.children.length;
                addMessage('user', 'Test message');
                this.assert(
                    chatMessages.children.length > initialCount,
                    'Add user message'
                );

                addMessage('ai', '**Bold** response with `code`');
                const lastMessage = chatMessages.lastElementChild;
                this.assert(
                    lastMessage.classList.contains('ai'),
                    'Add AI message with correct class'
                );

                // Test AI fullscreen
                isAIFullscreen = false;
                toggleAIFullscreen();
                this.assert(isAIFullscreen === true, 'Enable AI fullscreen');
                const aiPanel = document.getElementById('aiPanel');
                this.assert(
                    aiPanel.classList.contains('fullscreen'),
                    'AI panel fullscreen class'
                );
                toggleAIFullscreen();
            }

            async testAutoscroll() {
                console.log('\nüìú Testing Autoscroll...');
                
                // Set up test content
                currentText = 'Test content for autoscroll testing.';
                displayText(currentText);

                // Test autoscroll controls visibility
                const controls = document.getElementById('autoscrollControls');
                toggleAutoscroll();
                this.assert(
                    controls.classList.contains('active'),
                    'Autoscroll controls activated'
                );

                // Test speed update
                const slider = document.getElementById('autoscrollSpeed');
                slider.value = 100;
                updateAutoscrollSpeed();
                this.assert(
                    autoscrollSpeed === 100,
                    'Autoscroll speed updated'
                );
                this.assert(
                    document.getElementById('autoscrollSpeedValue').textContent === '100 px/s',
                    'Speed display updated'
                );

                // Test autoscroll state
                startAutoscroll();
                this.assert(isAutoscrolling === true, 'Autoscroll started');
                this.assert(autoscrollInterval !== null, 'Autoscroll interval created');
                
                pauseAutoscroll();
                this.assert(autoscrollPaused === true, 'Autoscroll paused');
                
                stopAutoscroll();
                this.assert(isAutoscrolling === false, 'Autoscroll stopped');
                this.assert(autoscrollInterval === null, 'Autoscroll interval cleared');
                
                toggleAutoscroll();
            }

            async testKeyboardShortcuts() {
                console.log('\n‚å®Ô∏è Testing Keyboard Shortcuts...');
                
                // Create keyboard event helper
                const createKeyEvent = (key, ctrlKey = false) => {
                    return new KeyboardEvent('keydown', {
                        key: key,
                        ctrlKey: ctrlKey,
                        preventDefault: () => {}
                    });
                };

                // Test shortcuts (without actually triggering them to avoid UI changes)
                this.assert(typeof toggleFullscreen === 'function', 'Fullscreen shortcut function exists');
                this.assert(typeof startSpeedReader === 'function', 'Speed reader shortcut function exists');
                this.assert(typeof toggleBionicMode === 'function', 'Bionic mode shortcut function exists');
                this.assert(typeof togglePomodoro === 'function', 'Pomodoro shortcut function exists');
                this.assert(typeof toggleTTS === 'function', 'TTS shortcut function exists');
                this.assert(typeof toggleSyntaxHighlighting === 'function', 'Syntax highlighting shortcut function exists');
                this.assert(typeof toggleAIFullscreen === 'function', 'AI fullscreen shortcut function exists');
                this.assert(typeof toggleAutoscroll === 'function', 'Autoscroll shortcut function exists');
            }

            async testUIComponents() {
                console.log('\nüé® Testing UI Components...');
                
                // Test stats bar
                this.assert(
                    document.getElementById('wordCount') !== null,
                    'Word count element exists'
                );
                this.assert(
                    document.getElementById('readingTime') !== null,
                    'Reading time element exists'
                );
                this.assert(
                    document.getElementById('progressPercent') !== null,
                    'Progress percent element exists'
                );
                this.assert(
                    document.getElementById('sessionTime') !== null,
                    'Session time element exists'
                );

                // Test feature menu
                const featuresMenu = document.getElementById('featuresMenu');
                this.assert(featuresMenu !== null, 'Features menu exists');
                
                // Test control buttons
                this.assert(
                    document.querySelectorAll('.feature-item').length >= 10,
                    'All feature menu items present'
                );
            }

            async testMarkdownParsing() {
                console.log('\nüìã Testing Markdown Parsing...');
                
                // Test various markdown elements
                const testCases = [
                    {
                        input: '# Header 1',
                        expected: '<h1>',
                        name: 'H1 header'
                    },
                    {
                        input: '**bold text**',
                        expected: '<strong>',
                        name: 'Bold text'
                    },
                    {
                        input: '*italic text*',
                        expected: '<em>',
                        name: 'Italic text'
                    },
                    {
                        input: '`code snippet`',
                        expected: 'syntax-code',
                        name: 'Inline code'
                    },
                    {
                        input: '[link](http://example.com)',
                        expected: '<a href=',
                        name: 'Link'
                    },
                    {
                        input: '- list item',
                        expected: '<li>',
                        name: 'List item'
                    }
                ];

                testCases.forEach(test => {
                    const result = parseAIMarkdown(test.input);
                    this.assert(
                        result.includes(test.expected),
                        `Markdown: ${test.name}`,
                        `Expected "${test.expected}" in result`
                    );
                });

                // Test code block
                const codeBlock = '```python\ndef test():\n    pass\n```';
                const codeResult = parseAIMarkdown(codeBlock);
                this.assert(
                    codeResult.includes('syntax-code-block') && codeResult.includes('language-python'),
                    'Code block with language'
                );
            }

            async testSyntaxHighlighting() {
                console.log('\nüåà Testing Syntax Highlighting...');
                
                // Test natural language highlighting
                const nlTest = 'The quick brown fox jumps over the lazy dog.';
                const nlResult = highlightNaturalLanguage(nlTest);
                this.assert(
                    nlResult.includes('syntax-'),
                    'Natural language highlighting applied'
                );

                // Test code highlighting
                const codeTest = 'function test() { return true; }';
                const codeResult = highlightCode(codeTest, 'javascript');
                this.assert(
                    codeResult.includes('syntax-keyword') && codeResult.includes('syntax-function'),
                    'Code syntax highlighting'
                );

                // Test toggle functionality
                syntaxHighlightingEnabled = true;
                toggleSyntaxHighlighting();
                this.assert(
                    syntaxHighlightingEnabled === false,
                    'Syntax highlighting toggled off'
                );
                toggleSyntaxHighlighting();
                this.assert(
                    syntaxHighlightingEnabled === true,
                    'Syntax highlighting toggled on'
                );
            }

            async testStateManagement() {
                console.log('\nüíæ Testing State Management...');
                
                // Test session timer
                this.assert(sessionInterval !== null, 'Session timer initialized');
                
                // Test reading progress calculation
                const textDisplay = document.getElementById('textDisplay');
                textDisplay.scrollTop = 0;
                updateProgressPercent();
                this.assert(
                    parseFloat(document.getElementById('progressPercent').textContent) >= 0,
                    'Reading progress calculation'
                );

                // Test feature state updates
                updateFeatureItemState('theme', true);
                const themeItem = document.querySelectorAll('.feature-item')[6];
                this.assert(
                    themeItem && themeItem.classList.contains('active'),
                    'Feature item state update'
                );
                updateFeatureItemState('theme', false);
            }

            async testEdgeTTS() {
                console.log('\nüîä Testing Edge TTS Integration...');
                
                // Test initial state
                this.assert(ttsEngine === 'browser', 'Default TTS engine is browser');
                this.assert(edgeVoice === 'en-US-JennyNeural', 'Default Edge voice');
                this.assert(edgeAudio === null, 'Edge audio initially null');
                this.assert(isEdgeTTSPlaying === false, 'Edge TTS not playing initially');
                
                // Test UI elements
                this.assert(
                    document.getElementById('browserTTSBtn') !== null,
                    'Browser TTS button exists'
                );
                this.assert(
                    document.getElementById('edgeTTSBtn') !== null,
                    'Edge TTS button exists'
                );
                this.assert(
                    document.getElementById('edgeVoiceSelector') !== null,
                    'Edge voice selector exists'
                );
                this.assert(
                    document.getElementById('edgeTTSStatus') !== null,
                    'Edge TTS status element exists'
                );
                
                // Test engine switching
                switchTTSEngine('edge');
                this.assert(ttsEngine === 'edge', 'Switch to Edge TTS engine');
                this.assert(
                    document.getElementById('edgeTTSBtn').classList.contains('active'),
                    'Edge TTS button active'
                );
                this.assert(
                    document.getElementById('edgeTTSOptions').classList.contains('active'),
                    'Edge TTS options visible'
                );
                
                // Test voice selection
                const voiceSelector = document.getElementById('edgeVoiceSelector');
                voiceSelector.value = 'en-GB-SoniaNeural';
                updateEdgeVoice();
                this.assert(
                    edgeVoice === 'en-GB-SoniaNeural',
                    'Edge voice selection'
                );
                
                // Test Edge TTS API mock
                currentText = 'Test text for Edge TTS';
                const response = await generateEdgeTTSAudio(currentText, edgeVoice);
                this.assert(
                    typeof response === 'object',
                    'Edge TTS API returns response object'
                );
                this.assert(
                    response.ok === false,
                    'Mock Edge TTS API simulates failure for fallback test'
                );
                
                // Test rate control
                const rateSlider = document.getElementById('ttsRate');
                rateSlider.value = 1.5;
                updateTTSRate();
                this.assert(
                    document.getElementById('ttsRateValue').textContent === '1.5x',
                    'TTS rate update'
                );
                
                // Test cleanup functions
                this.assert(typeof stopEdgeTTS === 'function', 'stopEdgeTTS function exists');
                this.assert(typeof pauseEdgeTTS === 'function', 'pauseEdgeTTS function exists');
                
                // Reset to browser TTS
                switchTTSEngine('browser');
                this.assert(ttsEngine === 'browser', 'Switch back to browser TTS');
                
                // Reset voice
                edgeVoice = 'en-US-JennyNeural';
            }
        }

        // Initialize test suite
        window.zenReaderTests = new ZenReaderTestSuite();
        
        // Auto-run tests in development mode
        if (debugMode) {
            console.log('Debug mode enabled. Run window.zenReaderTests.runAllTests() to execute test suite.');
        }

        // Quick test runner
        window.runTests = async function() {
            console.log('üöÄ Running Zen Reader Tests...\n');
            const results = await window.zenReaderTests.runAllTests();
            
            // Additional manual checks
            console.log('\nüîç Additional Checks:');
            
            // Check for memory leaks
            const intervals = [sessionInterval, pomodoroInterval, speedInterval, autoscrollInterval];
            const activeIntervals = intervals.filter(i => i !== null).length;
            console.log(`‚è±Ô∏è Active intervals: ${activeIntervals}`);
            
            // Check DOM elements
            const criticalElements = [
                'textContent', 'chatMessages', 'wordCount', 'readingTime',
                'progressPercent', 'sessionTime', 'featuresMenu', 'apiKey'
            ];
            const missingElements = criticalElements.filter(id => !document.getElementById(id));
            if (missingElements.length === 0) {
                console.log('‚úÖ All critical DOM elements present');
            } else {
                console.error('‚ùå Missing DOM elements:', missingElements);
            }
            
            // Check event listeners
            console.log('‚úÖ Event listeners attached');
            
            // Performance check
            const loadTime = performance.now();
            console.log(`‚ö° Page load time: ${Math.round(loadTime)}ms`);
            
            return results;
        };

        // Debug helper to reset all states
        window.resetAllStates = function() {
            // Stop all active features
            stopAutoscroll();
            stopTTS();
            stopEdgeTTS();
            stopSpeedReading();
            pausePomodoro();
            
            // Reset UI states
            if (isFullscreen) exitFullscreen();
            if (isAIFullscreen) toggleAIFullscreen();
            if (document.getElementById('speedReaderModal').classList.contains('active')) {
                closeSpeedReader();
            }
            
            // Reset TTS engine to default
            switchTTSEngine('browser');
            
            // Reset variables
            currentText = '';
            words = [];
            readingProgress = 0;
            currentWordIndex = 0;
            
            // Clear chat
            document.getElementById('chatMessages').innerHTML = '';
            
            // Reset displays
            document.getElementById('textContent').innerHTML = '';
            document.getElementById('wordCount').textContent = '0';
            document.getElementById('readingTime').textContent = '0 min';
            document.getElementById('progressPercent').textContent = '0%';
            
            console.log('‚úÖ All states reset');
        };
    </script>
</body>
</html>